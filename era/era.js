"use strict";
function create(ctor, props) {
    return Object.assign(new ctor(), props);
}
function assign(obj, props) {
    return Object.assign(obj, props);
}
var Core;
(function (Core) {
    class Object {
        serialize() {
            return JSON.stringify(this);
        }
        getClassName() {
            if ('name' in this.constructor)
                return this.constructor['name'];
            else {
                let matches = /function (.{1,})\(/.exec(this.constructor.toString());
                return matches ? matches[1] : this.constructor.toString();
            }
        }
        assign(props) {
            return assign(this, props);
        }
        toString() {
            return `[object ${this.getClassName()}]`;
        }
    }
    Core.Object = Object;
})(Core || (Core = {}));
var Core;
(function (Core) {
    class Events {
        constructor() {
            this.list = new Array();
        }
        connect(handler, capture = false) {
            let id = ++Events.handlerGenerator;
            this.list.push({ handler: handler, capture: capture, id: id });
            return id;
        }
        disconnect(handler) {
            for (let i = 0; i < this.list.length; i++) {
                if (this.list[i].handler === handler || this.list[i].id === handler) {
                    this.list.splice(i, 1);
                    break;
                }
            }
        }
        fire(event) {
            for (let handler of this.list.slice())
                handler.handler(event);
        }
    }
    Events.handlerGenerator = 0;
    Core.Events = Events;
})(Core || (Core = {}));
var DEBUG = true;
var htmlNS = "http://www.w3.org/1999/xhtml";
var svgNS = "http://www.w3.org/2000/svg";
var Core;
(function (Core) {
    class Util {
        static clone(obj) {
            if (obj === undefined)
                return undefined;
            if (obj === null || typeof (obj) !== 'object')
                return null;
            var clone = {};
            for (var prop in obj)
                clone[prop] = obj[prop];
            return clone;
        }
        static encodeURIQuery(obj) {
            let args = '';
            let encodeArg = (arg, value) => {
                if ((typeof (value) !== 'number') && (typeof (value) !== 'string') && (typeof (value) !== 'boolean') && (typeof (value) !== 'object'))
                    return;
                if (args !== '')
                    args += '&';
                args += encodeURIComponent(arg) + '=';
                if (typeof (value) === 'object')
                    args += encodeURIComponent(JSON.stringify(value));
                else
                    args += encodeURIComponent(value);
            };
            if ((obj !== undefined) && (obj !== null)) {
                for (let prop in obj) {
                    let propValue = obj[prop];
                    if (propValue instanceof Array) {
                        for (let value of propValue)
                            encodeArg(prop, value);
                    }
                    else
                        encodeArg(prop, propValue);
                }
            }
            return args;
        }
        static utf8Encode(value) {
            var res = '';
            for (var i = 0; i < value.length; i++) {
                var c = value.charCodeAt(i);
                if (c < 128)
                    res += String.fromCharCode(c);
                else if ((c >= 128) && (c < 2048)) {
                    res += String.fromCharCode((c >> 6) | 192);
                    res += String.fromCharCode((c & 63) | 128);
                }
                else {
                    res += String.fromCharCode((c >> 12) | 224);
                    res += String.fromCharCode(((c >> 6) & 63) | 128);
                    res += String.fromCharCode((c & 63) | 128);
                }
            }
            return res;
        }
        static utf8Decode(value) {
            let res = '';
            let i = 0;
            let c;
            while (i < value.length) {
                c = value.charCodeAt(i++);
                if (c < 128)
                    res += String.fromCharCode(c);
                else if ((c >= 192) && (c < 224))
                    res += String.fromCharCode(((c & 31) << 6) | (value.charCodeAt(i++) & 63));
                else
                    res += String.fromCharCode(((c & 15) << 12) | ((value.charCodeAt(i++) & 63) << 6) | (value.charCodeAt(i++) & 63));
            }
            return res;
        }
        static toBase64(stringValue) {
            let val1;
            let val2;
            let val3;
            let enc1;
            let enc2;
            let enc3;
            let enc4;
            let value = Util.utf8Encode(stringValue);
            let code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            let res = '';
            let i = 0;
            while (i + 2 < value.length) {
                val1 = value.charCodeAt(i++) & 0xff;
                val2 = value.charCodeAt(i++) & 0xff;
                val3 = value.charCodeAt(i++) & 0xff;
                enc1 = code.charAt(val1 >> 2);
                enc2 = code.charAt(((val1 & 3) << 4) | (val2 >> 4));
                enc3 = code.charAt(((val2 & 15) << 2) | (val3 >> 6));
                enc4 = code.charAt(val3 & 63);
                res += enc1 + enc2 + enc3 + enc4;
            }
            if (i + 1 < value.length) {
                val1 = value.charCodeAt(i++) & 0xff;
                val2 = value.charCodeAt(i++) & 0xff;
                enc1 = code.charAt(val1 >> 2);
                enc2 = code.charAt(((val1 & 3) << 4) | (val2 >> 4));
                enc3 = code.charAt((val2 & 15) << 2);
                res += enc1 + enc2 + enc3 + '=';
            }
            else if (i < value.length) {
                val1 = value.charCodeAt(i++) & 0xff;
                enc1 = code.charAt(val1 >> 2);
                enc2 = code.charAt((val1 & 3) << 4);
                res += enc1 + enc2 + '==';
            }
            return res;
        }
        static fromBase64(value) {
            let char1;
            let char2;
            let char3;
            let enc1;
            let enc2;
            let enc3;
            let enc4;
            let code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            let res = '';
            let i = 0;
            while (i < value.length) {
                enc1 = code.indexOf(value.charAt(i++));
                enc2 = code.indexOf(value.charAt(i++));
                enc3 = code.indexOf(value.charAt(i++));
                enc4 = code.indexOf(value.charAt(i++));
                char1 = (enc1 << 2) | (enc2 >> 4);
                char2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                char3 = ((enc3 & 3) << 6) | enc4;
                res += String.fromCharCode(char1);
                if (enc3 !== 64) {
                    res += String.fromCharCode(char2);
                    if (enc4 !== 64)
                        res += String.fromCharCode(char3);
                }
            }
            return Util.utf8Decode(res);
        }
        static toNoDiacritics(value) {
            return value.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }
    }
    Core.Util = Util;
    class Navigator {
    }
    Navigator.isGecko = (navigator.userAgent.match(/Gecko\//i) !== null);
    Navigator.isWebkit = (navigator.userAgent.match(/WebKit\//i) !== null);
    Navigator.isOpera = ((navigator.userAgent === undefined) || (navigator.userAgent.match(/Opera\//i) !== null));
    Navigator.isChrome = (navigator.userAgent.match(/ Chrome\//) !== null);
    Navigator.isSafari = (navigator.userAgent.match(/ Safari\//) !== null);
    Navigator.isFirefox = (navigator.userAgent.match(/ Firefox\//) !== null);
    Navigator.iPad = (navigator.userAgent.match(/iPad/i) !== null);
    Navigator.iPhone = (navigator.userAgent.match(/iPhone/i) !== null);
    Navigator.iOs = Navigator.iPad || Navigator.iPhone;
    Navigator.Android = (navigator.userAgent.match(/Android/i) !== null);
    Navigator.supportWebP = true;
    Core.Navigator = Navigator;
})(Core || (Core = {}));
(function () {
    let testCanvas = document.createElement('canvas');
    if (!!(testCanvas.getContext && testCanvas.getContext('2d'))) {
        Core.Navigator.supportWebP = testCanvas.toDataURL('image/webp').indexOf('data:image/webp') == 0;
    }
    else
        Core.Navigator.supportWebP = false;
})();
if (!window.ResizeObserver) {
    if (window.MutationObserver) {
        function EmuResizeObserver(callback) {
            this.callback = callback;
            this.observe = function (element) {
                if (this.elements == undefined)
                    this.elements = [];
                let data = {
                    element: element,
                    width: 0, height: 0,
                };
                let observer = new MutationObserver(() => {
                    if ((data.width != data.element.offsetWidth) || (data.height != data.element.offsetHeight)) {
                        data.width = data.element.offsetWidth;
                        data.height = data.element.offsetHeight;
                        this.callback();
                    }
                });
                observer.observe(element, {
                    attributes: true
                });
            };
            this.disconnect = function () { };
            this.unobserve = function (target) { };
        }
        ;
        window.ResizeObserver = EmuResizeObserver;
    }
}
var Core;
(function (Core) {
    class Uri extends Core.Object {
        constructor(uri = null) {
            super();
            let fullpath = true;
            let baseURI;
            if ('baseURI' in document)
                baseURI = document.baseURI;
            else
                baseURI = document.location.href;
            if (uri == null)
                uri = baseURI;
            let res = uri.match(/^([^:\/]+):\/\/([^\/]+)(\/.*)$/);
            if (res === null) {
                fullpath = false;
                res = baseURI.match(/^([^:\/]+):\/\/([^\/]+)(\/.*)$/);
                if (res == null)
                    throw `Invalid uri ${uri}`;
            }
            this.scheme = res[1];
            var authority = res[2];
            var path = res[3];
            res = authority.match(/^(.+):(.+)@(.*)$/);
            if (res !== null) {
                this.user = res[1];
                this.password = res[2];
                authority = res[3];
            }
            res = authority.match(/^(.+):(.+)$/);
            if (res !== null) {
                authority = res[1];
                this.port = parseInt(res[2]);
            }
            else {
                if (this.scheme == 'https')
                    this.port = 443;
                else
                    this.port = 80;
            }
            this.host = authority;
            if (fullpath)
                this.path = path;
            else {
                if (uri.indexOf('/') === 0)
                    this.path = Uri.cleanPath(uri);
                else
                    this.path = Uri.mergePath(path, uri);
            }
        }
        getScheme() {
            return this.scheme;
        }
        getUser() {
            return this.user;
        }
        getPassword() {
            return this.password;
        }
        getHost() {
            return this.host;
        }
        getPort() {
            return this.port;
        }
        getPath() {
            return this.path;
        }
        getQuery() {
            return this.query;
        }
        getFragment() {
            return this.fragment;
        }
        toString() {
            var str = this.scheme + '://';
            if ((this.user !== undefined) && (this.password !== undefined))
                str += this.user + ':' + this.password + '@';
            str += this.host;
            if (this.port !== undefined)
                str += ':' + this.port;
            str += this.path;
            return str;
        }
        static cleanPath(path) {
            while (path.match(/\/([^\/]*)\/\.\.\//))
                path = path.replace(/\/([^\/]*)\/\.\.\//, '/');
            while (path.match(/\/\//))
                path = path.replace(/\/\//, '/');
            while (path.match(/\/\.\//))
                path = path.replace(/\/\.\//, '/');
            return path;
        }
        static mergePath(base, relative) {
            let matches = base.match(/^(.*)\//);
            var dir = matches ? matches[0] : base;
            dir += relative;
            return Uri.cleanPath(dir);
        }
    }
    Core.Uri = Uri;
})(Core || (Core = {}));
var Core;
(function (Core) {
    class DoubleLinkedListNode {
        constructor(data) {
            this.data = data;
        }
    }
    Core.DoubleLinkedListNode = DoubleLinkedListNode;
    class DoubleLinkedList {
        getLength() {
            return this.length;
        }
        getFirstNode() {
            return this.root;
        }
        getLastNode() {
            if (this.root === undefined)
                return undefined;
            else
                return this.root.previous;
        }
        appendNode(node) {
            if (this.root === undefined) {
                node.previous = node;
                node.next = node;
                this.root = node;
            }
            else {
                node.previous = this.root.previous;
                node.next = this.root;
                this.root.previous.next = node;
                this.root.previous = node;
            }
            this.length++;
            return node;
        }
        prependNode(node) {
            if (this.root === undefined) {
                node.previous = node;
                node.next = node;
                this.root = node;
            }
            else {
                node.previous = this.root.previous;
                node.next = this.root;
                this.root.previous.next = node;
                this.root.previous = node;
                this.root = node;
            }
            this.length++;
            return node;
        }
        removeNode(node) {
            if (this.root === node) {
                if (node.next === node)
                    this.root = undefined;
                else {
                    node.next.previous = node.previous;
                    node.previous.next = node.next;
                    this.root = node.next;
                }
            }
            else {
                node.next.previous = node.previous;
                node.previous.next = node.next;
            }
            node.next = node;
            node.previous = node;
            this.length--;
        }
        findNode(data) {
            if (this.root === undefined)
                return undefined;
            let current = this.root;
            while (current.next !== this.root) {
                if (current.data === data)
                    return current;
                current = current.next;
            }
            return undefined;
        }
        getFirst() {
            let firstNode = this.getFirstNode();
            if (firstNode === undefined)
                return undefined;
            else
                return firstNode.data;
        }
        getLast() {
            let lastNode = this.getLastNode();
            if (lastNode === undefined)
                return undefined;
            else
                return lastNode.data;
        }
        append(data) {
            return this.appendNode(new DoubleLinkedListNode(data));
        }
        prepend(data) {
            return this.prependNode(new DoubleLinkedListNode(data));
        }
        remove(data) {
            let node = this.findNode(data);
            if (node !== undefined)
                this.removeNode(node);
        }
        clear() {
            this.root = undefined;
        }
        static moveNext(node) {
            if (node !== undefined)
                return node.next;
            else
                return undefined;
        }
        isLast(node) {
            if (node === undefined)
                return true;
            else
                return node.next === this.root;
        }
    }
    Core.DoubleLinkedList = DoubleLinkedList;
})(Core || (Core = {}));
var Core;
(function (Core) {
    class HttpRequest extends Core.Object {
        constructor(init) {
            super();
            this.url = null;
            this.method = 'GET';
            this.binary = false;
            this.content = undefined;
            this.error = new Core.Events();
            this.done = new Core.Events();
            this.request = new XMLHttpRequest();
            let wrapper = () => {
                if (this.request.readyState == 4) {
                    if ((this.request.status >= 200) && (this.request.status < 300))
                        this.done.fire({ target: this });
                    else
                        this.error.fire({ target: this, code: this.request.status });
                }
            };
            this.request.onreadystatechange = wrapper;
            if (init) {
                if (init.url !== undefined)
                    this.url = init.url;
                if (init.method !== undefined)
                    this.method = init.method;
                if (init.binary !== undefined)
                    this.binary = init.binary;
                if (init.arguments !== undefined)
                    this.arguments = init.arguments;
                if (init.content !== undefined)
                    this.content = init.content;
                if (init.headers !== undefined)
                    this.headers = init.headers;
                if (init.ondone)
                    this.done.connect(init.ondone);
                if (init.onerror)
                    this.error.connect(init.onerror);
            }
        }
        set onerror(value) { this.error.connect(value); }
        set ondone(value) { this.done.connect(value); }
        set headers(headers) {
            this._headers = Core.Util.clone(headers);
        }
        get headers() {
            return this._headers;
        }
        setRequestHeader(header, value) {
            if (this.headers === undefined)
                this.headers = {};
            this.headers[header] = value;
        }
        addArgument(argName, argValue) {
            if (this.arguments === undefined)
                this.arguments = {};
            this.arguments[argName] = argValue;
        }
        abort() {
            this.request.abort();
        }
        send() {
            if (this.url == undefined)
                throw ('url MUST be given for an HttpRequest');
            let header;
            let args = '';
            if (this.arguments !== undefined)
                args = Core.Util.encodeURIQuery(this.arguments);
            let url = this.url;
            if (((this.method === 'GET') || (this.method === 'DELETE') || (this.content !== undefined)) && (args !== '')) {
                if (this.url.indexOf('?') === -1)
                    url += '?' + args;
                else
                    url += '&' + args;
            }
            this.request.open(this.method, url, true);
            if (this.binary)
                this.request.overrideMimeType('text/plain; charset=x-user-defined');
            if (HttpRequest.requestHeaders !== undefined) {
                for (header in HttpRequest.requestHeaders)
                    this.request.setRequestHeader(header, HttpRequest.requestHeaders[header]);
            }
            if (this.headers !== undefined) {
                for (header in this.headers)
                    this.request.setRequestHeader(header, this.headers[header]);
            }
            if (this.content !== undefined) {
                if ((this.headers === undefined) || (this.headers["Content-Type"] === undefined))
                    this.request.setRequestHeader('Content-Type', 'text/plain; charset=utf-8');
                this.request.send(this.content);
            }
            else if ((args !== '') && ((this.method === 'POST') || (this.method === 'PUT'))) {
                if ((this.headers === undefined) || (this.headers["Content-Type"] === undefined))
                    this.request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
                this.request.send(args);
            }
            else
                this.request.send();
        }
        sendAsync() {
            return new Promise(resolve => {
                this.done.connect(() => resolve(this));
                this.error.connect(() => resolve(this));
                this.send();
            });
        }
        waitAsync() {
            return new Promise(resolve => {
                this.done.connect(() => resolve(this));
                this.error.connect(() => resolve(this));
            });
        }
        getResponseHeader(header) {
            return this.request.getResponseHeader(header);
        }
        get responseType() {
            return this.request.responseType;
        }
        set responseType(value) {
            this.request.responseType = value;
        }
        get response() {
            return this.request.response;
        }
        get responseText() {
            return this.request.responseText;
        }
        get responseBase64() {
            return Core.Util.toBase64(this.request.responseText);
        }
        get responseJSON() {
            let res;
            try {
                res = JSON.parse(this.responseText);
            }
            catch (err) {
                res = undefined;
            }
            return res;
        }
        get responseXML() {
            let parser = new DOMParser();
            try {
                let xmlDoc = parser.parseFromString(this.responseText, 'text/xml');
                return xmlDoc;
            }
            catch (e) { }
            return parser.parseFromString('', 'text/xml');
        }
        get status() {
            return this.request.status;
        }
        static setRequestHeader(header, value) {
            if (HttpRequest.requestHeaders === undefined)
                HttpRequest.requestHeaders = {};
            HttpRequest.requestHeaders[header] = value;
        }
    }
    HttpRequest.requestHeaders = undefined;
    Core.HttpRequest = HttpRequest;
})(Core || (Core = {}));
var Core;
(function (Core) {
    class DelayedTask extends Core.Object {
        constructor(delay, callback) {
            super();
            this.isDone = false;
            this.delay = delay;
            this.callback = callback;
            this.handle = setTimeout(() => {
                this.handle = undefined;
                this.isDone = true;
                this.callback(this);
            }, this.delay * 1000);
        }
        abort() {
            if (this.handle !== undefined) {
                clearTimeout(this.handle);
                this.handle = undefined;
            }
        }
    }
    Core.DelayedTask = DelayedTask;
})(Core || (Core = {}));
var Core;
(function (Core) {
    class Timer extends Core.Object {
        constructor(init) {
            super();
            this.interval = 1;
            this.timeupdated = new Core.Events();
            if (init) {
                if (init.interval !== undefined)
                    this.interval = init.interval;
                if (init.arguments !== undefined)
                    this.arguments = init.arguments;
                else
                    this.arguments = [];
            }
            let wrapper = () => {
                var startTime = (new Date().getTime()) / 1000;
                this.timeupdated.fire({ target: this, arguments: this.arguments });
                var endTime = (new Date().getTime()) / 1000;
                var deltaTime = endTime - startTime;
                if (deltaTime < 0)
                    deltaTime = 0;
                var interval = (this.interval * 1000) - deltaTime;
                if (interval < 0)
                    interval = 0;
                if (this.handle !== undefined)
                    this.handle = setTimeout(wrapper, interval);
            };
            this.handle = setTimeout(wrapper, 0);
        }
        set ontimeupdated(value) { this.timeupdated.connect(value); }
        abort() {
            if (this.handle !== undefined) {
                clearTimeout(this.handle);
                this.handle = undefined;
            }
        }
    }
    Core.Timer = Timer;
})(Core || (Core = {}));
var Core;
(function (Core) {
    class Socket extends Core.Object {
        constructor(init) {
            super();
            this.service = '/';
            this.port = 80;
            this.secure = false;
            this.lastPosition = 0;
            this.readSize = true;
            this.size = 0;
            this.data = '';
            this.isClosed = false;
            this.closeSent = false;
            this.sep = '?';
            this.pollInterval = 2.5;
            this.error = new Core.Events();
            this.message = new Core.Events();
            this.closed = new Core.Events();
            this.opened = new Core.Events();
            this.onWebSocketOpen = () => {
                if (this.websocketdelay !== undefined) {
                    this.websocketdelay.abort();
                    this.websocketdelay = undefined;
                }
                this.opened.fire({ target: this });
            };
            this.onWebSocketError = () => {
                if (this.websocketdelay !== undefined) {
                    this.websocketdelay.abort();
                    this.websocketdelay = undefined;
                }
                this.error.fire({ target: this });
            };
            this.onWebSocketMessage = (msg) => {
                if (msg.data === 'PING')
                    this.websocket.send('PONG');
                else
                    this.message.fire({ target: this, message: msg.data });
            };
            this.onWebSocketClose = (msg) => {
                if (this.websocketdelay !== undefined) {
                    this.websocketdelay.abort();
                    this.websocketdelay = undefined;
                }
                this.closed.fire({ target: this });
            };
            if (init.host !== undefined)
                this.host = init.host;
            else
                this.host = document.location.hostname;
            if (init.secure !== undefined)
                this.secure = init.secure;
            else
                this.secure = (document.location.protocol === 'https:');
            if (init.port !== undefined)
                this.port = init.port;
            else if ((document.location.port !== undefined) && (document.location.port !== ''))
                this.port = parseInt(document.location.port);
            else {
                if (this.secure)
                    this.port = 443;
                else
                    this.port = 80;
            }
            if (init.service !== undefined) {
                this.service = init.service;
                if (this.service.indexOf('?') == -1)
                    this.sep = '?';
                else
                    this.sep = '&';
            }
            if (init.mode !== undefined)
                this.mode = init.mode;
            else {
                if (Core.Socket.supportWebSocket)
                    this.mode = 'websocket';
                else
                    this.mode = 'poll';
            }
            if (this.mode == 'websocket') {
                this.websocket = new WebSocket((this.secure ? 'wss' : 'ws') + '://' + this.host + ':' + this.port + this.service);
                this.websocketdelay = new Core.DelayedTask(30, this.onWebSocketOpenTimeout);
                this.websocket.addEventListener('open', this.onWebSocketOpen);
                this.websocket.addEventListener('error', this.onWebSocketError);
                this.websocket.addEventListener('message', this.onWebSocketMessage);
                this.websocket.addEventListener('close', this.onWebSocketClose);
            }
            else {
                this.emumessages = [];
                var url = (this.secure ? 'https' : 'http') + '://' + this.host + ':' + this.port + this.service + this.sep + 'socket=poll&command=open';
                this.emuopenrequest = new Core.HttpRequest({
                    url: url,
                    ondone: e => this.onEmuSocketOpenDone(),
                    onerror: e => this.onEmuSocketOpenError(e.target, e.code)
                });
                this.emuopenrequest.send();
            }
        }
        set onerror(value) { this.error.connect(value); }
        set onmessage(value) { this.message.connect(value); }
        set onclosed(value) { this.closed.connect(value); }
        set onopened(value) { this.opened.connect(value); }
        send(msg) {
            if (this.websocket !== undefined) {
                this.websocket.send(msg);
            }
            else {
                if (this.emusendrequest === undefined) {
                    var url = (this.secure ? 'https' : 'http') + '://' + this.host + ':' + this.port + this.service + this.sep + 'socket=' + this.mode + '&command=send&id=' + this.emuid + '&messages=' + encodeURIComponent(msg.toBase64());
                    this.emusendrequest = new Core.HttpRequest({
                        url: url,
                        ondone: e => this.onEmuSocketSendDone(),
                        onerror: e => this.onEmuSocketSendError()
                    });
                    this.emusendrequest.send();
                    if (this.delayPollTask !== undefined) {
                        this.delayPollTask.abort();
                        this.delayPollTask = new Core.DelayedTask(0.1, this.delayPollDone);
                    }
                }
                else
                    this.emumessages.push(msg.toBase64());
            }
        }
        close() {
            if (this.delayPollTask !== undefined) {
                this.delayPollTask.abort();
                this.delayPollTask = undefined;
            }
            if (this.websocket !== undefined) {
                this.isClosed = true;
                this.websocket.close();
            }
            else {
                if (!this.isClosed) {
                    this.isClosed = true;
                    if (this.emuopenrequest !== undefined) {
                        this.emuopenrequest.abort();
                        this.emuopenrequest = undefined;
                    }
                    else if (this.emuid !== undefined) {
                        if (this.emusendrequest === undefined) {
                            this.closeSent = true;
                            this.emusendrequest = new Core.HttpRequest({
                                url: (this.secure ? 'https' : 'http') + '://' + this.host + ':' + this.port + this.service + this.sep + 'socket=' + this.mode + '&command=close&id=' + this.emuid,
                                ondone: e => this.onEmuSocketSendDone(),
                                onerror: e => this.onEmuSocketSendError()
                            });
                            this.emusendrequest.send();
                        }
                    }
                }
            }
        }
        onWebSocketOpenTimeout() {
            this.websocketdelay = undefined;
            this.websocket.removeEventListener('open', this.onWebSocketOpen);
            this.websocket.removeEventListener('error', this.onWebSocketError);
            this.websocket.removeEventListener('message', this.onWebSocketMessage);
            this.websocket.removeEventListener('close', this.onWebSocketClose);
            this.websocket.close();
            this.websocket = undefined;
            this.mode = 'poll';
            this.emumessages = [];
            this.emuopenrequest = new Core.HttpRequest({
                url: (this.secure ? 'https' : 'http') + '://' + this.host + ':' + this.port + this.service + this.sep + 'socket=poll&command=open',
                ondone: e => this.onEmuSocketOpenDone(),
                onerror: e => this.onEmuSocketOpenError(e.target, e.code)
            });
            this.emuopenrequest.send();
        }
        emuSocketDataAvailable(data) {
            if (this.emuid === undefined) {
                this.emuid = data;
                this.opened.fire({ target: this });
            }
            else {
                if (data !== 'keepalive')
                    this.message.fire({ target: this, message: data.fromBase64() });
            }
        }
        emuSocketUpdate(delta) {
            for (var i = 0; i < delta.length; i++) {
                var character = delta[i];
                if (this.readSize) {
                    if (character === ':') {
                        this.readSize = false;
                        this.size = parseInt('0x' + this.data);
                        this.data = '';
                    }
                    else
                        this.data += character;
                }
                else {
                    this.data += character;
                    if (this.data.length >= this.size + 2) {
                        this.emuSocketDataAvailable(this.data.substring(0, this.data.length - 2));
                        this.readSize = true;
                        this.data = '';
                    }
                }
            }
        }
        onEmuSocketSendDone() {
            var response = this.emusendrequest.getResponseJSON();
            if (this.emumessages.length > 0) {
                var messages = '';
                for (var i = 0; i < this.emumessages.length; i++) {
                    if (messages !== '')
                        messages += ';';
                    messages += this.emumessages[i];
                }
                this.emusendrequest = new Core.HttpRequest({
                    url: (this.secure ? 'https' : 'http') + '://' + this.host + ':' + this.port + this.service + this.sep + 'socket=' + this.mode + '&command=send&id=' + this.emuid + '&messages=' + encodeURIComponent(messages),
                    ondone: e => this.onEmuSocketSendDone(),
                    onerror: e => this.onEmuSocketSendError()
                });
                this.emusendrequest.send();
                this.emumessages = [];
            }
            else if (this.isClosed && !this.closeSent) {
                this.emusendrequest = new Core.HttpRequest({
                    url: (this.secure ? 'https' : 'http') + '://' + this.host + ':' + this.port + this.service + this.sep + 'socket=' + this.mode + '&command=close&id=' + this.emuid,
                    ondone: e => this.onEmuSocketSendDone(),
                    onerror: e => this.onEmuSocketSendError()
                });
                this.emusendrequest.send();
            }
            else
                this.emusendrequest = undefined;
        }
        onEmuSocketSendError() {
            this.emusendrequest = undefined;
        }
        onEmuSocketOpenDone() {
            this.lastPoll = new Date();
            var response = this.emuopenrequest.getResponseJSON();
            this.emuopenrequest = undefined;
            if (response === undefined) {
                this.error.fire({ target: this });
                this.closed.fire({ target: this });
            }
            else {
                this.emuid = response.id;
                if ('keepAliveInterval' in response)
                    this.pollInterval = Math.min(response.keepAliveInterval, 2.5);
                if (response.status != 'open') {
                    this.error.fire({ target: this });
                    this.closed.fire({ target: this });
                }
                else {
                    this.opened.fire({ target: this });
                    this.emupollrequest = new Core.HttpRequest({
                        url: (this.secure ? 'https' : 'http') + '://' + this.host + ':' + this.port + this.service + this.sep + 'socket=poll&command=poll&id=' + this.emuid,
                        ondone: e => this.onEmuSocketPollDone(),
                        onerror: e => this.onEmuSocketPollError()
                    });
                    this.emupollrequest.send();
                }
            }
        }
        onEmuSocketOpenError(request, status) {
            this.emuopenrequest = undefined;
            this.error.fire({ target: this });
            this.closed.fire({ target: this });
        }
        onEmuSocketPollDone() {
            var response = this.emupollrequest.getResponseJSON();
            this.emupollrequest = undefined;
            if (response === undefined) {
                this.close();
                this.closed.fire({ target: this });
            }
            else {
                if (response.messages !== undefined) {
                    for (var i = 0; i < response.messages.length; i++) {
                        var msg = response.messages[i].fromBase64();
                        this.message.fire({ target: this, message: msg });
                    }
                }
                if (response.status !== 'open') {
                    this.close();
                    this.closed.fire({ target: this });
                }
                else {
                    var now = new Date();
                    var deltaMs = Math.max(0, now.getTime() - this.lastPoll.getTime());
                    this.lastPoll = now;
                    if (deltaMs >= this.pollInterval * 1000)
                        this.sendPoll();
                    else
                        this.delayPollTask = new Core.DelayedTask(this.pollInterval, this.delayPollDone);
                }
            }
        }
        onEmuSocketPollError() {
            this.emupollrequest = undefined;
            this.error.fire({ target: this });
            this.close();
        }
        delayPollDone() {
            this.delayPollTask = undefined;
            if (this.emupollrequest === undefined)
                this.sendPoll();
        }
        sendPoll() {
            var now = new Date();
            this.lastPoll = now;
            this.emupollrequest = new Core.HttpRequest({
                url: (this.secure ? 'https' : 'http') + '://' + this.host + ':' + this.port + this.service + this.sep + 'socket=poll&command=poll&id=' + this.emuid,
                ondone: e => this.onEmuSocketPollDone(),
                onerror: e => this.onEmuSocketPollError()
            });
            this.emupollrequest.send();
        }
    }
    Socket.supportWebSocket = true;
    Core.Socket = Socket;
})(Core || (Core = {}));
Core.Socket.supportWebSocket = "WebSocket" in window;
var Core;
(function (Core) {
    class RemoteDebug extends Core.Object {
        constructor(init) {
            super();
            this.socketAlive = false;
            this.retryTask = undefined;
            this.nativeConsole = undefined;
            this.buffer = [];
            this.onSocketOpen = () => {
                this.socketAlive = true;
                while (this.buffer.length > 0) {
                    this.socket.send(this.buffer.shift());
                }
            };
            this.onSocketMessage = (e) => {
                eval(e.message);
            };
            this.onSocketError = () => {
                this.socketAlive = false;
                this.socket.close();
            };
            this.onSocketClose = () => {
                this.socketAlive = false;
                this.socket.error.disconnect(this.onSocketError);
                this.socket.closed.disconnect(this.onSocketClose);
                this.socket = undefined;
                this.retryTask = new Core.DelayedTask(5, this.startSocket);
            };
            Core.RemoteDebug.current = this;
            this.host = init.host;
            this.port = init.port;
            this.nativeConsole = window.console;
            window.console = {
                log: Core.RemoteDebug.onConsoleLog,
                error: Core.RemoteDebug.onConsoleError,
                warn: Core.RemoteDebug.onConsoleWarn
            };
            window.onerror = Core.RemoteDebug.onError;
            this.startSocket();
        }
        startSocket() {
            this.socket = new Core.Socket({ service: '/', host: this.host, port: this.port });
            this.socket.opened.connect(this.onSocketOpen);
            this.socket.message.connect(this.onSocketMessage);
            this.socket.error.connect(this.onSocketError);
            this.socket.closed.connect(this.onSocketClose);
        }
        onConsoleLog(message) {
            if (this.socketAlive)
                this.socket.send(JSON.stringify({ type: 'log', message: message }));
            else
                this.buffer.push(JSON.stringify({ type: 'log', message: message }));
        }
        onConsoleError(message) {
            if (this.socketAlive)
                this.socket.send(JSON.stringify({ type: 'error', message: message }));
            else
                this.buffer.push(JSON.stringify({ type: 'error', message: message }));
        }
        onConsoleWarn(message) {
            if (this.socketAlive)
                this.socket.send(JSON.stringify({ type: 'warn', message: message }));
            else
                this.buffer.push(JSON.stringify({ type: 'warn', message: message }));
        }
        onError(message, url, line) {
            if (this.socketAlive)
                this.socket.send(JSON.stringify({ type: 'warn', message: message, url: url, line: line }));
            else
                this.buffer.push(JSON.stringify({ type: 'warn', message: message, url: url, line: line }));
        }
        static onConsoleLog(message) {
            var _a;
            (_a = Core.RemoteDebug.current) === null || _a === void 0 ? void 0 : _a.onConsoleLog.call(Core.RemoteDebug.current, message);
        }
        static onConsoleError(message) {
            var _a;
            (_a = Core.RemoteDebug.current) === null || _a === void 0 ? void 0 : _a.onConsoleError.call(Core.RemoteDebug.current, message);
        }
        static onConsoleWarn(message) {
            var _a;
            (_a = Core.RemoteDebug.current) === null || _a === void 0 ? void 0 : _a.onConsoleWarn.call(Core.RemoteDebug.current, message);
        }
        static onError(message, url, line) {
            var _a;
            (_a = Core.RemoteDebug.current) === null || _a === void 0 ? void 0 : _a.onError.call(Core.RemoteDebug.current, message, url, line);
        }
    }
    Core.RemoteDebug = RemoteDebug;
})(Core || (Core = {}));
var Core;
(function (Core) {
    class FilePostUploader extends Core.Object {
        constructor(init) {
            super();
            this._method = 'POST';
            this._isCompleted = false;
            this._isSent = false;
            this.field = 'file';
            this.progress = new Core.Events();
            this.completed = new Core.Events();
            this.error = new Core.Events();
            this.formData = new FormData();
            if (init) {
                if (init.method !== undefined)
                    this.method = init.method;
                if (init.headers !== undefined)
                    this.headers = init.headers;
                if (init.file !== undefined)
                    this.file = init.file;
                if (init.field !== undefined)
                    this.field = init.field;
                if (init.service !== undefined)
                    this.service = init.service;
                if (init.destination !== undefined)
                    this.destination = init.destination;
                if (init.arguments !== undefined)
                    this.arguments = init.arguments;
                if (init.onprogress)
                    this.progress.connect(init.onprogress);
                if (init.oncompleted)
                    this.completed.connect(init.oncompleted);
                if (init.onerror)
                    this.error.connect(init.onerror);
            }
        }
        set onprogress(value) { this.progress.connect(value); }
        set oncompleted(value) { this.completed.connect(value); }
        set onerror(value) { this.error.connect(value); }
        set headers(headers) {
            this._headers = Core.Util.clone(headers);
        }
        get headers() {
            return this._headers;
        }
        setRequestHeader(header, value) {
            if (this.headers === undefined)
                this.headers = {};
            this.headers[header] = value;
        }
        set method(method) {
            this._method = method;
        }
        get file() {
            return this._file;
        }
        set file(file) {
            this._file = file;
        }
        set service(service) {
            this._service = service;
        }
        setField(name, value, fileName) {
            this.formData.set(name, value, fileName);
        }
        appendField(name, value, fileName) {
            this.formData.append(name, value, fileName);
        }
        deleteField(name) {
            this.formData.delete(name);
        }
        set arguments(args) {
            for (const key in args) {
                if (Array.isArray(args[key])) {
                    for (const data of args[key]) {
                        this.formData.append(key, data);
                    }
                }
                else {
                    this.formData.append(key, args[key]);
                }
            }
        }
        set destination(destination) {
            this.setField('destination', destination);
        }
        send() {
            this._isSent = true;
            if (this._file)
                this.formData.append(this.field, this._file);
            this.request = new XMLHttpRequest();
            if ('upload' in this.request)
                this.request.upload.addEventListener('progress', e => this.onUpdateProgress(e));
            this.request.open(this._method, this._service);
            if (this.headers !== undefined) {
                for (let header in this.headers)
                    this.request.setRequestHeader(header, this.headers[header]);
            }
            this.request.send(this.formData);
            this.request.onreadystatechange = (event) => this.onStateChange(event);
        }
        get status() {
            var _a;
            return this.request ? this.request.status : ((_a = this._lastStatus) !== null && _a !== void 0 ? _a : -1);
        }
        sendAsync() {
            return new Promise(resolve => {
                this.completed.connect(() => resolve(this));
                this.error.connect(() => resolve(this));
                this.send();
            });
        }
        waitAsync() {
            return new Promise(resolve => {
                if (this.isCompleted)
                    resolve(this);
                else {
                    this.completed.connect(() => resolve(this));
                    if (!this._isSent)
                        this.send();
                }
            });
        }
        abort() {
            if (this.request !== undefined) {
                this.request.abort();
                this.request = undefined;
            }
        }
        get responseText() {
            return this._responseText;
        }
        get responseJSON() {
            let res;
            try {
                res = JSON.parse(this.responseText);
            }
            catch (err) {
                res = undefined;
            }
            return res;
        }
        get isCompleted() {
            return this._isCompleted;
        }
        get total() {
            return this.totalOctets;
        }
        get loaded() {
            return this.loadedOctets;
        }
        onStateChange(event) {
            this._lastStatus = this.request.status;
            if (this.request.readyState == 4) {
                this._isCompleted = true;
                if (this.request.status == 200) {
                    this._responseText = this.request.responseText;
                    this.completed.fire({ target: this });
                }
                else {
                    this._responseText = this.request.responseText;
                    this.error.fire({ target: this, status: this.request.status });
                }
                this.request = undefined;
            }
        }
        onUpdateProgress(event) {
            this.loadedOctets = event.loaded;
            this.totalOctets = event.total;
            this.progress.fire({ target: this, loaded: event.loaded, total: event.total });
        }
    }
    Core.FilePostUploader = FilePostUploader;
})(Core || (Core = {}));
var Anim;
(function (Anim) {
    class EasingFunction extends Core.Object {
        constructor(init) {
            super();
            this.mode = 'in';
            if (init) {
                if (init.mode !== undefined)
                    this.mode = init.mode;
            }
        }
        ease(normalizedTime) {
            if (this.mode == 'in')
                return this.easeInCore(normalizedTime);
            else if (this.mode == 'out')
                return 1 - this.easeInCore(1 - normalizedTime);
            else {
                if (normalizedTime <= 0.5)
                    return this.easeInCore(normalizedTime * 2.0) / 2.0;
                else
                    return 0.5 + ((1 - this.easeInCore(2.0 - (normalizedTime * 2.0))) / 2.0);
            }
        }
        easeInCore(normalizedTime) {
            return normalizedTime;
        }
        static register(easeName, classType) {
            this.eases[easeName] = classType;
        }
        static parse(ease) {
            return new this.eases[ease]();
        }
        static create(ease) {
            if (ease instanceof EasingFunction)
                return ease;
            else
                return EasingFunction.parse(ease);
        }
    }
    EasingFunction.eases = {};
    Anim.EasingFunction = EasingFunction;
})(Anim || (Anim = {}));
var Anim;
(function (Anim) {
    class LinearEase extends Anim.EasingFunction {
        easeInCore(normalizedTime) {
            return normalizedTime;
        }
    }
    Anim.LinearEase = LinearEase;
})(Anim || (Anim = {}));
Anim.EasingFunction.register('linear', Anim.LinearEase);
var Anim;
(function (Anim) {
    class PowerEase extends Anim.EasingFunction {
        constructor(init) {
            super(init);
            this.power = 2;
            if (init) {
                if (init.power !== undefined)
                    this.power = init.power;
            }
        }
        easeInCore(normalizedTime) {
            return Math.pow(normalizedTime, this.power);
        }
    }
    Anim.PowerEase = PowerEase;
})(Anim || (Anim = {}));
Anim.EasingFunction.register('power', Anim.PowerEase);
var Anim;
(function (Anim) {
    class BounceEase extends Anim.EasingFunction {
        constructor(init) {
            super(init);
            this.bounces = 3;
            this.bounciness = 2.0;
            if (init) {
                if (init.bounces !== undefined)
                    this.bounces = init.bounces;
                if (init.bounciness !== undefined)
                    this.bounciness = init.bounciness;
            }
        }
        easeInCore(normalizedTime) {
            var sq = Math.exp((1.0 / this.bounciness) * Math.log(normalizedTime));
            var step = Math.floor(sq * (this.bounces + 0.5));
            var sinstep = (sq * (this.bounces + 0.5)) - step;
            return Math.sin(sinstep * Math.PI) / Math.exp(this.bounces - step);
        }
    }
    Anim.BounceEase = BounceEase;
})(Anim || (Anim = {}));
Anim.EasingFunction.register('bounce', Anim.BounceEase);
var Anim;
(function (Anim) {
    class ElasticEase extends Anim.EasingFunction {
        constructor(init) {
            super(init);
            this.oscillations = 3;
            this.springiness = 3.0;
            if (init) {
                if (init.oscillations !== undefined)
                    this.oscillations = init.oscillations;
                if (init.springiness !== undefined)
                    this.springiness = init.springiness;
            }
        }
        easeInCore(normalizedTime) {
            return Math.sin(normalizedTime * (this.oscillations * 2 + 0.5) * Math.PI) * Math.pow(normalizedTime, this.springiness);
        }
    }
    Anim.ElasticEase = ElasticEase;
})(Anim || (Anim = {}));
Anim.EasingFunction.register('elastic', Anim.ElasticEase);
var Anim;
(function (Anim) {
    class TimeManager extends Core.Object {
        constructor() {
            super();
            this.clocks = undefined;
            this.timer = undefined;
            this.start = 0;
            this.tick = new Core.Events();
            this.clocks = [];
            this.start = new Date().getTime();
        }
        add(clock) {
            var found = false;
            for (var i = 0; !found && (i < this.clocks.length); i++) {
                found = this.clocks[i] === clock;
            }
            if (!found) {
                this.clocks.push(clock);
                if (this.clocks.length === 1) {
                    this.timer = new Core.Timer({ interval: 1 / 60 });
                    this.timer.timeupdate.connect(this.onTick);
                }
            }
        }
        remove(clock) {
            var i = 0;
            while ((i < this.clocks.length) && (this.clocks[i] != clock)) {
                i++;
            }
            if (i < this.clocks.length)
                this.clocks.splice(i, 1);
            if (this.clocks.length === 0) {
                this.timer.abort();
                this.timer = undefined;
            }
        }
        onTick() {
            var current = (new Date().getTime()) - this.start;
            current /= 1000;
            for (var i = 0; i < this.clocks.length; i++)
                this.clocks[i].update(current);
            this.tick.fire({ target: this });
        }
    }
    TimeManager.current = new TimeManager();
    Anim.TimeManager = TimeManager;
})(Anim || (Anim = {}));
var Anim;
(function (Anim) {
    class AnimationManager extends Core.Object {
        constructor() {
            super();
            this.clocks = undefined;
            this.start = 0;
            this.onTickBind = undefined;
            this.tick = new Core.Events();
            this.clocks = [];
            this.start = new Date().getTime();
            this.onTickBind = this.onTick.bind(this);
        }
        add(clock) {
            var found = false;
            for (var i = 0; !found && (i < this.clocks.length); i++) {
                found = this.clocks[i] === clock;
            }
            if (!found) {
                this.clocks.push(clock);
                if (this.clocks.length == 1)
                    requestAnimationFrame(this.onTickBind);
            }
        }
        remove(clock) {
            var i = 0;
            while ((i < this.clocks.length) && (this.clocks[i] != clock)) {
                i++;
            }
            if (i < this.clocks.length)
                this.clocks.splice(i, 1);
        }
        forceTick() {
            if (this.clocks.length > 0)
                this.onTickBind();
        }
        onTick() {
            var startTime = (new Date().getTime()) / 1000;
            var current = (new Date().getTime()) - this.start;
            current /= 1000;
            for (var i = 0; i < this.clocks.length; i++)
                this.clocks[i].update(current);
            this.tick.fire({ target: this });
            if (this.clocks.length > 0)
                requestAnimationFrame(this.onTickBind);
        }
    }
    AnimationManager.current = new AnimationManager();
    Anim.AnimationManager = AnimationManager;
})(Anim || (Anim = {}));
if (!('requestAnimationFrame' in window)) {
    if ('webkitRequestAnimationFrame' in window)
        window.requestAnimationFrame = window['webkitRequestAnimationFrame'];
    else if ('mozRequestAnimationFrame' in window)
        window.requestAnimationFrame = window['mozRequestAnimationFrame'];
    else if ('msRequestAnimationFrame' in window)
        window.requestAnimationFrame = window['msRequestAnimationFrame'];
    else
        window.requestAnimationFrame = function (cb) { setTimeout(cb, 1 / 60); };
}
var Anim;
(function (Anim) {
    class Clock extends Core.Object {
        constructor(init) {
            super();
            this._animation = true;
            this._parent = undefined;
            this._time = undefined;
            this._iteration = undefined;
            this._progress = 0;
            this._isActive = false;
            this._globalTime = 0;
            this.startTime = 0;
            this.lastTick = 0;
            this._beginTime = 0;
            this.isPaused = false;
            this._speed = 1;
            this._duration = 'forever';
            this.pendingState = 'none';
            this._autoReverse = false;
            this._repeat = 1;
            this._target = undefined;
            this._ease = undefined;
            this.timeupdate = new Core.Events();
            this.completed = new Core.Events();
            if (init) {
                if (init.animation !== undefined)
                    this.animation = init.animation;
                if (init.repeat !== undefined)
                    this.repeat = init.repeat;
                if (init.speed !== undefined)
                    this.speed = init.speed;
                if (init.autoReverse !== undefined)
                    this.autoReverse = init.autoReverse;
                if (init.beginTime !== undefined)
                    this.beginTime = init.beginTime;
                if (init.ease !== undefined)
                    this.ease = init.ease;
                if (init.target !== undefined)
                    this.target = init.target;
                if (init.duration !== undefined)
                    this.duration = init.duration;
                if (init.parent !== undefined)
                    this.parent = init.parent;
                if (init.ontimeupdate)
                    this.timeupdate.connect(init.ontimeupdate);
                if (init.oncompleted)
                    this.completed.connect(init.oncompleted);
            }
        }
        set animation(animation) {
            this._animation = animation;
        }
        set repeat(repeat) {
            this._repeat = repeat;
        }
        set speed(speed) {
            this._speed = speed;
        }
        set autoReverse(autoReverse) {
            this._autoReverse = autoReverse;
        }
        set beginTime(beginTime) {
            this._beginTime = beginTime;
        }
        set ease(ease) {
            this._ease = Anim.EasingFunction.create(ease);
        }
        set target(target) {
            this._target = target;
        }
        set duration(duration) {
            if (duration == 'automatic')
                this._duration = 'forever';
            else
                this._duration = duration;
        }
        set parent(parent) {
            this._parent = parent;
        }
        get parent() {
            return this._parent;
        }
        get globalTime() {
            return this._globalTime + (this.lastTick - this.startTime) * this._speed;
        }
        get isActive() {
            return this._isActive || (this.pendingState === 'active');
        }
        get time() {
            var _a;
            return (_a = this._time) !== null && _a !== void 0 ? _a : 0;
        }
        get iteration() {
            var _a;
            return (_a = this._iteration) !== null && _a !== void 0 ? _a : 0;
        }
        get progress() {
            var _a;
            return (_a = this._progress) !== null && _a !== void 0 ? _a : 0;
        }
        begin() {
            if (this.isActive)
                return;
            if (this._parent === undefined) {
                if (this._animation)
                    Anim.AnimationManager.current.add(this);
                else
                    Anim.TimeManager.current.add(this);
            }
            this.pendingState = 'active';
            if ((this._target !== undefined) && (this._target.setAnimClock !== undefined))
                this._target.setAnimClock(this);
        }
        pause() {
            this.pendingState = 'paused';
        }
        resume() {
            this.pendingState = 'resumed';
        }
        stop() {
            this.pendingState = 'stopped';
        }
        complete() {
            if (this._parent === undefined) {
                if (this._animation)
                    Anim.AnimationManager.current.remove(this);
                else
                    Anim.TimeManager.current.remove(this);
            }
            this.completed.fire({ target: this });
        }
        onTimeUpdate(deltaTick) {
            var progress = this.progress;
            if (this._ease !== undefined)
                progress = this._ease.ease(progress);
            this.timeupdate.fire({ target: this, progress: progress, deltaTick: deltaTick });
        }
        update(parentGlobalTime) {
            do {
                let state = this.pendingState;
                this.pendingState = 'none';
                if (state === 'none') {
                    if (this._isActive && !this.isPaused) {
                        var deltaTick = parentGlobalTime - this.lastTick;
                        this.lastTick = parentGlobalTime;
                        var globalTime = this.globalTime;
                        globalTime -= this._beginTime;
                        if (globalTime >= 0) {
                            if ((this._duration !== 'forever') && (this._duration !== 'automatic')) {
                                var iteration = globalTime / this._duration;
                                var iterationRounded = Math.floor(iteration + 1);
                                var time = globalTime % this._duration;
                                if (this._autoReverse) {
                                    if ((iterationRounded & 1) === 0)
                                        time = this._duration - time;
                                    iteration /= 2;
                                    iterationRounded = Math.floor(iteration + 1);
                                }
                                if (this._repeat == 'forever') {
                                    this._iteration = iterationRounded;
                                    this._time = time;
                                    this._progress = time / this._duration;
                                    this.onTimeUpdate(deltaTick);
                                }
                                else {
                                    if (iteration >= this._repeat) {
                                        this.pendingState = 'stopped';
                                        this._iteration = this._repeat;
                                        this._time = this._duration;
                                        if (this._autoReverse)
                                            this._progress = 0;
                                        else
                                            this._progress = 1;
                                        this.onTimeUpdate(0);
                                    }
                                    else {
                                        this._iteration = iterationRounded;
                                        this._time = time;
                                        this._progress = time / this._duration;
                                        this.onTimeUpdate(deltaTick);
                                    }
                                }
                            }
                            else {
                                this._time = globalTime;
                                this._progress = 0;
                                this._iteration = undefined;
                                this.onTimeUpdate(deltaTick);
                            }
                        }
                    }
                }
                else if (state == 'active') {
                    if (!this._isActive) {
                        this._isActive = true;
                        this._globalTime = 0;
                        this.startTime = parentGlobalTime;
                        this.lastTick = this.startTime;
                        if (this._beginTime > 0) {
                            this._time = undefined;
                            this._progress = 0;
                            this._iteration = undefined;
                        }
                        else {
                            this._time = 0;
                            this._progress = 0;
                            this._iteration = 1;
                            this.onTimeUpdate(0);
                        }
                    }
                }
                else if (state == 'paused') {
                    if (!this.isPaused && this._isActive) {
                        this.isPaused = true;
                        this._globalTime = this.globalTime;
                        this.startTime = 0;
                        this.lastTick = 0;
                    }
                }
                else if (state == 'resumed') {
                    if (this.isPaused && this._isActive) {
                        this.isPaused = false;
                        this.startTime = parentGlobalTime;
                        this.lastTick = parentGlobalTime;
                    }
                }
                else if (state == 'stopped') {
                    if (this._isActive) {
                        this._progress = undefined;
                        this._time = undefined;
                        this._iteration = undefined;
                        this._isActive = false;
                    }
                }
            } while (this.pendingState != 'none');
            if ((this._parent === undefined) && !this._isActive)
                this.complete();
        }
    }
    Anim.Clock = Clock;
})(Anim || (Anim = {}));
var Anim;
(function (Anim) {
    class ClockGroup extends Anim.Clock {
        constructor() {
            super(...arguments);
            this.children = [];
        }
        appendChild(child) {
            child.parent = this;
            this.children.push(child);
        }
        set content(content) {
            this.children = [];
            if (content !== undefined) {
                if (content instanceof Array) {
                    for (let i = 0; i < content.length; i++)
                        this.appendChild(content[i]);
                }
                else
                    this.appendChild(content);
            }
        }
        begin() {
            super.begin();
            for (var i = 0; i < this.children.length; i++)
                this.children[i].begin();
        }
        pause() {
            super.pause();
            for (let i = 0; i < this.children.length; i++)
                this.children[i].pause();
        }
        resume() {
            super.resume();
            for (let i = 0; i < this.children.length; i++)
                this.children[i].resume();
        }
        stop() {
            super.stop();
            for (let i = 0; i < this.children.length; i++)
                this.children[i].stop();
        }
        complete() {
            super.complete();
            for (let i = 0; i < this.children.length; i++)
                this.children[i].complete();
        }
        update(parentGlobalTime) {
            do {
                super.update(parentGlobalTime);
                let childStopped = true;
                for (let i = 0; i < this.children.length; i++) {
                    let childClock = this.children[i];
                    childClock.update(this.globalTime);
                    if (childClock.isActive)
                        childStopped = false;
                }
                if (this.isActive && childStopped)
                    this.pendingState = 'stopped';
            } while (this.pendingState != 'none');
        }
    }
    Anim.ClockGroup = ClockGroup;
})(Anim || (Anim = {}));
var Ui;
(function (Ui) {
    class Matrix extends Core.Object {
        constructor() {
            super();
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
        isTranslateOnly() {
            return ((this.a === 1) && (this.b === 0) && (this.c === 0) && (this.d === 1));
        }
        isIdentity() {
            return ((this.a === 1) && (this.b === 0) && (this.c === 0) && (this.d === 1) && (this.e === 0) && (this.f === 0));
        }
        translate(x, y) {
            return this.multiply(Matrix.createTranslate(x, y));
        }
        rotate(angle) {
            return this.multiply(Matrix.createRotate(angle));
        }
        scale(scaleX, scaleY) {
            if (scaleY === undefined)
                scaleY = scaleX;
            return this.multiply(Matrix.createScale(scaleX, scaleY));
        }
        multiply(matrix) {
            let a = matrix.a * this.a + matrix.b * this.c;
            let c = matrix.c * this.a + matrix.d * this.c;
            let e = matrix.e * this.a + matrix.f * this.c + this.e;
            let b = matrix.a * this.b + matrix.b * this.d;
            let d = matrix.c * this.b + matrix.d * this.d;
            let f = matrix.e * this.b + matrix.f * this.d + this.f;
            return Matrix.createMatrix(a, b, c, d, e, f);
        }
        getDeterminant() {
            return ((this.a * this.d) - (this.b * this.c));
        }
        inverse() {
            let determinant = this.getDeterminant();
            if (determinant === 0)
                throw ("Matrix not invertible");
            let invd = 1 / determinant;
            let ta = this.d * invd;
            let tb = -this.b * invd;
            let tc = -this.c * invd;
            let td = this.a * invd;
            let te = ((this.c * this.f) - (this.e * this.d)) * invd;
            let tf = ((this.e * this.b) - (this.a * this.f)) * invd;
            return Matrix.createMatrix(ta, tb, tc, td, te, tf);
        }
        setMatrix(a, b, c, d, e, f) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.e = e;
            this.f = f;
        }
        getA() {
            return this.a;
        }
        getB() {
            return this.b;
        }
        getC() {
            return this.c;
        }
        getD() {
            return this.d;
        }
        getE() {
            return this.e;
        }
        getF() {
            return this.f;
        }
        clone() {
            return Matrix.createMatrix(this.a, this.b, this.c, this.d, this.e, this.f);
        }
        toString() {
            return 'matrix(' + this.a.toFixed(4) + ',' + this.b.toFixed(4) + ',' + this.c.toFixed(4) + ',' + this.d.toFixed(4) + ',' + this.e.toFixed(4) + ',' + this.f.toFixed(4) + ')';
        }
        static createMatrix(a, b, c, d, e, f) {
            let matrix = new Matrix();
            matrix.setMatrix(a, b, c, d, e, f);
            return matrix;
        }
        static createTranslate(x, y) {
            return Matrix.createMatrix(1, 0, 0, 1, x, y);
        }
        static createScaleAt(scaleX, scaleY, centerX, centerY) {
            return Matrix.createMatrix(scaleX, 0, 0, scaleY, centerX - (scaleX * centerX), centerY - (scaleY * centerY));
        }
        static createScale(scaleX, scaleY) {
            if (scaleY === undefined)
                scaleY = scaleX;
            return Matrix.createScaleAt(scaleX, scaleY, 0, 0);
        }
        static createRotateAt(angle, centerX, centerY) {
            angle = (angle % 360) * Math.PI / 180;
            let sin = Math.sin(angle);
            let cos = Math.cos(angle);
            let offsetX = (centerX * (1.0 - cos)) + (centerY * sin);
            let offsetY = (centerY * (1.0 - cos)) - (centerX * sin);
            return Matrix.createMatrix(cos, sin, -sin, cos, offsetX, offsetY);
        }
        static createRotate(angle) {
            return Matrix.createRotateAt(angle, 0, 0);
        }
        static parse(stringMatrix) {
            let matrix;
            if (typeof (stringMatrix) === 'string') {
                let res;
                if ((res = stringMatrix.match(/^matrix\((-?\d+\.?\d*),(-?\d+\.?\d*),(-?\d+\.?\d*),(-?\d+\.?\d*),(-?\d+\.?\d*),(-?\d+\.?\d*)\)$/)) != undefined) {
                    let a = parseFloat(res[1]);
                    let b = parseFloat(res[2]);
                    let c = parseFloat(res[3]);
                    let d = parseFloat(res[4]);
                    let e = parseFloat(res[5]);
                    let f = parseFloat(res[6]);
                    matrix = new Matrix();
                    matrix.setMatrix(a, b, c, d, e, f);
                }
            }
            if (matrix === undefined)
                throw ('Unknown matrix format (' + stringMatrix + ')');
            return matrix;
        }
    }
    Ui.Matrix = Matrix;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Point extends Core.Object {
        constructor(x = 0, y = 0) {
            super();
            this.x = 0;
            this.y = 0;
            this.x = x;
            this.y = y;
        }
        matrixTransform(matrix) {
            let x = this.x * matrix.a + this.y * matrix.c + matrix.e;
            let y = this.x * matrix.b + this.y * matrix.d + matrix.f;
            this.x = x;
            this.y = y;
            return this;
        }
        multiply(value) {
            let res;
            if (typeof (value) === 'number')
                res = new Ui.Point(this.x * value, this.y * value);
            else if (value instanceof Ui.Matrix)
                res = new Ui.Point(this.x * value.a + this.y * value.c + value.e, this.x * value.b + this.y * value.d + value.f);
            else
                res = this;
            return res;
        }
        divide(value) {
            let res;
            if (typeof (value) === 'number')
                res = new Ui.Point(this.x / value, this.y / value);
            else if (value instanceof Ui.Matrix) {
                value = value.inverse();
                res = new Ui.Point(this.x * value.a + this.y * value.c + value.e, this.x * value.b + this.y * value.d + value.f);
            }
            else
                res = this;
            return res;
        }
        add(value) {
            let res;
            if (typeof (value) === 'number')
                res = new Point(this.x + value, this.y + value);
            else if (value instanceof Point)
                res = new Point(this.x + value.x, this.y + value.y);
            else
                res = this;
            return res;
        }
        substract(value) {
            let res;
            if (typeof (value) === 'number')
                res = new Point(this.x - value, this.y - value);
            else if (value instanceof Point)
                res = new Point(this.x - value.x, this.y - value.y);
            else
                res = this;
            return res;
        }
        setPoint(point) {
            this.x = point.x;
            this.y = point.y;
        }
        getX() {
            return this.x;
        }
        setX(x) {
            this.x = x;
        }
        getY() {
            return this.y;
        }
        setY(y) {
            this.y = y;
        }
        getLength() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        clone() {
            return new Point(this.x, this.y);
        }
        toString() {
            return 'point(' + this.x.toFixed(4) + ', ' + this.y.toFixed(4) + ')';
        }
    }
    Ui.Point = Point;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Color extends Core.Object {
        constructor(r = 0, g = 0, b = 0, a = 1) {
            super();
            this.r = 0;
            this.g = 0;
            this.b = 0;
            this.a = 1;
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        addA(a) {
            return new Color(this.r, this.g, this.b, Math.max(0, Math.min(1, this.a + a)));
        }
        addY(y) {
            let yuva = this.getYuva();
            yuva.y += y;
            return Color.createFromYuv(yuva.y, yuva.u, yuva.v, yuva.a);
        }
        addH(h) {
            let hsla = this.getHsla();
            hsla.h += h;
            return Color.createFromHsl(hsla.h, hsla.s, hsla.l, hsla.a);
        }
        addS(s) {
            let hsla = this.getHsla();
            hsla.s += s;
            return Color.createFromHsl(hsla.h, hsla.s, hsla.l, hsla.a);
        }
        addL(l) {
            let hsla = this.getHsla();
            hsla.l += l;
            return Color.createFromHsl(hsla.h, hsla.s, hsla.l, hsla.a);
        }
        getCssRgba() {
            return 'rgba(' + Math.round(this.r * 255) + ',' + Math.round(this.g * 255) + ',' + Math.round(this.b * 255) + ',' + this.a + ')';
        }
        getCssRgb() {
            return 'rgb(' + Math.round(this.r * 255) + ',' + Math.round(this.g * 255) + ',' + Math.round(this.b * 255) + ')';
        }
        getCssHtml(alpha = false) {
            let res = '#';
            let t = Math.round(this.r * 255).toString(16);
            if (t.length == 1)
                t = '0' + t;
            res += t;
            t = Math.round(this.g * 255).toString(16);
            if (t.length == 1)
                t = '0' + t;
            res += t;
            t = Math.round(this.b * 255).toString(16);
            if (t.length == 1)
                t = '0' + t;
            res += t;
            if (alpha) {
                t = Math.round(this.a * 255).toString(16);
                if (t.length == 1)
                    t = '0' + t;
                res += t;
            }
            return res;
        }
        getRgba() {
            return { r: this.r, g: this.g, b: this.b, a: this.a };
        }
        getRgb() {
            return this.getRgba();
        }
        getHsla() {
            let r = this.r;
            let g = this.g;
            let b = this.b;
            let min = Math.min(r, Math.min(g, b));
            let max = Math.max(r, Math.max(g, b));
            let delta = max - min;
            let h = 0;
            let s = 0;
            let l = 0;
            if (delta == 0)
                h = 0;
            else if (max == r)
                h = ((g - b) / delta) % 6;
            else if (max == g)
                h = (b - r) / delta + 2;
            else
                h = (r - g) / delta + 4;
            h = Math.round(h * 60);
            h = (h + 360) % 360;
            l = (max + min) / 2;
            s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
            return { h: h, s: s, l: l, a: this.a };
        }
        getHsl() {
            return this.getHsla();
        }
        getYuva() {
            let y = 0.299 * this.r + 0.587 * this.g + 0.114 * this.b;
            let u = 0.492 * (this.b - y);
            let v = 0.877 * (this.r - y);
            return { y: y, u: u, v: v, a: this.a };
        }
        getYuv() {
            return this.getYuva();
        }
        initFromHsl(h, s, l, a = 1) {
            this.a = Math.min(Math.max(a, 0), 1);
            if (s <= 0) {
                this.r = l;
                this.g = l;
                this.b = l;
                return;
            }
            let c = (1 - Math.abs(2 * l - 1)) * s;
            let x = c * (1 - Math.abs((h / 60) % 2 - 1));
            let m = l - c / 2;
            let r = 0;
            let g = 0;
            let b = 0;
            if (0 <= h && h < 60) {
                r = c;
                g = x;
                b = 0;
            }
            else if (60 <= h && h < 120) {
                r = x;
                g = c;
                b = 0;
            }
            else if (120 <= h && h < 180) {
                r = 0;
                g = c;
                b = x;
            }
            else if (180 <= h && h < 240) {
                r = 0;
                g = x;
                b = c;
            }
            else if (240 <= h && h < 300) {
                r = x;
                g = 0;
                b = c;
            }
            else if (300 <= h && h <= 360) {
                r = c;
                g = 0;
                b = x;
            }
            this.r = r + m;
            this.g = g + m;
            this.b = b + m;
            if (isNaN(this.r))
                this.r = 0;
            if (isNaN(this.g))
                this.g = 0;
            if (isNaN(this.b))
                this.b = 0;
        }
        initFromYuv(y, u, v, a = 1) {
            this.r = Math.max(0, Math.min(y + 1.13983 * v, 1));
            this.g = Math.max(0, Math.min(y - 0.39465 * u - 0.58060 * v, 1));
            this.b = Math.max(0, Math.min(y + 2.03211 * u, 1));
            this.a = Math.min(Math.max(a, 0), 1);
        }
        initFromRgb(r, g, b, a = 1) {
            this.r = Math.min(Math.max(r, 0), 1);
            this.g = Math.min(Math.max(g, 0), 1);
            this.b = Math.min(Math.max(b, 0), 1);
            this.a = Math.min(Math.max(a, 0), 1);
        }
        toString() {
            return 'color(' + this.r.toFixed(4) + ', ' + this.g.toFixed(4) + ', ' + this.b.toFixed(4) + ', ' + this.a.toFixed(4) + ')';
        }
        static parse(color) {
            let r;
            let g;
            let b;
            let a;
            if (typeof (color) == 'string') {
                if (color in Color.knownColor)
                    color = Color.knownColor[color];
                let res;
                if ((res = color.match(/^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+\.?\d*)\s*\)\s*$/)) != undefined) {
                    r = parseInt(res[1]) / 255;
                    g = parseInt(res[2]) / 255;
                    b = parseInt(res[3]) / 255;
                    a = parseFloat(res[4]);
                    return new Color(r, g, b, a);
                }
                else if ((res = color.match(/^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/)) != undefined) {
                    r = parseInt(res[1]) / 255;
                    g = parseInt(res[2]) / 255;
                    b = parseInt(res[3]) / 255;
                    return new Color(r, g, b);
                }
                else if (color.indexOf('#') === 0) {
                    if (color.length == 4) {
                        r = parseInt(color.substr(1, 1), 16) / 15;
                        g = parseInt(color.substr(2, 1), 16) / 15;
                        b = parseInt(color.substr(3, 1), 16) / 15;
                        return new Color(r, g, b);
                    }
                    else if (color.length == 5) {
                        r = parseInt(color.substr(1, 1), 16) / 15;
                        g = parseInt(color.substr(2, 1), 16) / 15;
                        b = parseInt(color.substr(3, 1), 16) / 15;
                        a = parseInt(color.substr(4, 1), 16) / 15;
                        return new Color(r, g, b, a);
                    }
                    else if (color.length == 7) {
                        r = parseInt(color.substr(1, 2), 16) / 255;
                        g = parseInt(color.substr(3, 2), 16) / 255;
                        b = parseInt(color.substr(5, 2), 16) / 255;
                        return new Color(r, g, b);
                    }
                    else if (color.length == 9) {
                        r = parseInt(color.substr(1, 2), 16) / 255;
                        g = parseInt(color.substr(3, 2), 16) / 255;
                        b = parseInt(color.substr(5, 2), 16) / 255;
                        a = parseInt(color.substr(7, 2), 16) / 255;
                        return new Color(r, g, b, a);
                    }
                }
            }
            throw ('Unknown color format (' + color + ')');
        }
        static create(color) {
            if (color instanceof Color)
                return color;
            else
                return Color.parse(color);
        }
        static createFromRgb(r, g, b, a = 1) {
            let color = new Color();
            color.initFromRgb(r, g, b, a);
            return color;
        }
        static createFromYuv(y, u, v, a = 1) {
            let color = new Color();
            color.initFromYuv(y, u, v, a);
            return color;
        }
        static createFromHsl(h, s, l, a = 1) {
            let color = new Color();
            color.initFromHsl(h, s, l, a);
            return color;
        }
    }
    Color.knownColor = {
        white: '#ffffff',
        black: '#000000',
        red: '#ff0000',
        green: '#008000',
        blue: '#0000ff',
        lightblue: '#add8e6',
        lightgreen: '#90ee90',
        orange: '#ffa500',
        purple: '#800080',
        lightgray: '#d3d3d3',
        darkgray: '#a9a9a9',
        pink: '#ffc0cb',
        brown: '#a52a2a'
    };
    Ui.Color = Color;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class LinearGradient extends Core.Object {
        constructor(stops, orientation = 'vertical') {
            super();
            this.image = undefined;
            if (stops !== undefined)
                this.stops = stops;
            else
                this.stops = [
                    { offset: 0, color: new Ui.Color(1, 1, 1, 1) },
                    { offset: 1, color: new Ui.Color(0, 0, 0, 1) }
                ];
            this.orientation = orientation;
            for (let i = 0; i < this.stops.length; i++)
                this.stops[i].color = Ui.Color.create(this.stops[i].color);
        }
        getBackgroundImage() {
            if (this.image !== undefined)
                return this.image;
            this.image = this.getCssGradient();
            return this.image;
        }
        getSVGGradient() {
            let gradient = document.createElementNS(svgNS, 'linearGradient');
            gradient.setAttributeNS(null, 'gradientUnits', 'objectBoundingBox');
            gradient.setAttributeNS(null, 'x1', 0);
            gradient.setAttributeNS(null, 'y1', 0);
            if (this.orientation == 'vertical') {
                gradient.setAttributeNS(null, 'x2', 0);
                gradient.setAttributeNS(null, 'y2', 1);
            }
            else {
                gradient.setAttributeNS(null, 'x2', 1);
                gradient.setAttributeNS(null, 'y2', 0);
            }
            for (let i = 0; i < this.stops.length; i++) {
                let stop = this.stops[i];
                let svgStop = document.createElementNS(svgNS, 'stop');
                svgStop.setAttributeNS(null, 'offset', stop.offset);
                svgStop.style.stopColor = stop.color.getCssHtml();
                svgStop.style.stopOpacity = stop.color.getRgba().a;
                gradient.appendChild(svgStop);
            }
            return gradient;
        }
        getCanvasGradient(context, width, height) {
            let gradient;
            if (this.orientation == 'vertical')
                gradient = context.createLinearGradient(0, 0, 0, height);
            else
                gradient = context.createLinearGradient(0, 0, width, 0);
            for (let i = 0; i < this.stops.length; i++) {
                let stop = this.stops[i];
                gradient.addColorStop(stop.offset, stop.color.getCssRgba());
            }
            return gradient;
        }
        getCssGradient() {
            let image = 'linear-gradient(';
            if (this.orientation == 'vertical')
                image += 'to bottom';
            else
                image += 'to right';
            for (let i = 0; i < this.stops.length; i++) {
                let stop = this.stops[i];
                image += `, ${Ui.Color.create(stop.color).getCssRgba()} ${Math.round(stop.offset * 100)}%`;
            }
            image += ')';
            return image;
        }
    }
    Ui.LinearGradient = LinearGradient;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Element extends Core.Object {
        constructor(init) {
            super();
            this._marginTop = 0;
            this._marginBottom = 0;
            this._marginLeft = 0;
            this._marginRight = 0;
            this._resizable = false;
            this.collapse = false;
            this._measureValid = false;
            this.measureConstraintPixelRatio = 1;
            this.measureConstraintWidth = 0;
            this.measureConstraintHeight = 0;
            this.measureConstraintIsPrint = false;
            this._measureWidth = 0;
            this._measureHeight = 0;
            this.arrangeValid = false;
            this.arrangeValidLock = false;
            this.arrangeX = 0;
            this.arrangeY = 0;
            this.arrangeWidth = 0;
            this.arrangeHeight = 0;
            this.arrangeIsPrint = false;
            this.arrangePixelRatio = 1;
            this.drawValid = true;
            this.layoutValid = true;
            this._layoutX = 0;
            this._layoutY = 0;
            this._layoutWidth = 0;
            this._layoutHeight = 0;
            this._isLoaded = false;
            this._verticalAlign = 'stretch';
            this._horizontalAlign = 'stretch';
            this._clipToBounds = false;
            this._eventsHidden = false;
            this._focusable = false;
            this._hasFocus = false;
            this.isMouseFocus = false;
            this.isMouseDownFocus = false;
            this._selectable = false;
            this.transformOriginX = 0.5;
            this.transformOriginY = 0.5;
            this.transformOriginAbsolute = false;
            this._opacity = 1;
            this.focused = new Core.Events();
            this.blurred = new Core.Events();
            this.loaded = new Core.Events();
            this.unloaded = new Core.Events();
            this.enabled = new Core.Events();
            this.disabled = new Core.Events();
            this.visible = new Core.Events();
            this.hidden = new Core.Events();
            this.dragover = new Core.Events();
            this.onMouseDownFocus = (event) => {
                this.isMouseDownFocus = true;
                window.addEventListener('mouseup', this.onMouseUpFocus, true);
            };
            this.onMouseUpFocus = (event) => {
                this.isMouseDownFocus = false;
                window.removeEventListener('mouseup', this.onMouseUpFocus);
            };
            this.drawing = this.renderDrawing();
            if (DEBUG) {
                this.drawing.setAttribute('eraClass', this.getClassName());
                this.drawing.data = this;
            }
            this.drawing.style.position = 'absolute';
            this.drawing.style.left = '0px';
            this.drawing.style.top = '0px';
            this.drawing.style.width = '0px';
            this.drawing.style.height = '0px';
            this.drawing.style.visibility = 'hidden';
            this.drawing.style.outline = 'none';
            this.drawing.style.transformOrigin = '0 0';
            if (Core.Navigator.isGecko)
                this.drawing.style.MozTransformOrigin = '0 0';
            else if (Core.Navigator.isWebkit)
                this.drawing.style.webkitTransformOrigin = '0 0';
            this.drawing.addEventListener('focus', (e) => this.onFocus(e));
            this.drawing.addEventListener('blur', (e) => this.onBlur(e));
            this.selectable = false;
            if (init) {
                if (init.selectable !== undefined)
                    this.selectable = init.selectable;
                if (init.id !== undefined)
                    this.id = init.id;
                if (init.focusable !== undefined)
                    this.focusable = init.focusable;
                if (init.resizable !== undefined)
                    this.resizable = init.resizable;
                if (init.role !== undefined)
                    this.role = init.role;
                if (init.width !== undefined)
                    this.width = init.width;
                if (init.height !== undefined)
                    this.height = init.height;
                if (init.maxWidth !== undefined)
                    this.maxWidth = init.maxWidth;
                if (init.maxHeight !== undefined)
                    this.maxHeight = init.maxHeight;
                if (init.verticalAlign !== undefined)
                    this.verticalAlign = init.verticalAlign;
                if (init.horizontalAlign !== undefined)
                    this.horizontalAlign = init.horizontalAlign;
                if (init.clipToBounds !== undefined)
                    this.clipToBounds = init.clipToBounds;
                if (init.margin !== undefined)
                    this.margin = init.margin;
                if (init.marginTop !== undefined)
                    this.marginTop = init.marginTop;
                if (init.marginBottom !== undefined)
                    this.marginBottom = init.marginBottom;
                if (init.marginLeft !== undefined)
                    this.marginLeft = init.marginLeft;
                if (init.marginRight !== undefined)
                    this.marginRight = init.marginRight;
                if (init.opacity !== undefined)
                    this.opacity = init.opacity;
                if (init.transform !== undefined)
                    this.transform = init.transform;
                if (init.eventsHidden !== undefined)
                    this.eventsHidden = init.eventsHidden;
                if (init.style !== undefined)
                    this.style = init.style;
                if (init.isVisible !== undefined)
                    this.isVisible = init.isVisible;
                if (init.onfocused)
                    this.focused.connect(init.onfocused);
                if (init.onblurred)
                    this.blurred.connect(init.onblurred);
                if (init.onloaded)
                    this.loaded.connect(init.onloaded);
                if (init.onunloaded)
                    this.unloaded.connect(init.onunloaded);
            }
        }
        set onfocused(value) { this.focused.connect(value); }
        set onblurred(value) { this.blurred.connect(value); }
        set onloaded(value) { this.loaded.connect(value); }
        set onunloaded(value) { this.unloaded.connect(value); }
        set onenabled(value) { this.enabled.connect(value); }
        set ondisabled(value) { this.disabled.connect(value); }
        set onvisible(value) { this.visible.connect(value); }
        set onhidden(value) { this.hidden.connect(value); }
        set ondragover(value) { this.dragover.connect(value); }
        get selectable() {
            return this._selectable;
        }
        set selectable(selectable) {
            this._selectable = selectable;
            this.drawing.selectable = selectable;
            Element.setSelectable(this.drawing, selectable);
        }
        get resizable() {
            return this._resizable;
        }
        set resizable(value) {
            if (this._resizable != value) {
                this._resizable = value;
                this.invalidateMeasure();
            }
        }
        get layoutX() {
            return this._layoutX;
        }
        get layoutY() {
            return this._layoutY;
        }
        get layoutWidth() {
            return this._layoutWidth;
        }
        get layoutHeight() {
            return this._layoutHeight;
        }
        get measureValid() {
            return this._measureValid;
        }
        set id(id) {
            this.drawing.setAttribute('id', id);
        }
        get id() {
            return this.drawing.getAttribute('id');
        }
        get focusable() {
            return this._focusable;
        }
        set focusable(focusable) {
            if (this._focusable !== focusable) {
                this._focusable = focusable;
                if (focusable && !this.isDisabled) {
                    this.drawing.tabIndex = 0;
                    this.drawing.addEventListener('mousedown', this.onMouseDownFocus, true);
                }
                else {
                    this.drawing.removeEventListener('mousedown', this.onMouseDownFocus);
                    this.drawing.removeAttribute('tabIndex');
                }
            }
        }
        getIsMouseFocus() {
            return this.isMouseFocus;
        }
        set role(role) {
            if ('setAttributeNS' in this.drawing) {
                if (role === undefined) {
                    if (this.drawing.hasAttributeNS('http://www.w3.org/2005/07/aaa', 'role'))
                        this.drawing.removeAttributeNS('http://www.w3.org/2005/07/aaa', 'role');
                }
                else
                    this.drawing.setAttributeNS('http://www.w3.org/2005/07/aaa', 'role', role);
            }
        }
        measure(width, height) {
            if (!this._isLoaded)
                return { width: 0, height: 0 };
            if (this.collapse) {
                this._measureValid = true;
                return { width: 0, height: 0 };
            }
            if (this._measureValid && (this.measureConstraintWidth === width) && (this.measureConstraintHeight === height) &&
                (this.measureConstraintIsPrint == Ui.App.isPrint) &&
                (this.measureConstraintPixelRatio == (window.devicePixelRatio || 1)))
                return { width: this._measureWidth, height: this._measureHeight };
            this.measureConstraintPixelRatio = (window.devicePixelRatio || 1);
            this.measureConstraintWidth = width;
            this.measureConstraintHeight = height;
            this.measureConstraintIsPrint = Ui.App.isPrint;
            let marginLeft = this.marginLeft;
            let marginRight = this.marginRight;
            let marginTop = this.marginTop;
            let marginBottom = this.marginBottom;
            let constraintWidth = Math.max(width - (marginLeft + marginRight), 0);
            let constraintHeight = Math.max(height - (marginTop + marginBottom), 0);
            if (this._maxWidth !== undefined)
                constraintWidth = Math.min(constraintWidth, this._maxWidth - (marginLeft + marginRight));
            if (this._maxHeight !== undefined)
                constraintHeight = Math.min(constraintHeight, this._maxHeight - (marginTop + marginBottom));
            if (this._horizontalAlign !== 'stretch')
                constraintWidth = 0;
            if (this._verticalAlign !== 'stretch')
                constraintHeight = 0;
            if (this._width !== undefined)
                constraintWidth = Math.max(this._width, constraintWidth);
            if (this._height !== undefined)
                constraintHeight = Math.max(this._height, constraintHeight);
            this._measureValid = true;
            let size = this.measureCore(constraintWidth, constraintHeight);
            if ((this._width !== undefined) && (size.width < this._width))
                this._measureWidth = this._width + marginLeft + marginRight;
            else
                this._measureWidth = Math.ceil(size.width) + marginLeft + marginRight;
            if ((this._height !== undefined) && (size.height < this._height))
                this._measureHeight = this._height + marginTop + marginBottom;
            else
                this._measureHeight = Math.ceil(size.height) + marginTop + marginBottom;
            return { width: this._measureWidth, height: this._measureHeight };
        }
        measureCore(width, height) {
            return { width: 0, height: 0 };
        }
        invalidateMeasure() {
            if (this._measureValid) {
                this._measureValid = false;
                if ((this._parent != undefined) && (this._parent._measureValid))
                    this._parent.onChildInvalidateMeasure(this, 'change');
            }
            this.invalidateArrange();
        }
        invalidateLayout() {
            this._measureValid = false;
            this.arrangeValid = false;
            if (this.layoutValid) {
                this.layoutValid = false;
                if (this.isLoaded)
                    Ui.App.enqueueLayout(this);
            }
        }
        onChildInvalidateMeasure(child, event) {
            this.invalidateMeasure();
        }
        updateLayout(width, height) {
            this._layoutWidth = width;
            this._layoutHeight = height;
            this.layoutValid = true;
            this.layoutCore();
            if (!this.arrangeValid || !this._measureValid)
                this.invalidateLayout();
        }
        layoutCore() {
            this.measure(this._layoutWidth, this._layoutHeight);
            this.arrange(this._layoutX, this._layoutY, this._layoutWidth, this._layoutHeight);
        }
        arrange(x, y, width, height) {
            if (!this._isLoaded || this.collapse)
                return;
            if (isNaN(x))
                x = 0;
            if (isNaN(y))
                y = 0;
            if (isNaN(width))
                width = 0;
            if (isNaN(height))
                height = 0;
            x = Math.round(x);
            y = Math.round(y);
            width = Math.ceil(width);
            height = Math.ceil(height);
            if (!this.arrangeValid || (this.arrangeX != x) || (this.arrangeY != y) ||
                (this.arrangeWidth != width) || (this.arrangeHeight != height) ||
                (this.arrangeIsPrint != Ui.App.isPrint) ||
                (this.arrangePixelRatio != (window.devicePixelRatio || 1))) {
                this.arrangeValid = true;
                this.arrangeValidLock = true;
                this.arrangeX = x;
                this.arrangeY = y;
                this.arrangeWidth = width;
                this.arrangeHeight = height;
                this.arrangePixelRatio = (window.devicePixelRatio || 1);
                this.arrangeIsPrint = Ui.App.isPrint;
                if (this._verticalAlign == 'top') {
                    height = this._measureHeight;
                }
                else if (this._verticalAlign == 'bottom') {
                    y += height - this._measureHeight;
                    height = this._measureHeight;
                }
                else if (this._verticalAlign == 'center') {
                    y += (height - this._measureHeight) / 2;
                    height = this._measureHeight;
                }
                else if (this._verticalAlign == 'stretch' && this._maxHeight && this._maxHeight < height) {
                    y += (height - this._maxHeight) / 2;
                    height = this._maxHeight;
                }
                if (this._horizontalAlign == 'left') {
                    width = this._measureWidth;
                }
                else if (this._horizontalAlign == 'right') {
                    x += width - this._measureWidth;
                    width = this._measureWidth;
                }
                else if (this._horizontalAlign == 'center') {
                    x += (width - this._measureWidth) / 2;
                    width = this._measureWidth;
                }
                else if (this._horizontalAlign == 'stretch' && this._maxWidth && this._maxWidth < width) {
                    x += (width - Math.max(this._maxWidth, this._measureWidth)) / 2;
                    width = Math.max(this._maxWidth, this._measureWidth);
                }
                let marginLeft = this.marginLeft;
                let marginRight = this.marginRight;
                let marginTop = this.marginTop;
                let marginBottom = this.marginBottom;
                x += marginLeft;
                y += marginTop;
                width -= marginLeft + marginRight;
                height -= marginTop + marginBottom;
                this._layoutX = x;
                this._layoutY = y;
                this._layoutWidth = Math.max(width, 0);
                this._layoutHeight = Math.max(height, 0);
                this.drawing.style.left = Math.round(this._layoutX) + 'px';
                this.drawing.style.top = Math.round(this._layoutY) + 'px';
                if (this._transform !== undefined)
                    this.updateTransform();
                if (this._eventsHidden) {
                    this.drawing.style.width = '0px';
                    this.drawing.style.height = '0px';
                }
                else {
                    this.drawing.style.width = Math.round(this._layoutWidth) + 'px';
                    this.drawing.style.height = Math.round(this._layoutHeight) + 'px';
                }
                this.drawing.style.visibility = 'inherit';
                this.arrangeCore(this._layoutWidth, this._layoutHeight);
                this.arrangeValidLock = false;
                if (!this.arrangeValid)
                    console.log(`${this}.arrange PROBLEM. Arrange invalidated during arrange`);
            }
        }
        arrangeCore(width, height) {
        }
        invalidateArrange() {
            if (this.arrangeValid) {
                if (this.arrangeValidLock)
                    console.log(`${this} called invalidateArrange while in its own arrange process`);
                this.arrangeValid = false;
                if (this._parent != undefined) {
                    if (this._parent.arrangeValidLock)
                        console.log(`${this} invalidateArrange its parent ${this._parent} while its parent is in an arrange process`);
                    this._parent.onChildInvalidateArrange(this);
                }
            }
        }
        onChildInvalidateArrange(child) {
            this.invalidateArrange();
        }
        draw() {
            this.drawCore();
            this.drawValid = true;
        }
        drawCore() {
        }
        invalidateDraw() {
            if (this.drawValid) {
                this.drawValid = false;
                Ui.App.enqueueDraw(this);
            }
        }
        renderDrawing() {
            return document.createElement('div');
        }
        get width() {
            return this._width;
        }
        set width(width) {
            if (this._width !== width) {
                this._width = width;
                this.invalidateMeasure();
            }
        }
        get height() {
            return this._height;
        }
        set height(height) {
            if (this._height !== height) {
                this._height = height;
                this.invalidateMeasure();
            }
        }
        get maxWidth() {
            return this._maxWidth;
        }
        set maxWidth(width) {
            if (this._maxWidth !== width) {
                this._maxWidth = width;
                this.invalidateMeasure();
            }
        }
        get maxHeight() {
            return this._maxHeight;
        }
        set maxHeight(height) {
            if (this._maxWidth !== height) {
                this._maxHeight = height;
                this.invalidateMeasure();
            }
        }
        get verticalAlign() {
            return this._verticalAlign;
        }
        set verticalAlign(align) {
            if (this._verticalAlign !== align) {
                this._verticalAlign = align;
                this.invalidateArrange();
            }
        }
        get horizontalAlign() {
            return this._horizontalAlign;
        }
        set horizontalAlign(align) {
            if (this._horizontalAlign !== align) {
                this._horizontalAlign = align;
                this.invalidateArrange();
            }
        }
        get clipToBounds() {
            return this._clipToBounds;
        }
        set clipToBounds(clip) {
            if (this._clipToBounds !== clip) {
                this._clipToBounds = clip;
                if (clip)
                    this.drawing.style.overflow = 'hidden';
                else
                    this.drawing.style.removeProperty('overflow');
            }
        }
        setClipRectangle(x, y, width, height) {
            this.clipX = x;
            this.clipY = y;
            this.clipWidth = width;
            this.clipHeight = height;
            this.updateClipRectangle();
        }
        updateClipRectangle() {
            if (this.clipX !== undefined && this.clipY !== undefined && this.clipWidth !== undefined && this.clipHeight !== undefined) {
                let x = Math.round(this.clipX);
                let y = Math.round(this.clipY);
                let width = Math.round(this.clipWidth);
                let height = Math.round(this.clipHeight);
                this.drawing.style.clip = 'rect(' + y + 'px ' + (x + width) + 'px ' + (y + height) + 'px ' + x + 'px)';
            }
            else {
                if ('removeProperty' in this.drawing.style)
                    this.drawing.style.removeProperty('clip');
                else if ('removeAttribute' in this.drawing.style)
                    this.drawing.style.removeAttribute('clip');
            }
        }
        set margin(margin) {
            this.marginTop = margin;
            this.marginBottom = margin;
            this.marginLeft = margin;
            this.marginRight = margin;
        }
        get marginTop() {
            return this._marginTop;
        }
        set marginTop(marginTop) {
            if (marginTop !== this._marginTop) {
                this._marginTop = marginTop;
                this.invalidateMeasure();
            }
        }
        get marginBottom() {
            return this._marginBottom;
        }
        set marginBottom(marginBottom) {
            if (marginBottom !== this._marginBottom) {
                this._marginBottom = marginBottom;
                this.invalidateMeasure();
            }
        }
        get marginLeft() {
            return this._marginLeft;
        }
        set marginLeft(marginLeft) {
            if (marginLeft !== this._marginLeft) {
                this._marginLeft = marginLeft;
                this.invalidateMeasure();
            }
        }
        get marginRight() {
            return this._marginRight;
        }
        set marginRight(marginRight) {
            if (marginRight !== this._marginRight) {
                this._marginRight = marginRight;
                this.invalidateMeasure();
            }
        }
        get opacity() {
            return this._opacity;
        }
        set opacity(opacity) {
            if (this._opacity !== opacity) {
                this._opacity = opacity;
                this.drawing.style.opacity = this._opacity.toString();
            }
        }
        focus() {
            if (this._focusable) {
                try {
                    this.drawing.focus();
                }
                catch (e) { }
            }
        }
        blur() {
            try {
                this.drawing.blur();
            }
            catch (e) { }
        }
        set transform(transform) {
            if (this._transform !== transform) {
                this._transform = transform;
                this.updateTransform();
            }
        }
        setTransformOrigin(x, y, absolute = false) {
            if ((this.transformOriginX !== x) || (this.transformOriginY !== y) || (this.transformOriginAbsolute !== absolute)) {
                this.transformOriginX = x;
                this.transformOriginY = y;
                this.transformOriginAbsolute = absolute;
                this.updateTransform();
            }
        }
        getInverseLayoutTransform() {
            let matrix = Ui.Matrix.createTranslate(this.layoutX, this.layoutY);
            if (this._transform !== undefined) {
                let originX = this.transformOriginX * this.layoutWidth;
                let originY = this.transformOriginY * this.layoutHeight;
                matrix = matrix.translate(-originX, -originY).multiply(this._transform).translate(originX, originY);
            }
            return matrix;
        }
        getLayoutTransform() {
            let matrix = new Ui.Matrix();
            if (this._transform !== undefined) {
                let originX = this.transformOriginX * this.layoutWidth;
                let originY = this.transformOriginY * this.layoutHeight;
                matrix = Ui.Matrix.createTranslate(-originX, -originY).
                    multiply(this._transform).
                    translate(originX, originY).
                    inverse();
            }
            return matrix.translate(-this.layoutX, -this.layoutY);
        }
        transformToWindow() {
            return Ui.Element.transformToWindow(this);
        }
        transformFromWindow() {
            return Ui.Element.transformFromWindow(this);
        }
        transformToElement(element) {
            let toMatrix = this.transformToWindow();
            let fromMatrix = element.transformFromWindow();
            return toMatrix.multiply(fromMatrix);
        }
        pointToWindow(point) {
            return point.multiply(this.transformToWindow());
        }
        pointFromWindow(point) {
            return point.multiply(this.transformFromWindow());
        }
        pointFromElement(element, point) {
            return this.pointFromWindow(element.pointToWindow(point));
        }
        getIsInside(point) {
            let p = point.multiply(this.getLayoutTransform());
            if ((p.x >= 0) && (p.x <= this._layoutWidth) &&
                (p.y >= 0) && (p.y <= this._layoutHeight))
                return true;
            return false;
        }
        set eventsHidden(eventsHidden) {
            this._eventsHidden = eventsHidden;
            this.invalidateArrange();
        }
        get eventsHidden() {
            return this._eventsHidden;
        }
        get measureWidth() {
            return this.collapse ? 0 : this._measureWidth;
        }
        get measureHeight() {
            return this.collapse ? 0 : this._measureHeight;
        }
        get isCollapsed() {
            return this.collapse;
        }
        hide(collapse = false) {
            if ((this._visible === undefined) || this._visible) {
                let old = this.isVisible;
                this._visible = false;
                this.drawing.style.display = 'none';
                if (old)
                    this.onInternalHidden();
            }
            if (this.collapse != collapse) {
                this.collapse = collapse;
                this.invalidateMeasure();
            }
        }
        show() {
            if ((this._visible === undefined) || !this._visible) {
                let old = this.isVisible;
                this._visible = true;
                this.drawing.style.display = 'block';
                if (this.isVisible && !old)
                    this.onInternalVisible();
            }
            if (this.collapse) {
                this.collapse = false;
                this.invalidateMeasure();
            }
        }
        get isVisible() {
            return ((this._parentVisible === true) && (this._visible !== false));
        }
        set isVisible(value) {
            if (value)
                this.show();
            else
                this.hide();
        }
        set parentVisible(visible) {
            let old = this.isVisible;
            this._parentVisible = visible;
            if (old != this.isVisible) {
                if (this.isVisible)
                    this.onInternalVisible();
                else
                    this.onInternalHidden();
            }
        }
        onInternalHidden() {
            this.onHidden();
            this.hidden.fire({ target: this });
        }
        onHidden() {
        }
        onInternalVisible() {
            this.onVisible();
            this.visible.fire({ target: this });
        }
        checkVisible() {
            if (this.drawing === undefined)
                return;
            let visible = false;
            let current = this.drawing;
            while (current != undefined) {
                if (current instanceof HTMLElement && current.style.display === 'none') {
                    visible = false;
                    break;
                }
                if (current == document.body) {
                    visible = true;
                    break;
                }
                current = current.parentNode;
            }
            if (this.isVisible !== visible)
                console.log('checkVisible expect: ' + this.isVisible + ', got: ' + visible + ' (on ' + this + ')');
        }
        onVisible() {
        }
        disable() {
            if ((this._disabled === undefined) || !this._disabled) {
                let old = this.isDisabled;
                this._disabled = true;
                if (!old)
                    this.onInternalDisable();
            }
        }
        enable() {
            if ((this._disabled === undefined) || this._disabled) {
                let old = this.isDisabled;
                this._disabled = false;
                if (old && !this.isDisabled)
                    this.onInternalEnable();
            }
        }
        setEnable(enable) {
            if (enable)
                this.enable();
            else
                this.disable();
        }
        get isDisabled() {
            if ((this._disabled !== undefined) && (this._disabled === true))
                return true;
            if ((this.parentDisabled !== undefined) && (this.parentDisabled === true))
                return true;
            return false;
        }
        set isDisabled(disabled) {
            if (disabled)
                this.disable();
            else
                this.enable();
        }
        setParentDisabled(disabled) {
            let old = this.isDisabled;
            this.parentDisabled = disabled;
            if (old !== this.isDisabled) {
                if (this.isDisabled)
                    this.onInternalDisable();
                else
                    this.onInternalEnable();
            }
        }
        onInternalDisable() {
            if (this._focusable) {
                this.drawing.tabIndex = -1;
                if (this._hasFocus)
                    this.blur();
            }
            this.onDisable();
            this.disabled.fire({ target: this });
        }
        onDisable() {
        }
        onInternalEnable() {
            if (this._focusable)
                this.drawing.tabIndex = 0;
            this.onEnable();
            this.enabled.fire({ target: this });
        }
        onEnable() {
        }
        containSubStyle(style) {
            return style['types'] != undefined && style['types'] instanceof Array;
        }
        fusionStyle(dst, src) {
            if (src['types'] == undefined || !(src['types'] instanceof Array))
                return;
            let mergeTypes = dst['types'] == undefined ? [] : dst['types'].slice();
            let pos = mergeTypes.findIndex((t) => t.types);
            if (pos != -1)
                mergeTypes.splice(pos, 1);
            for (let i = 0; i < src['types'].length; i++) {
                let srcStyle = src['types'][i];
                let dstStyle = this.getClassStyle(dst, srcStyle['type']);
                if (dstStyle != undefined) {
                    let mergeStyle = {};
                    for (let prop in dstStyle)
                        mergeStyle[prop] = dstStyle[prop];
                    for (let prop in srcStyle)
                        mergeStyle[prop] = srcStyle[prop];
                    let pos = mergeTypes.indexOf(dstStyle);
                    if (pos != -1)
                        mergeTypes.splice(pos, 1);
                    mergeTypes.push(mergeStyle);
                }
                else
                    mergeTypes.push(srcStyle);
            }
            dst['types'] = mergeTypes;
        }
        getClassStyle(style, classFunc) {
            if (style['types'] != undefined && (style['types'] instanceof Array)) {
                for (let i = 0; i < style['types'].length; i++) {
                    let pStyle = style['types'][i];
                    if (pStyle.type == classFunc)
                        return pStyle;
                }
            }
            return undefined;
        }
        mergeStyles() {
            let current;
            let found;
            this.mergeStyle = undefined;
            if (this._parentStyle != undefined) {
                current = this.constructor;
                found = false;
                while (current != undefined) {
                    let classStyle = this.getClassStyle(this._parentStyle, current);
                    if (classStyle != undefined && this.containSubStyle(classStyle)) {
                        if (this.mergeStyle == undefined)
                            this.mergeStyle = Core.Util.clone(this._parentStyle);
                        this.fusionStyle(this.mergeStyle, classStyle);
                        this.mergeStyle['types'].push(classStyle);
                        found = true;
                        break;
                    }
                    current = Object.getPrototypeOf(current.prototype);
                    if (current != null)
                        current = current.constructor;
                }
                if (!found)
                    this.mergeStyle = this._parentStyle;
            }
            if (this._style != undefined) {
                if (this.mergeStyle != undefined) {
                    this.mergeStyle = Core.Util.clone(this.mergeStyle);
                    this.fusionStyle(this.mergeStyle, this._style);
                    current = this.constructor;
                    while (current != undefined) {
                        let classStyle = this.getClassStyle(this._style, current);
                        if (classStyle != undefined && this.containSubStyle(classStyle)) {
                            this.fusionStyle(this.mergeStyle, classStyle);
                            break;
                        }
                        current = Object.getPrototypeOf(current.prototype);
                        if (current != null)
                            current = current.constructor;
                    }
                }
                else {
                    current = this.constructor;
                    found = false;
                    while (current != undefined) {
                        let classStyle = this.getClassStyle(this._style, current);
                        if (classStyle != undefined) {
                            if (this.mergeStyle == undefined)
                                this.mergeStyle = Core.Util.clone(this._style);
                            this.fusionStyle(this.mergeStyle, classStyle);
                            found = true;
                            break;
                        }
                        current = Object.getPrototypeOf(current.prototype);
                        if (current != null)
                            current = current.constructor;
                    }
                    if (!found)
                        this.mergeStyle = this._style;
                }
            }
        }
        getIsChildOf(parent) {
            let current = this;
            while (current != undefined) {
                if (current === parent)
                    return true;
                current = current.parent;
            }
            return false;
        }
        get parent() {
            return this._parent;
        }
        set parent(parent) {
            this._parent = parent;
        }
        getParentByClass(classFunc) {
            let current = this.parent;
            while (current != undefined) {
                if (current instanceof classFunc)
                    return current;
                current = current.parent;
            }
            return undefined;
        }
        setParentStyle(parentStyle) {
            if (this._parentStyle !== parentStyle)
                this._parentStyle = parentStyle;
            this.mergeStyles();
            this.onInternalStyleChange();
        }
        set style(style) {
            this._style = style;
            this.mergeStyles();
            this.onInternalStyleChange();
        }
        setStyleProperty(property, value) {
            if (this._style === undefined)
                this._style = {};
            this._style[property] = value;
            this.mergeStyles();
            this.onInternalStyleChange();
        }
        getStyleProperty(property, forClass) {
            let current;
            if (this._style != undefined && this._style[property] != undefined)
                return this._style[property];
            if (this.mergeStyle != undefined) {
                current = forClass !== null && forClass !== void 0 ? forClass : this.constructor;
                while (current != undefined) {
                    if (this.mergeStyle['types'] != undefined && (this.mergeStyle['types'] instanceof Array)) {
                        let classStyle = undefined;
                        for (let i = 0; classStyle == undefined && i < this.mergeStyle['types'].length; i++) {
                            let pStyle = this.mergeStyle['types'][i];
                            if (pStyle.type == current)
                                classStyle = pStyle;
                        }
                        if (classStyle != undefined && classStyle[property] != undefined)
                            return classStyle[property];
                    }
                    current = Object.getPrototypeOf(current.prototype);
                    if (current != null)
                        current = current.constructor;
                }
            }
            current = forClass !== null && forClass !== void 0 ? forClass : this.constructor;
            while (current != undefined) {
                if (('style' in current) && (property in current.style))
                    return current.style[property];
                current = Object.getPrototypeOf(current);
            }
            return undefined;
        }
        onInternalStyleChange() {
            if (!this._isLoaded)
                return;
            this.onStyleChange();
        }
        onStyleChange() {
        }
        get hasFocus() {
            return this._hasFocus;
        }
        scrollIntoView() {
            this.onScrollIntoView(this);
        }
        onScrollIntoView(el) {
            if (this._parent != undefined)
                this._parent.onScrollIntoView(el);
        }
        get(name) {
            return (this.name == name) ? this : undefined;
        }
        get isLoaded() {
            return this._isLoaded;
        }
        set isLoaded(isLoaded) {
            if (this._isLoaded !== isLoaded) {
                this._isLoaded = isLoaded;
                if (isLoaded)
                    this.onLoad();
                else
                    this.onUnload();
            }
        }
        onFocus(event) {
            if (!this._hasFocus && this._focusable && !this.isDisabled) {
                this._hasFocus = true;
                this.isMouseFocus = this.isMouseDownFocus;
                this.focused.fire({ target: this });
            }
        }
        onBlur(event) {
            if (this._hasFocus) {
                this.isMouseFocus = false;
                this._hasFocus = false;
                this.blurred.fire({ target: this });
            }
        }
        updateTransform() {
            if (this._transform !== undefined) {
                let matrix = this._transform;
                let x = this.transformOriginX;
                let y = this.transformOriginY;
                if (!this.transformOriginAbsolute) {
                    x *= this._layoutWidth;
                    y *= this._layoutHeight;
                }
                if ((x !== 0) || (y !== 0))
                    matrix = Ui.Matrix.createTranslate(x, y).multiply(this._transform).translate(-x, -y);
                this.drawing.style.transform = matrix.toString();
            }
            else {
                if ('removeProperty' in this.drawing.style)
                    this.drawing.style.removeProperty('transform');
            }
        }
        setAnimClock(clock) {
            if (this.animClock != undefined)
                this.animClock.stop();
            this.animClock = clock;
            if (clock != undefined)
                clock.completed.connect(() => this.onAnimClockComplete());
        }
        onAnimClockComplete() {
            this.animClock = undefined;
        }
        onLoad() {
            if (this._parent != undefined) {
                this.setParentStyle(this._parent.mergeStyle);
                this.setParentDisabled(this._parent.isDisabled);
                this.parentVisible = this._parent.isVisible;
            }
            else
                this.setParentStyle(Ui.App.style);
            if (!this.layoutValid)
                Ui.App.enqueueLayout(this);
            this.loaded.fire({ target: this });
        }
        onUnload() {
            if (this.animClock != undefined) {
                this.animClock.stop();
                this.animClock = undefined;
            }
            this.unloaded.fire({ target: this });
        }
        static transformToWindow(element) {
            let matrix = new Ui.Matrix();
            let current = element;
            while (current != undefined) {
                matrix = current.getInverseLayoutTransform().multiply(matrix);
                current = current._parent;
            }
            return matrix;
        }
        static transformFromWindow(element) {
            return Ui.Element.transformToWindow(element).inverse();
        }
        static elementFromPoint(point) {
            let element = document.elementFromPoint(point.x, point.y);
            while (element) {
                if (element.data && element.data instanceof Element)
                    return element.data;
                element = element.parentElement;
            }
            return undefined;
        }
        static getIsDrawingChildOf(drawing, parent) {
            let current = drawing;
            while (current != undefined) {
                if (current === parent)
                    return true;
                current = current.offsetParent;
            }
            return false;
        }
        static setSelectable(drawing, selectable) {
            drawing.selectable = selectable;
            if (selectable) {
                drawing.style.cursor = 'text';
                drawing.style.userSelect = 'text';
                if (Core.Navigator.isWebkit)
                    drawing.style.webkitUserSelect = 'text';
                else if (Core.Navigator.isGecko)
                    drawing.style.MozUserSelect = 'text';
            }
            else {
                drawing.style.cursor = 'inherit';
                drawing.style.userSelect = 'none';
                if (Core.Navigator.isWebkit)
                    drawing.style.webkitUserSelect = 'none';
                else if (Core.Navigator.isGecko)
                    drawing.style.MozUserSelect = 'none';
            }
        }
    }
    Ui.Element = Element;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Container extends Ui.Element {
        constructor(init) {
            super(init);
            this._containerDrawing = undefined;
            this._children = [];
            if (this._containerDrawing === undefined)
                this._containerDrawing = this.drawing;
        }
        get containerDrawing() {
            return this._containerDrawing;
        }
        set containerDrawing(containerDrawing) {
            this._containerDrawing = containerDrawing;
        }
        appendChild(child) {
            if (child.parent !== undefined) {
                console.error('try to load in the DOM an element already loaded');
                if (child.parent instanceof Container)
                    child.parent.removeChild(child);
            }
            child.parent = this;
            this._children.push(child);
            this._containerDrawing.appendChild(child.drawing);
            child.isLoaded = this.isLoaded;
            child.parentVisible = this.isVisible;
            child.parentDisabled = this.isDisabled;
            this.onChildInvalidateMeasure(child, 'add');
        }
        prependChild(child) {
            if (child.parent !== undefined) {
                console.error('try to load in the DOM an element already loaded');
                if (child.parent instanceof Container)
                    child.parent.removeChild(child);
            }
            child.parent = this;
            this._children.unshift(child);
            if (this._containerDrawing.firstChild !== undefined)
                this._containerDrawing.insertBefore(child.drawing, this._containerDrawing.firstChild);
            else
                this._containerDrawing.appendChild(child.drawing);
            child.isLoaded = this.isLoaded;
            child.parentVisible = this.isVisible;
            child.parentDisabled = this.isDisabled;
            this.onChildInvalidateMeasure(child, 'add');
        }
        removeChild(child) {
            if (child == undefined)
                return;
            child.parent = undefined;
            if (child.drawing != undefined && child.drawing.parentNode == this._containerDrawing)
                this._containerDrawing.removeChild(child.drawing);
            let i = 0;
            while ((i < this._children.length) && (this._children[i] !== child)) {
                i++;
            }
            if (i < this._children.length)
                this._children.splice(i, 1);
            child.isLoaded = false;
            child.parentVisible = false;
            this.onChildInvalidateMeasure(child, 'remove');
        }
        insertChildAt(child, position) {
            position = Math.max(0, Math.min(position, this._children.length));
            if (child.parent !== undefined) {
                console.error('try to load in the DOM an element already loaded');
                if (child.parent instanceof Container)
                    child.parent.removeChild(child);
            }
            child.parent = this;
            this._children.splice(position, 0, child);
            if ((this._containerDrawing.firstChild !== undefined) && (position < this._children.length - 1))
                this._containerDrawing.insertBefore(child.drawing, this._containerDrawing.childNodes[position]);
            else
                this._containerDrawing.appendChild(child.drawing);
            child.isLoaded = this.isLoaded;
            child.parentVisible = this.isVisible;
            child.parentDisabled = this.isDisabled;
            this.onChildInvalidateMeasure(child, 'add');
        }
        insertChildBefore(child, beforeChild) {
            this.insertChildAt(child, this.getChildPosition(beforeChild));
        }
        moveChildAt(child, position) {
            if (this._children.indexOf(child) == position)
                return;
            if (position < 0)
                position = this._children.length + position;
            if (position < 0)
                position = 0;
            if (position >= this._children.length)
                position = this._children.length;
            let i = 0;
            while ((i < this._children.length) && (this._children[i] !== child)) {
                i++;
            }
            if (i < this._children.length) {
                this._children.splice(i, 1);
                this._children.splice(position, 0, child);
                this._containerDrawing.removeChild(child.drawing);
                if ((this._containerDrawing.firstChild !== undefined) && (position < this._containerDrawing.childNodes.length))
                    this._containerDrawing.insertBefore(child.drawing, this._containerDrawing.childNodes[position]);
                else
                    this._containerDrawing.appendChild(child.drawing);
            }
            this.onChildInvalidateMeasure(child, 'move');
        }
        get children() {
            return this._children;
        }
        get firstChild() {
            if (this._children.length > 0)
                return this._children[0];
            else
                return undefined;
        }
        get lastChild() {
            if (this._children.length > 0)
                return this._children[this._children.length - 1];
            else
                return undefined;
        }
        getChildPosition(child) {
            for (let i = 0; i < this._children.length; i++) {
                if (this._children[i] === child) {
                    return i;
                }
            }
            return -1;
        }
        hasChild(child) {
            return this.getChildPosition(child) !== -1;
        }
        clear() {
            while (this.firstChild !== undefined) {
                this.removeChild(this.firstChild);
            }
        }
        get(name) {
            if (this.name == name)
                return this;
            else {
                for (let i = 0; i < this._children.length; i++) {
                    let child = this._children[i];
                    let res = child.get(name);
                    if (res != undefined)
                        return res;
                }
            }
            return undefined;
        }
        onLoad() {
            super.onLoad();
            for (let i = 0; i < this._children.length; i++)
                this._children[i].isLoaded = this.isLoaded;
        }
        onUnload() {
            super.onUnload();
            for (let i = 0; i < this._children.length; i++)
                this._children[i].isLoaded = this.isLoaded;
        }
        onInternalStyleChange() {
            if (!this.isLoaded)
                return;
            this.onStyleChange();
            if (this._children !== undefined) {
                for (let i = 0; i < this._children.length; i++)
                    this._children[i].setParentStyle(this.mergeStyle);
            }
        }
        onInternalDisable() {
            super.onInternalDisable();
            if (this._children) {
                for (let i = 0; i < this._children.length; i++)
                    this._children[i].setParentDisabled(true);
            }
        }
        onInternalEnable() {
            super.onInternalEnable();
            if (this._children) {
                for (let i = 0; i < this._children.length; i++)
                    this._children[i].setParentDisabled(false);
            }
        }
        onInternalVisible() {
            super.onInternalVisible();
            if (this._children) {
                for (let i = 0; i < this._children.length; i++)
                    this._children[i].parentVisible = true;
            }
        }
        onInternalHidden() {
            super.onInternalHidden();
            if (this._children) {
                for (let i = 0; i < this._children.length; i++)
                    this._children[i].parentVisible = false;
            }
        }
    }
    Ui.Container = Container;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class SvgParser extends Core.Object {
        constructor(path) {
            super();
            this.pos = 0;
            this.current = undefined;
            this.value = false;
            this.end = false;
            this.path = path;
        }
        isEnd() {
            return this.end;
        }
        next() {
            this.end = this.pos >= this.path.length;
            if (!this.end) {
                while ((this.pos < this.path.length) && ((this.path[this.pos] == ' ') || (this.path[this.pos] == ',') || (this.path[this.pos] == ';')))
                    this.pos++;
                let dotseen = false;
                let eseen = false;
                this.current = '';
                let c = this.path[this.pos];
                let isCmd = (c !== 'e') && ((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'));
                if (isCmd) {
                    this.current = this.path[this.pos++];
                    this.cmd = this.current;
                    this.value = false;
                }
                else {
                    while ((this.pos < this.path.length) && (((this.path[this.pos] >= '0') && (this.path[this.pos] <= '9')) ||
                        ((this.path[this.pos] === '-') && ((this.current.length == 0) || (this.current[this.current.length - 1] === 'e'))) ||
                        (!eseen && (this.path[this.pos] === 'e')) || (!dotseen && (this.path[this.pos] === '.')))) {
                        if (this.path[this.pos] === '.')
                            dotseen = true;
                        if (this.path[this.pos] === 'e')
                            eseen = true;
                        this.current += this.path[this.pos++];
                    }
                    this.value = true;
                    if (this.current[0] === '.')
                        this.current = '0' + this.current;
                    if ((this.current[0] === '-') && (this.current[1] === '.'))
                        this.current = '-0' + this.current.substring(1);
                    this.current = parseFloat(this.current);
                    if (isNaN(this.current))
                        throw ('bad number');
                }
            }
        }
        setCmd(cmd) {
            this.cmd = cmd;
        }
        getCmd() {
            return this.cmd;
        }
        getCurrent() {
            return this.current;
        }
        isCmd() {
            return !this.value;
        }
        isValue() {
            return this.value;
        }
    }
    Ui.SvgParser = SvgParser;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class CanvasElement extends Ui.Container {
        constructor(init) {
            super(init);
            this.dpiRatio = 1;
            this.generateNeeded = true;
            this._allowPointerEvent = false;
            this.selectable = false;
            this.canvasEngine = 'svg';
            this.drawing.style.overflow = 'hidden';
        }
        get allowPointerEvent() {
            return this._allowPointerEvent;
        }
        set allowPointerEvent(value) {
            if (this._allowPointerEvent != value) {
                this._allowPointerEvent = value;
                if (this.svgDrawing) {
                    if (value)
                        this.svgDrawing.removeAttribute('pointer-events');
                    else
                        this.svgDrawing.setAttribute('pointer-events', 'none');
                }
            }
        }
        get canvasEngine() {
            return this._canvasEngine;
        }
        set canvasEngine(value) {
            if (this._canvasEngine != value) {
                this._canvasEngine = value;
                this.generateNeeded = true;
                while (this.drawing.firstChild)
                    this.drawing.removeChild(this.drawing.firstChild);
                this._context = undefined;
                this.svgDrawing = undefined;
                this.canvasDrawing = undefined;
                this.invalidateDraw();
            }
        }
        update() {
            if (this.generateNeeded)
                this.renderCanvasDrawing();
            if (this.canvasEngine === 'canvas') {
                this._context.clearRect(0, 0, Math.ceil(this.layoutWidth * this.dpiRatio), Math.ceil(this.layoutHeight * this.dpiRatio));
                this._context.save();
                if (this.dpiRatio !== 1)
                    this._context.scale(this.dpiRatio, this.dpiRatio);
                this.updateCanvas(this._context);
                this._context.restore();
            }
            else {
                if (this.svgDrawing !== undefined)
                    this.drawing.removeChild(this.svgDrawing);
                let svgDrawing = document.createElementNS(svgNS, 'svg');
                svgDrawing.style.position = 'absolute';
                svgDrawing.style.top = '0px';
                svgDrawing.style.left = '0px';
                svgDrawing.style.width = this.layoutWidth + 'px';
                svgDrawing.style.height = this.layoutHeight + 'px';
                svgDrawing.setAttribute('focusable', 'false');
                svgDrawing.setAttribute('draggable', 'false');
                if (!this._allowPointerEvent)
                    svgDrawing.setAttribute('pointer-events', 'none');
                let ctx = new Core.SVG2DContext(svgDrawing);
                this.updateCanvas(ctx);
                this.svgDrawing = svgDrawing;
                this.svgDrawing.appendChild(ctx.getSVG());
                this.drawing.appendChild(this.svgDrawing);
            }
        }
        get context() {
            return this._context;
        }
        updateCanvas(context) {
        }
        renderCanvasDrawing() {
            let drawing;
            let resourceDrawing;
            if (this.canvasEngine === 'canvas') {
                drawing = this.canvasDrawing = document.createElement('canvas');
                if (this.layoutWidth) {
                    drawing.setAttribute('width', Math.ceil(this.layoutWidth * this.dpiRatio).toString());
                    drawing.style.width = Math.ceil(this.layoutWidth) + 'px';
                }
                if (this.layoutHeight) {
                    drawing.setAttribute('height', Math.ceil(this.layoutHeight * this.dpiRatio).toString());
                    drawing.style.height = Math.ceil(this.layoutHeight) + 'px';
                }
                this._context = drawing.getContext('2d');
            }
            else {
                drawing = document.createElement('div');
                resourceDrawing = document.createElement('div');
                resourceDrawing.style.width = '0px';
                resourceDrawing.style.height = '0px';
                resourceDrawing.style.visibility = 'hidden';
                drawing.appendChild(resourceDrawing);
                this.containerDrawing = resourceDrawing;
                drawing.toDataURL = this.svgToDataURL.bind(this);
            }
            this.generateNeeded = false;
            this.drawing.appendChild(drawing);
        }
        svgToDataURL() {
            let drawing = document.createElement('canvas');
            let context = drawing.getContext('2d');
            drawing.setAttribute('width', Math.ceil(this.layoutWidth).toString());
            drawing.setAttribute('height', Math.ceil(this.layoutHeight).toString());
            this.updateCanvas(context);
            return drawing.toDataURL.apply(drawing, arguments);
        }
        arrangeCore(width, height) {
            let devicePixelRatio = window.devicePixelRatio || 1;
            let backingStoreRatio = 1;
            if (this._context !== undefined) {
                let context = this._context;
                backingStoreRatio = context.webkitBackingStorePixelRatio ||
                    context.mozBackingStorePixelRatio ||
                    context.msBackingStorePixelRatio ||
                    context.oBackingStorePixelRatio ||
                    context.backingStorePixelRatio || 1;
            }
            this.dpiRatio = devicePixelRatio / backingStoreRatio;
            if (this.canvasDrawing) {
                this.canvasDrawing.setAttribute('width', Math.ceil(width * this.dpiRatio).toString());
                this.canvasDrawing.setAttribute('height', Math.ceil(height * this.dpiRatio).toString());
                this.canvasDrawing.style.width = Math.ceil(width) + 'px';
                this.canvasDrawing.style.height = Math.ceil(height) + 'px';
            }
            if (this.isVisible && this.isLoaded)
                this.update();
        }
        drawCore() {
            if ((this.layoutWidth !== 0) && (this.layoutHeight !== 0))
                this.update();
        }
        onInternalVisible() {
            super.onInternalVisible();
            this.invalidateDraw();
        }
    }
    Ui.CanvasElement = CanvasElement;
})(Ui || (Ui = {}));
var Core;
(function (Core) {
    class SVG2DPath extends Core.Object {
        constructor() {
            super();
            this.d = undefined;
            this.x = 0;
            this.y = 0;
            this.d = '';
        }
        moveTo(x, y) {
            this.d += ' M ' + x + ' ' + y;
            this.x = x;
            this.y = y;
        }
        lineTo(x, y) {
            this.d += ' L ' + x + ' ' + y;
            this.x = x;
            this.y = y;
        }
        quadraticCurveTo(cpx, cpy, x, y) {
            this.d += ' Q ' + cpx + ' ' + cpy + ' ' + x + ' ' + y;
            this.x = x;
            this.y = y;
        }
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
            this.d += ' C ' + cp1x + ' ' + cp1y + ' ' + cp2x + ' ' + cp2y + ' ' + x + ' ' + y;
            this.x = x;
            this.y = y;
        }
        arcTo(x1, y1, x2, y2, radiusX, radiusY, angle) {
            let vx1 = this.x - x1;
            let vy1 = this.y - y1;
            let vx2 = x2 - x1;
            let vy2 = y2 - y1;
            let p = vx1 * vy2 - vy1 * vx2;
            if (angle === undefined) {
                angle = radiusY;
                radiusY = radiusX;
            }
            this.d += ' A ' + radiusX + ' ' + radiusY + ' ' + (angle * Math.PI / 180) + ' 0 ' + ((p < 0) ? 1 : 0) + ' ' + x2 + ' ' + y2;
            this.x = x2;
            this.y = y2;
        }
        closePath() {
            this.d += ' Z';
        }
        rect(x, y, w, h) {
            this.moveTo(x, y);
            this.lineTo(x + w, y);
            this.lineTo(x + w, y + h);
            this.lineTo(x, y + h);
        }
        arc(x, y, radius, startAngle, endAngle, anticlockwise) {
            this.ellipse(x, y, radius, radius, 0, startAngle, endAngle, anticlockwise);
        }
        ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
            if ((rotation === 0) && (Math.abs(endAngle - startAngle) >= Math.PI * 2)) {
                this.moveTo(x, y + radiusY);
                if (anticlockwise) {
                    this.arcTo(x - radiusX, y + radiusY, x - radiusX, y, radiusX, radiusY, Math.PI / 2);
                    this.arcTo(x - radiusX, y - radiusY, x, y - radiusY, radiusX, radiusY, Math.PI / 2);
                    this.arcTo(x + radiusY, y - radiusY, x + radiusX, y, radiusX, radiusY, Math.PI / 2);
                    this.arcTo(x + radiusX, y + radiusY, x, y + radiusY, radiusX, radiusY, Math.PI / 2);
                }
                else {
                    this.arcTo(x + radiusX, y + radiusY, x + radiusX, y, radiusX, radiusY, Math.PI / 2);
                    this.arcTo(x + radiusX, y - radiusY, x, y - radiusY, radiusX, radiusY, Math.PI / 2);
                    this.arcTo(x - radiusX, y - radiusY, x - radiusX, y, radiusX, radiusY, Math.PI / 2);
                    this.arcTo(x - radiusX, y + radiusY, x, y + radiusY, radiusX, radiusY, Math.PI / 2);
                }
            }
            else {
                let startX = x + Math.cos(startAngle) * radiusX;
                let startY = y + Math.sin(startAngle) * radiusY;
                let endX = x + Math.cos(endAngle) * radiusX;
                let endY = y + Math.sin(endAngle) * radiusY;
                if (this.d == '')
                    this.moveTo(startX, startY);
                else
                    this.lineTo(startX, startY);
                let largeArc = (((endAngle - startAngle) + Math.PI * 2) % (Math.PI * 2)) > Math.PI;
                if (anticlockwise)
                    largeArc = !largeArc;
                this.d += ' A ' + radiusX + ' ' + radiusY + ' ' + ((endAngle - startAngle) * Math.PI / 180) + ' ' + (largeArc ? 1 : 0) + ' ' + (!anticlockwise ? 1 : 0) + ' ' + endX + ' ' + endY;
                this.x = endX;
                this.y = endY;
            }
        }
        roundRect(x, y, w, h, radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft, antiClockwise) {
            if (antiClockwise === true) {
                this.moveTo(x + radiusTopLeft, y);
                if (radiusTopLeft > 0)
                    this.arcTo(x, y, x, y + radiusTopLeft, radiusTopLeft, radiusTopLeft, Math.PI / 4);
                this.lineTo(x, y + h - radiusBottomLeft);
                if (radiusBottomLeft > 0)
                    this.arcTo(x, y + h, x + radiusBottomLeft, y + h, radiusBottomLeft, radiusBottomLeft, Math.PI / 4);
                this.lineTo(x + w - radiusBottomRight, y + h);
                if (radiusBottomRight > 0)
                    this.arcTo(x + w, y + h, x + w, y + h - radiusBottomRight, radiusBottomRight, radiusBottomRight, Math.PI / 4);
                this.lineTo(x + w, y + radiusTopRight);
                if (radiusTopRight > 0)
                    this.arcTo(x + w, y, x + w - radiusTopRight, y, radiusTopRight, radiusTopRight, Math.PI / 4);
            }
            else {
                this.moveTo(x, y + radiusTopLeft);
                if (radiusTopLeft > 0)
                    this.arcTo(x, y, x + radiusTopLeft, y, radiusTopLeft, radiusTopLeft, Math.PI / 4);
                this.lineTo(x + w - radiusTopRight, y);
                if (radiusTopRight > 0)
                    this.arcTo(x + w, y, x + w, y + radiusTopRight, radiusTopRight, radiusTopRight, Math.PI / 4);
                this.lineTo(x + w, y + h - radiusBottomRight);
                if (radiusBottomRight > 0)
                    this.arcTo(x + w, y + h, x + w - radiusBottomRight, y + h, radiusBottomRight, radiusBottomRight, Math.PI / 4);
                this.lineTo(x + radiusBottomLeft, y + h);
                if (radiusBottomLeft > 0)
                    this.arcTo(x, y + h, x, y + h - radiusBottomLeft, radiusBottomLeft, radiusBottomLeft, Math.PI / 4);
            }
        }
        getSVG() {
            let path = document.createElementNS(svgNS, 'path');
            path.setAttribute('d', this.d);
            return path;
        }
    }
    Core.SVG2DPath = SVG2DPath;
    class SVGGradient extends Core.Object {
        constructor(x0, y0, x1, y1) {
            super();
            this.gradient = undefined;
            this.id = undefined;
            this.gradient = document.createElementNS(svgNS, 'linearGradient');
            this.gradient.setAttributeNS(null, 'gradientUnits', 'userSpaceOnUse');
            this.gradient.setAttributeNS(null, 'x1', x0);
            this.gradient.setAttributeNS(null, 'y1', y0);
            this.gradient.setAttributeNS(null, 'x2', x1);
            this.gradient.setAttributeNS(null, 'y2', y1);
            this.id = '_grad' + (++Core.SVGGradient.counter);
            this.gradient.setAttributeNS(null, 'id', this.id);
        }
        getId() {
            return this.id;
        }
        addColorStop(offset, color) {
            let svgStop = document.createElementNS(svgNS, 'stop');
            svgStop.setAttributeNS(null, 'offset', offset);
            svgStop.style.stopColor = color;
            color = Ui.Color.create(color);
            svgStop.style.stopOpacity = color.getRgba().a;
            this.gradient.appendChild(svgStop);
        }
        getSVG() {
            return this.gradient;
        }
    }
    SVGGradient.counter = 0;
    Core.SVGGradient = SVGGradient;
    class SVG2DContext extends Core.Object {
        constructor(svgElement) {
            super();
            this.fillStyle = 'black';
            this.strokeStyle = 'black';
            this.lineWidth = 1;
            this.lineDash = undefined;
            this.globalAlpha = 1;
            this.currentTransform = undefined;
            this.font = 'default 10px sans-serif';
            this.textAlign = 'start';
            this.textBaseline = 'alphabetic';
            this.direction = 'inherit';
            this.clipId = undefined;
            this.title = undefined;
            this.document = undefined;
            this.currentPath = undefined;
            this.g = undefined;
            this.defs = undefined;
            this.states = undefined;
            this.document = svgElement;
            this.g = document.createElementNS(svgNS, 'g');
            this.currentTransform = this.document.createSVGMatrix();
            this.states = [];
            this.lineDash = [];
            this.defs = document.createElementNS(svgNS, 'defs');
            this.g.appendChild(this.defs);
        }
        beginPath() {
            this.currentPath = new Core.SVG2DPath();
        }
        moveTo(x, y) {
            this.currentPath.moveTo(x, y);
        }
        lineTo(x, y) {
            this.currentPath.lineTo(x, y);
        }
        quadraticCurveTo(cpx, cpy, x, y) {
            this.currentPath.quadraticCurveTo(cpx, cpy, x, y);
        }
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
            this.currentPath.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        }
        rect(x, y, w, h) {
            this.currentPath.rect(x, y, w, h);
        }
        arcTo(x1, y1, x2, y2, radius) {
            this.currentPath.arcTo(x1, y1, x2, y2, radius);
        }
        arc(x, y, radius, startAngle, endAngle, anticlockwise) {
            this.currentPath.arc(x, y, radius, startAngle, endAngle, anticlockwise);
        }
        ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
            this.currentPath.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
        }
        roundRect(x, y, w, h, radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft, antiClockwise = false) {
            this.currentPath.roundRect(x, y, w, h, radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft, antiClockwise);
        }
        closePath() {
            this.currentPath.closePath();
        }
        fill() {
            let svg = this.currentPath.getSVG();
            if (this.fillStyle instanceof Core.SVGGradient) {
                let id = this.fillStyle.getId();
                this.defs.appendChild(this.fillStyle.getSVG());
                svg.style.fill = 'url(#' + id + ')';
            }
            else
                svg.style.fill = this.fillStyle;
            if (this.clipId !== undefined)
                svg.setAttributeNS(null, 'clip-path', 'url(#' + this.clipId + ')');
            svg.style.opacity = this.globalAlpha;
            svg.transform.baseVal.initialize(this.document.createSVGTransformFromMatrix(this.currentTransform));
            if (this.title) {
                let title = document.createElementNS(svgNS, 'title');
                title.textContent = this.title;
                this.title = undefined;
                svg.appendChild(title);
            }
            this.g.appendChild(svg);
        }
        stroke() {
            let svg = this.currentPath.getSVG();
            svg.style.stroke = this.strokeStyle;
            svg.style.fill = 'none';
            svg.style.opacity = this.globalAlpha;
            svg.style.strokeWidth = this.lineWidth;
            if (this.clipId !== undefined)
                svg.setAttributeNS(null, 'clip-path', 'url(#' + this.clipId + ')');
            if (this.lineDash.length !== 0)
                svg.setAttributeNS(null, 'stroke-dasharray', this.lineDash.join(','));
            svg.setAttributeNS(null, 'pointer-events', 'none');
            svg.transform.baseVal.initialize(this.document.createSVGTransformFromMatrix(this.currentTransform));
            this.g.appendChild(svg);
        }
        clip() {
            let clip = document.createElementNS(svgNS, 'clipPath');
            this.clipId = '_clip' + (++Core.SVG2DContext.counter);
            clip.setAttributeNS(null, 'id', this.clipId);
            clip.appendChild(this.currentPath.getSVG());
            this.defs.appendChild(clip);
        }
        resetClip() {
            this.clipId = undefined;
        }
        getLineDash() {
            return this.lineDash;
        }
        setLineDash(lineDash) {
            this.lineDash = lineDash;
        }
        drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) {
            let img;
            let nw = image.naturalWidth;
            let nh = image.naturalHeight;
            if (sw === undefined) {
                dx = sx;
                dy = sy;
                sx = 0;
                sy = 0;
                sw = nw;
                sh = nh;
                dw = nw;
                dh = nh;
            }
            else if (dx === undefined) {
                dx = sx;
                dy = sy;
                dw = sw;
                dh = sh;
                sx = 0;
                sy = 0;
                sw = nw;
                sh = nh;
            }
            if ((sx === 0) && (sy === 0) && (sw === nw) && (sh == nh)) {
                img = document.createElementNS(svgNS, 'image');
                if (this.clipId !== undefined)
                    img.setAttributeNS(null, 'clip-path', 'url(#' + this.clipId + ')');
                img.style.opacity = this.globalAlpha.toString();
                img.setAttributeNS(null, 'pointer-events', 'none');
                img.href.baseVal = image.src;
                img.setAttributeNS(null, 'x', dx.toString());
                img.setAttributeNS(null, 'y', dy.toString());
                img.setAttributeNS(null, 'width', dw.toString());
                img.setAttributeNS(null, 'height', dh.toString());
                img.transform.baseVal.initialize(this.document.createSVGTransformFromMatrix(this.currentTransform));
                this.g.appendChild(img);
            }
            else {
                let pattern = document.createElementNS(svgNS, 'pattern');
                let id = '_pat' + (++Core.SVG2DContext.counter);
                pattern.setAttributeNS(null, 'id', id);
                pattern.setAttributeNS(null, 'patternUnits', 'userSpaceOnUse');
                pattern.setAttributeNS(null, 'x', dx.toString());
                pattern.setAttributeNS(null, 'y', dy.toString());
                pattern.setAttributeNS(null, 'width', dw.toString());
                pattern.setAttributeNS(null, 'height', dh.toString());
                img = document.createElementNS(svgNS, 'image');
                img.href.baseVal = image.src;
                img.setAttributeNS(null, 'x', (-sx * dw / sw).toString());
                img.setAttributeNS(null, 'y', (-sy * dh / sh).toString());
                img.setAttributeNS(null, 'width', (nw * dw / sw).toString());
                img.setAttributeNS(null, 'height', (nh * dh / sh).toString());
                pattern.appendChild(img);
                this.defs.appendChild(pattern);
                let path = document.createElementNS(svgNS, 'path');
                path.setAttributeNS(null, 'pointer-events', 'none');
                path.setAttributeNS(null, 'd', 'M ' + dx + ' ' + dy + ' L ' + (dx + dw) + ' ' + dy + ' L ' + (dx + dw) + ' ' + (dy + dh) + ' L ' + dx + ' ' + (dy + dh) + ' Z');
                path.style.fill = 'url(#' + id + ')';
                if (this.clipId !== undefined)
                    path.setAttributeNS(null, 'clip-path', 'url(#' + this.clipId + ')');
                path.style.opacity = this.globalAlpha;
                path.transform.baseVal.initialize(this.document.createSVGTransformFromMatrix(this.currentTransform));
                this.g.appendChild(path);
            }
        }
        fillText(text, x, y, maxWidth) {
            let t = document.createElementNS(svgNS, 'text');
            let textNode = document.createTextNode(text);
            t.appendChild(textNode);
            t.style.fill = this.fillStyle;
            t.style.opacity = this.globalAlpha;
            t.setAttributeNS(null, 'pointer-events', 'none');
            t.transform.baseVal.initialize(this.document.createSVGTransformFromMatrix(this.currentTransform));
            if (this.textAlign == 'center')
                t.style.textAnchor = 'middle';
            else if (this.textAlign == 'end')
                t.style.textAnchor = 'end';
            else if (this.textAlign == 'right')
                t.style.textAnchor = 'end';
            let font = this.parseFont(this.font);
            t.style.fontFamily = font.family;
            t.style.fontWeight = font.weight;
            t.style.fontSize = font.size.toString() + 'px';
            t.style.fontStyle = font.style;
            if (!Core.Navigator.isWebkit) {
                let fontSize = font.size;
                if (this.textBaseline === 'top')
                    y += fontSize * 0.8;
                else if (this.textBaseline === 'hanging')
                    y += fontSize * 0.8;
                else if (this.textBaseline === 'middle')
                    y += (fontSize * 0.8) / 2;
                else if (this.textBaseline === 'bottom')
                    y += fontSize * -0.2;
            }
            else {
                if (this.textBaseline === 'top')
                    t.style.alignmentBaseline = 'text-before-edge';
                else if (this.textBaseline === 'hanging')
                    t.style.alignmentBaseline = 'text-before-edge';
                else if (this.textBaseline === 'middle')
                    t.style.alignmentBaseline = 'central';
                else if (this.textBaseline === 'alphabetic')
                    t.style.alignmentBaseline = 'alphabetic';
                else if (this.textBaseline === 'ideographic')
                    t.style.alignmentBaseline = 'ideographic';
                else if (this.textBaseline === 'bottom')
                    t.style.alignmentBaseline = 'text-after-edge';
            }
            t.setAttributeNS(null, 'x', x);
            t.setAttributeNS(null, 'y', y);
            this.g.appendChild(t);
        }
        strokeText(text, x, y, maxWidth) {
        }
        save() {
            let state = {
                fillStyle: this.fillStyle,
                strokeStyle: this.strokeStyle,
                lineWidth: this.lineWidth,
                lineDash: this.lineDash,
                globalAlpha: this.globalAlpha,
                matrix: {
                    a: this.currentTransform.a, b: this.currentTransform.b,
                    c: this.currentTransform.c, d: this.currentTransform.d,
                    e: this.currentTransform.e, f: this.currentTransform.f
                },
                font: this.font,
                textAlign: this.textAlign,
                textBaseline: this.textBaseline,
                direction: this.direction,
                clipId: this.clipId
            };
            this.states.push(state);
        }
        restore() {
            if (this.states.length > 0) {
                let state = this.states.pop();
                this.fillStyle = state.fillStyle;
                this.strokeStyle = state.strokeStyle;
                this.lineWidth = state.lineWidth;
                this.lineDash = state.lineDash;
                this.globalAlpha = state.globalAlpha;
                this.currentTransform = this.document.createSVGMatrix();
                this.currentTransform.a = state.matrix.a;
                this.currentTransform.b = state.matrix.b;
                this.currentTransform.c = state.matrix.c;
                this.currentTransform.d = state.matrix.d;
                this.currentTransform.e = state.matrix.e;
                this.currentTransform.f = state.matrix.f;
                this.font = state.font;
                this.textAlign = state.textAlign;
                this.textBaseline = state.textBaseline;
                this.direction = state.direction;
                this.clipId = state.clipId;
            }
        }
        scale(x, y) {
            this.currentTransform = this.currentTransform.scaleNonUniform(x, (y === undefined) ? x : y);
        }
        rotate(angle) {
            this.currentTransform = this.currentTransform.rotate(angle * 180 / Math.PI);
        }
        translate(x, y) {
            this.currentTransform = this.currentTransform.translate(x, y);
        }
        transform(a, b, c, d, e, f) {
            let mulMatrix = this.document.createSVGMatrix();
            mulMatrix.a = a;
            mulMatrix.b = b;
            mulMatrix.c = c;
            mulMatrix.d = d;
            mulMatrix.e = e;
            mulMatrix.f = f;
            this.currentTransform = this.currentTransform.multiply(mulMatrix);
        }
        setTransform(a, b, c, d, e, f) {
            this.currentTransform.a = a;
            this.currentTransform.b = b;
            this.currentTransform.c = c;
            this.currentTransform.d = d;
            this.currentTransform.e = e;
            this.currentTransform.f = f;
        }
        resetTransform() {
            this.currentTransform = this.document.createSVGMatrix();
        }
        clearRect(x, y, w, h) {
        }
        fillRect(x, y, w, h) {
            this.beginPath();
            this.currentPath.rect(x, y, w, h);
            this.closePath();
            this.fill();
        }
        strokeRect(x, y, w, h) {
            this.beginPath();
            this.currentPath.rect(x, y, w, h);
            this.closePath();
            this.stroke();
        }
        createLinearGradient(x0, y0, x1, y1) {
            return new Core.SVGGradient(x0, y0, x1, y1);
        }
        measureText(text) {
            let font = this.parseFont(this.font);
            return Ui.Label.measureText(text, font.size, font.family, font.weight);
        }
        svgPath(path) {
            let x = 0;
            let y = 0;
            let x1;
            let y1;
            let x2;
            let y2;
            let x3;
            let y3;
            let beginX = 0;
            let beginY = 0;
            let parser = new Ui.SvgParser(path);
            parser.next();
            this.beginPath();
            while (!parser.isEnd()) {
                let cmd = parser.getCmd();
                if (parser.isCmd())
                    parser.next();
                if (cmd === 'm') {
                    parser.setCmd('l');
                    x += parser.getCurrent();
                    parser.next();
                    y += parser.getCurrent();
                    parser.next();
                    beginX = x;
                    beginY = y;
                    this.moveTo(x, y);
                }
                else if (cmd === 'M') {
                    parser.setCmd('L');
                    x = parser.getCurrent();
                    parser.next();
                    y = parser.getCurrent();
                    parser.next();
                    beginX = x;
                    beginY = y;
                    this.moveTo(x, y);
                }
                else if (cmd === 'l') {
                    x += parser.getCurrent();
                    parser.next();
                    y += parser.getCurrent();
                    parser.next();
                    this.lineTo(x, y);
                }
                else if (cmd === 'L') {
                    x = parser.getCurrent();
                    parser.next();
                    y = parser.getCurrent();
                    parser.next();
                    this.lineTo(x, y);
                }
                else if (cmd === 'v') {
                    y += parser.getCurrent();
                    parser.next();
                    this.lineTo(x, y);
                }
                else if (cmd === 'V') {
                    y = parser.getCurrent();
                    parser.next();
                    this.lineTo(x, y);
                }
                else if (cmd === 'h') {
                    x += parser.getCurrent();
                    parser.next();
                    this.lineTo(x, y);
                }
                else if (cmd === 'H') {
                    x = parser.getCurrent();
                    parser.next();
                    this.lineTo(x, y);
                }
                else if (cmd === 'c') {
                    x1 = x + parser.getCurrent();
                    parser.next();
                    y1 = y + parser.getCurrent();
                    parser.next();
                    x2 = x + parser.getCurrent();
                    parser.next();
                    y2 = y + parser.getCurrent();
                    parser.next();
                    x3 = x + parser.getCurrent();
                    parser.next();
                    y3 = y + parser.getCurrent();
                    parser.next();
                    x = x3;
                    y = y3;
                    this.bezierCurveTo(x1, y1, x2, y2, x, y);
                }
                else if (cmd === 'C') {
                    x1 = parser.getCurrent();
                    parser.next();
                    y1 = parser.getCurrent();
                    parser.next();
                    x2 = parser.getCurrent();
                    parser.next();
                    y2 = parser.getCurrent();
                    parser.next();
                    x3 = parser.getCurrent();
                    parser.next();
                    y3 = parser.getCurrent();
                    parser.next();
                    x = x3;
                    y = y3;
                    this.bezierCurveTo(x1, y1, x2, y2, x, y);
                }
                else if (cmd === 's') {
                    x1 = x + parser.getCurrent();
                    parser.next();
                    y1 = y + parser.getCurrent();
                    parser.next();
                    x2 = x1;
                    y2 = y1;
                    x3 = x + parser.getCurrent();
                    parser.next();
                    y3 = y + parser.getCurrent();
                    parser.next();
                    x = x3;
                    y = y3;
                    this.bezierCurveTo(x1, y1, x2, y2, x, y);
                    this.lineTo(x, y);
                }
                else if (cmd === 'S') {
                    x1 = parser.getCurrent();
                    parser.next();
                    y1 = parser.getCurrent();
                    parser.next();
                    x2 = x1;
                    y2 = y1;
                    x3 = parser.getCurrent();
                    parser.next();
                    y3 = parser.getCurrent();
                    parser.next();
                    x = x3;
                    y = y3;
                    this.bezierCurveTo(x1, y1, x2, y2, x, y);
                }
                else if (cmd === 'q') {
                    x1 = x + parser.getCurrent();
                    parser.next();
                    y1 = y + parser.getCurrent();
                    parser.next();
                    x2 = x + parser.getCurrent();
                    parser.next();
                    y2 = y + parser.getCurrent();
                    parser.next();
                    x = x2;
                    y = y2;
                    this.quadraticCurveTo(x1, y1, x, y);
                }
                else if (cmd === 'Q') {
                    x1 = parser.getCurrent();
                    parser.next();
                    y1 = parser.getCurrent();
                    parser.next();
                    x2 = parser.getCurrent();
                    parser.next();
                    y2 = parser.getCurrent();
                    parser.next();
                    x = x2;
                    y = y2;
                    this.quadraticCurveTo(x1, y1, x, y);
                }
                else if ((cmd === 'z') || (cmd === 'Z')) {
                    x = beginX;
                    y = beginY;
                    this.closePath();
                }
                else {
                    throw ('Invalid SVG path cmd: ' + cmd + ' (' + path + ')');
                }
            }
        }
        parseFont(font) {
            let tab = font.split(' ');
            if (tab.length === 1)
                return { style: 'default', weight: 'normal', size: 16, family: tab[0] };
            if (tab.length === 2)
                return { style: 'default', weight: 'normal', size: parseInt(tab[0]), family: tab[1] };
            else if (tab.length === 3)
                return { style: 'default', weight: tab[0], size: parseInt(tab[1]), family: tab[2] };
            else if (tab.length === 4)
                return { style: tab[0], weight: tab[1], size: parseInt(tab[2]), family: tab[3] };
            throw `Invalid font format ${font}`;
        }
        roundRectFilledShadow(x, y, width, height, radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft, inner, shadowWidth, color) {
            this.save();
            let rgba = color.getRgba();
            for (let i = 0; i < shadowWidth; i++) {
                let opacity;
                if (inner) {
                    if (shadowWidth == 1)
                        opacity = 1;
                    else {
                        let tx = (i + 1) / shadowWidth;
                        opacity = tx * tx;
                    }
                }
                else
                    opacity = (i + 1) / (shadowWidth + 1);
                color = new Ui.Color(rgba.r, rgba.g, rgba.b, rgba.a * opacity);
                this.fillStyle = color.getCssRgba();
                if (inner) {
                    this.beginPath();
                    this.roundRect(x, y, width, height, radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft);
                    this.roundRect(x + shadowWidth - i, y + shadowWidth - i, width - ((shadowWidth - i) * 2), height - ((shadowWidth - i) * 2), radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft, true);
                    this.closePath();
                    this.fill();
                }
                else {
                    this.beginPath();
                    this.roundRect(x + i, y + i, width - i * 2, height - i * 2, radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft);
                    this.closePath();
                    this.fill();
                }
            }
            this.restore();
        }
        getSVG() {
            return this.g;
        }
    }
    SVG2DContext.counter = 0;
    Core.SVG2DContext = SVG2DContext;
})(Core || (Core = {}));
CanvasRenderingContext2D.prototype['roundRect'] = Core.SVG2DPath.prototype.roundRect;
CanvasRenderingContext2D.prototype['svgPath'] = Core.SVG2DContext.prototype.svgPath;
CanvasRenderingContext2D.prototype['roundRectFilledShadow'] = Core.SVG2DContext.prototype.roundRectFilledShadow;
var Ui;
(function (Ui) {
    class Rectangle extends Ui.Element {
        constructor(init) {
            super(init);
            this._radiusTopLeft = 0;
            this._radiusTopRight = 0;
            this._radiusBottomLeft = 0;
            this._radiusBottomRight = 0;
            this._fill = new Ui.Color(0, 0, 0);
            if (init) {
                if (init.fill !== undefined)
                    this.fill = init.fill;
                if (init.radius !== undefined)
                    this.radius = init.radius;
                if (init.radiusTopLeft != undefined)
                    this.radiusTopLeft = init.radiusTopLeft;
                if (init.radiusTopRight !== undefined)
                    this.radiusTopRight = init.radiusTopRight;
                if (init.radiusBottomLeft !== undefined)
                    this.radiusBottomLeft = init.radiusBottomLeft;
                if (init.radiusBottomRight !== undefined)
                    this.radiusBottomRight = init.radiusBottomRight;
            }
        }
        set fill(fill) {
            if (this._fill !== fill) {
                if (typeof (fill) === 'string')
                    fill = Ui.Color.create(fill);
                this._fill = fill;
                if (this._fill instanceof Ui.Color)
                    this.drawing.style.background = this._fill.getCssRgba();
                else if (this._fill instanceof Ui.LinearGradient)
                    this.drawing.style.background = this._fill.getBackgroundImage();
            }
        }
        set radius(radius) {
            this.radiusTopLeft = radius;
            this.radiusTopRight = radius;
            this.radiusBottomLeft = radius;
            this.radiusBottomRight = radius;
        }
        get radiusTopLeft() {
            return this._radiusTopLeft;
        }
        set radiusTopLeft(radiusTopLeft) {
            this._radiusTopLeft = radiusTopLeft;
            this.drawing.style.borderTopLeftRadius = `${radiusTopLeft}px`;
        }
        get radiusTopRight() {
            return this._radiusTopRight;
        }
        set radiusTopRight(radiusTopRight) {
            this._radiusTopRight = radiusTopRight;
            this.drawing.style.borderTopRightRadius = `${radiusTopRight}px`;
        }
        get radiusBottomLeft() {
            return this._radiusBottomLeft;
        }
        set radiusBottomLeft(radiusBottomLeft) {
            this._radiusTopRight = radiusBottomLeft;
            this.drawing.style.borderBottomLeftRadius = `${radiusBottomLeft}px`;
        }
        get radiusBottomRight() {
            return this._radiusBottomRight;
        }
        set radiusBottomRight(radiusBottomRight) {
            this._radiusTopRight = radiusBottomRight;
            this.drawing.style.borderBottomRightRadius = `${radiusBottomRight}px`;
        }
    }
    Ui.Rectangle = Rectangle;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Separator extends Ui.Rectangle {
        constructor() {
            super();
            this.height = 1;
            this.width = 1;
        }
        onStyleChange() {
            this.fill = this.getStyleProperty('color');
        }
    }
    Separator.style = {
        color: '#444444'
    };
    Ui.Separator = Separator;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Shape extends Ui.CanvasElement {
        constructor(init) {
            super(init);
            this._scale = 1;
            if (init) {
                if (init.scale !== undefined)
                    this.scale = init.scale;
                if (init.fill !== undefined)
                    this.fill = init.fill;
                if (init.path !== undefined)
                    this.path = init.path;
            }
        }
        set scale(scale) {
            if (this._scale != scale) {
                this._scale = scale;
                this.invalidateDraw();
            }
        }
        get fill() {
            if (this._fill === undefined)
                return Ui.Color.create(this.getStyleProperty('color'));
            else
                return this._fill;
        }
        set fill(fill) {
            if (this._fill !== fill) {
                if (typeof (fill) === 'string')
                    fill = Ui.Color.create(fill);
                this._fill = fill;
                this.invalidateDraw();
            }
        }
        set path(path) {
            if (this._path != path) {
                this._path = path;
                this.invalidateDraw();
            }
        }
        onStyleChange() {
            this.invalidateDraw();
        }
        updateCanvas(ctx) {
            if (this._path === undefined)
                return;
            if (this._scale != 1)
                ctx.scale(this._scale, this._scale);
            ctx.svgPath(this._path);
            let fill = this.fill;
            if (fill instanceof Ui.Color)
                ctx.fillStyle = fill.getCssRgba();
            else if (fill instanceof Ui.LinearGradient)
                ctx.fillStyle = fill.getCanvasGradient(ctx, this.layoutWidth, this.layoutHeight);
            ctx.fill();
        }
    }
    Shape.style = {
        color: '#444444'
    };
    Ui.Shape = Shape;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Icon extends Ui.Element {
        constructor(init) {
            super(init);
            this._icon = '';
            this.loadingfailed = new Core.Events();
            if (init) {
                if (init.icon !== undefined)
                    this.icon = init.icon;
                if (init.fill !== undefined)
                    this.fill = init.fill;
                if (init.path !== undefined)
                    this.path = init.path;
            }
        }
        set onloadingfailed(value) { this.loadingfailed.connect(value); }
        get fill() {
            if (this._fill === undefined)
                return Ui.Color.create(this.getStyleProperty('color'));
            else
                return this._fill;
        }
        set fill(value) {
            this._fill = value;
            this.drawing.style.fill = Ui.Color.create(this.fill).getCssRgba();
        }
        set path(value) {
            let drawing = this.drawing;
            drawing.innerHTML =
                `<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48">
        <path d="${value}"/>
    </svg>`;
            this.normalize();
        }
        get icon() {
            return this._icon;
        }
        set icon(value) {
            if (this._icon == value)
                return;
            this._icon = value;
            if (Icon.forceExternal)
                this.loadIcon(value);
            else {
                let path = Icon.getPath(value);
                if (path == undefined)
                    this.loadIcon(value);
                else
                    this.path = path;
            }
        }
        onStyleChange() {
            this.drawing.style.fill = Ui.Color.create(this.fill).getCssRgba();
        }
        onLoadingFailed() {
            this.loadingfailed.fire({ target: this });
        }
        async loadIcon(value) {
            if (!(value.indexOf('.svg') + 4 == value.length && value.length > 4))
                value = `${value}.svg`;
            let drawing = this.drawing;
            if (Ui.Icon.iconsCache[value] != undefined) {
                drawing.innerHTML = Ui.Icon.iconsCache[value];
            }
            else {
                let req;
                if (Ui.Icon.loadingReqs[value] != undefined) {
                    req = Ui.Icon.loadingReqs[value];
                    await req.waitAsync();
                }
                else {
                    req = new Core.HttpRequest().assign({
                        url: `${Icon.baseUrl}${value}`
                    });
                    Ui.Icon.loadingReqs[value] = req;
                    await req.sendAsync();
                    delete (Ui.Icon.loadingReqs[value]);
                }
                if (req.status == 200) {
                    drawing.innerHTML = req.responseText;
                    this.normalize();
                    Ui.Icon.iconsCache[value] = this.drawing.innerHTML;
                }
                else {
                    drawing.innerHTML = '';
                    this.onLoadingFailed();
                }
            }
        }
        normalize() {
            let child = this.drawing.children.item(0);
            if (child instanceof SVGSVGElement) {
                let svgWidth = child.getAttribute('width');
                let svgHeight = child.getAttribute('height');
                let svgViewBox = child.getAttribute('viewBox');
                if (svgViewBox == null) {
                    if (svgWidth != null && svgHeight != null)
                        svgViewBox = `0 0 ${parseInt(svgWidth)} ${parseInt(svgHeight)}`;
                    else
                        svgViewBox = '0 0 48 48';
                    child.setAttribute('viewBox', svgViewBox);
                }
                child.style.width = '100%';
                child.style.height = '100%';
                child.style.position = 'absolute';
            }
        }
        static initialize() {
            this.register('check', 'M18 32.3L9.7 24l-2.8 2.8L18 38 42 14l-2.8-2.8z');
            this.register('home', 'm24 6-20 18 6 0 0 16 10 0 0-12 8 0 0 12 10 0 0-16 6 0z');
            this.register('search', 'M16.6 2.8C9.3 2.8 3.3 8.7 3.3 16 3.3 23.3 9.3 29.3 16.6 29.3 19.2 29.3 21.7 28.5 23.8 27.1L26.5 29.8C26 31.2 26.4 32.9 27.5 34L37 43.5C38.5 45.1 41.1 45.1 42.6 43.5L44.3 41.8C45.9 40.3 45.9 37.8 44.3 36.2L34.8 26.7C33.7 25.6 32.3 25.3 30.9 25.7L28 22.7C29.2 20.8 29.8 18.5 29.8 16 29.8 8.7 23.9 2.8 16.6 2.8zM16.6 6.8C21.7 6.8 25.8 10.9 25.8 16 25.8 21.2 21.7 25.3 16.6 25.3 11.4 25.3 7.3 21.2 7.3 16 7.3 10.9 11.4 6.8 16.6 6.8z');
            this.register('close', 'M38 12.82L35.18 10 24 21.18 12.82 10 10 12.82 21.18 24 10 35.18 12.82 38 24 26.82 35.18 38 38 35.18 26.82 24z');
            this.register('backarrow', 'M40 22H15.86l11.18-11.18L24 8l-16 16 16 16 2.82-2.82L15.66 26H40v-4z');
            this.register('arrowleft', 'm30 4 5 5-15 15 15 15-5 5-20-20z');
            this.register('arrowright', 'm18 4-5 5 15 15-15 15 5 5 20-20z');
            this.register('arrowtop', 'm44 31-5 5-15-15-15 15-5-5 20-20z');
            this.register('arrowbottom', 'm4 16 5-5 15 15 15-15 5 5-20 20z');
            this.register('refresh', 'M24 8C15.2 8 8 15.2 8 24 8 32.8 15.2 40 24 40 31.5 40 37.7 34.9 39.5 28l-4.2 0C33.7 32.7 29.2 36 24 36 17.4 36 12 30.6 12 24c0-6.6 5.4-12 12-12 3.3 0 6.3 1.4 8.4 3.6L26 22 40 22 40 8 35.3 12.7C32.4 9.8 28.4 8 24 8Z');
            this.register('deny', 'M24.4 4.6C13.8 4.6 5.3 13.1 5.3 23.6 5.3 34.2 13.8 42.7 24.4 42.7 34.9 42.7 43.4 34.2 43.4 23.6 43.4 13.1 34.9 4.6 24.4 4.6zM12.9 20.5L36.4 20.5 36.4 27.8 12.9 27.8 12.9 20.5z');
            this.register('warning', 'M2 42h44L24 4 2 42zm24-6h-4v-4h4v4zm0-8h-4v-8h4v8z');
            this.register('trash', 'm12 38 c0 2 1.8 4 4 4l16 0c2.2 0 4-1.8 4-4L36 14 11.6 14ZM38 8 31 8 29 6 19 6 17 8 10 8 10 12 38 12Z');
            this.register('new', 'M38 6H10c-2.22 0-4 1.8-4 4v28c0 2.2 2.78 4 4 4h28c2.2 0 4-1.8 4-4V10c0-2.2-1.8-4-4-4zm-4 20h-8v8h-4v-8H14v-4h8V14h4v8h8v4z');
            this.register('star', 'M24 34.54L36.36 42l-3.28-14.06L44 18.48l-14.38-1.22L24 4 18.38 17.26 4 18.48l10.92 9.46L11.64 42z');
            this.register('exit', 'M20.18 31.18L23 34l10-10-10-10-2.82 2.82L25.34 22H6v4h19.34l-5.16 5.18zM38 6H10c-2.22 0-4 1.8-4 4v4h4V10h28v28H10v-8H6v8c0 2.2 1.78 4 4 4h28c2.2 0 4-1.8 4-4V10c0-2.2-1.8-4-4-4z');
            this.register('loading', 'M24 2.5C22.1 2.5 20.5 4.1 20.5 6 20.5 7.9 22.1 9.5 24 9.5 25.9 9.5 27.5 7.9 27.5 6 27.5 4.1 25.9 2.5 24 2.5zM11.3 7.8C10.4 7.8 9.5 8.1 8.8 8.8 7.5 10.2 7.5 12.4 8.8 13.8 10.2 15.1 12.4 15.1 13.8 13.8 15.1 12.4 15.1 10.2 13.8 8.8 13.1 8.1 12.2 7.8 11.3 7.8zM36.7 7.8C35.8 7.8 34.9 8.1 34.3 8.8 32.9 10.2 32.9 12.4 34.3 13.8 35.6 15.1 37.8 15.1 39.2 13.8 40.5 12.4 40.5 10.2 39.2 8.8 38.5 8.1 37.6 7.8 36.7 7.8zM6 20.5C4.1 20.5 2.5 22.1 2.5 24 2.5 25.9 4.1 27.5 6 27.5 7.9 27.5 9.5 25.9 9.5 24 9.5 22.1 7.9 20.5 6 20.5zM42 20.5C40.1 20.5 38.5 22.1 38.5 24 38.5 25.9 40.1 27.5 42 27.5 43.9 27.5 45.5 25.9 45.5 24 45.5 22.1 43.9 20.5 42 20.5zM11.3 33.3C10.4 33.3 9.5 33.6 8.8 34.3 7.5 35.6 7.5 37.8 8.8 39.2 10.2 40.5 12.4 40.5 13.8 39.2 15.1 37.8 15.1 35.6 13.8 34.3 13.1 33.6 12.2 33.3 11.3 33.3zM36.7 33.3C35.8 33.3 34.9 33.6 34.3 34.3 32.9 35.6 32.9 37.8 34.3 39.2 35.6 40.5 37.8 40.5 39.2 39.2 40.5 37.8 40.5 35.6 39.2 34.3 38.5 33.6 37.6 33.3 36.7 33.3zM24 38.5C22.1 38.5 20.5 40.1 20.5 42 20.5 43.9 22.1 45.5 24 45.5 25.9 45.5 27.5 43.9 27.5 42 27.5 40.1 25.9 38.5 24 38.5z');
            this.register('edit', 'M6 34.5V42h7.5L35.62 19.88l-7.5-7.5L6 35.5zM41.42 14.08c.78-.78.78-2.04 0-2.82l-4.68-4.68c-.78-.78-2.04-.78-2.82 0l-3.66 3.66 7.5 7.5 3.66-3.66z');
            this.register('upload', 'M18 32h12v-12h8l-14-14-14 14h8zm-8 18h28v4H10z');
            this.register('lock', 'M24 2C18.5 2 14 6.5 14 12l0 4-2 0c-2.2 0-4 1.8-4 4l0 20c0 2.2 1.8 4 4 4l24 0c2.2 0 4-1.8 4-4 0-10.5 0-11.2 0-20 0-2.2-1.8-4-4-4l-2 0 0-4C34 6.5 29.5 2 24 2Zm0 3.8C27.4 5.8 30.2 8.6 30.2 12l0 4-12.4 0 0-4C17.8 8.6 20.6 5.8 24 5.8ZM24 26c2.2 0 4 1.8 4 4 0 2.2-1.8 4-4 4-2.2 0-4-1.8-4-4 0-2.2 1.8-4 4-4z');
            this.register('savecloud', 'M38.7 20.08C37.34 13.18 31.28 8 24 8 18.22 8 13.2 11.28 10.7 16.08 2.68 16.72 0 21.82 0 28c0 6.62 5.28 12 12 12h26c5.52 0 10-4.48 10-10 0-5.28-4.1-9.56-9.3-9.92zM28 26v8h-8v-8H14l10-10 10 10h-6z');
            this.register('calendar', 'M34 24h-10v10h10v-10zM32 2v4H16V2H12v4H10c-2.22 0-3.98 1.8-3.98 4L6 38c0 2.2 1.78 4 4 4h28c2.2 0 2-1.8 4-4V10c0-2.2-1.8-4-4-4h-2V2h-4zm6 36H10V16h28v22z');
            this.register('phone', 'M13.2 21.6c2.9 5.7 7.5 10.3 13.2 13.2l4.4-4.4c.5-.5 1.3-.7 2-.5 2.2 .7 4.7 1.1 7.1 1.1 1.1 0 2 .9 2 2V40c0 1.1-.9 2-2 2-18.8 0-34-15.2-34-34 0-1.1 .9-2 2-2h7c1.1 0 2 .9 2 2 0 2.5 .4 4.9 1.1 7.1 .2 .7 .1 1.5-.5 2l-4.4 4.4z');
            this.register('mail', 'M40 8H8c-2.2 0-4 1.8-4 4L4 36c0 2.2 1.8 4 4 4h32c2.2 0 4-1.8 4-4V12c0-2.2-1.8-4-4-4zm0 8l-16 10-16-10V12l16 10 16-10v4z');
            this.register('plus', 'M38 26h-12v12h-4v-12H10v-4h12V10h4v12h12v4z');
            this.register('eye', 'M24.2 10.4C11.7 10.4 2 23.6 1.6 24.2L.9 25.1 1.6 26.1C2 26.7 11.7 39.9 24.2 39.9 36.6 39.9 46.3 26.7 46.7 26.1L47.4 25.1 46.7 24.2C46.3 23.6 36.6 10.4 24.2 10.4zM24.2 13.7C33.1 13.7 40.9 22.2 43.3 25.1 41 28 33.1 36.6 24.2 36.6 15.2 36.6 7.4 28 5 25.1 7.4 22.2 15.2 13.7 24.2 13.7zM24.8 15.2C19.4 15.2 15 19.6 15 24.9 15 30.3 19.4 34.7 24.8 34.7 30.2 34.7 34.6 30.3 34.6 24.9 34.6 23.1 34.1 21.5 33.3 20 33.1 22.1 31.4 23.8 29.3 23.8 27 23.8 25.3 22 25.3 19.8 25.3 17.9 26.7 16.3 28.5 15.9 27.4 15.5 26.1 15.2 24.8 15.2z');
            this.register('map', 'M41 6l-.3 .1L30 10.2 18 6 6.7 9.8c-.4 .1-.7 .5-.7 1V41c0 .6 .4 1 1 1l.3-.1L18 37.8l12 4.2 11.3-3.8c.4-.1 .7-.5 .7-1V7c0-.6-.4-1-1-1zM30 38l-12-4.2V10l12 4.2V38z');
            this.register('sortarrow', 'm4 32 40 0-20-20z');
            this.register('dragcopy', 'M24 .2C10.8 .2 .2 10.8 .2 24 .2 37.2 10.8 47.8 24 47.8 37.2 47.8 47.8 37.2 47.8 24 47.8 10.8 37.2 .2 24 .2zm-4.5 5.9 8.9 0 0 13.5 13.5 0 0 8.9-13.5 0 0 13.5-8.9 0 0-13.6-13.5 .1 0-8.9 13.5 0z');
            this.register('dragmove', 'M24 .2C10.8 .2 .2 10.8 .2 24 .2 37.2 10.8 47.8 24 47.8 37.2 47.8 47.8 37.2 47.8 24 47.8 10.8 37.2 .2 24 .2zM26.6 8.6L42 24 26.6 39.4 21.4 34.3 26.6 29.2 6 29.2 6 18.8 26.6 18.8 21.4 13.8 26.6 8.6z');
            this.register('draglink', 'M24 .2C10.8 .2 .2 10.8 .2 24 .2 37.2 10.8 47.8 24 47.8 37.2 47.8 47.8 37.2 47.8 24 47.8 10.8 37.2 .2 24 .2zM34.9 13.9C40.7 13.9 44.3 18.3 44.3 23.9 44.3 29.6 40.8 34.1 34.8 34.1 30.2 34.1 26.9 31.1 24 27.8 21 31.1 18.1 34.1 13.3 34.1 7.4 34.1 3.7 29.7 3.7 24 3.7 18.4 7.2 13.9 13.1 13.9 17.9 13.9 21.1 17.2 24 20.6 26.9 17.2 30.1 13.9 34.9 13.9zM34.8 19.3C31.9 19.3 29.1 22.1 27.2 24.1 29.2 26.3 31.8 28.7 34.9 28.7 37.7 28.7 39.3 26.7 39.3 24.1 39.3 21.4 37.6 19.3 34.8 19.3zM13.1 19.3C10.4 19.3 8.8 21.6 8.8 24.1 8.8 26.8 10.5 28.7 13.2 28.7 16.1 28.7 19 26.1 20.8 24.1 18.9 22.2 15.9 19.3 13.1 19.3z');
            this.register('dragchoose', 'M24 .2C10.8 .2 .2 10.8 .2 24 .2 37.2 10.8 47.8 24 47.8 37.2 47.8 47.8 37.2 47.8 24 47.8 10.8 37.2 .2 24 .2zM23.6 3.3L25.9 3.3C33.1 3.3 37.8 8 37.8 14.7 37.8 22.1 33.3 24 29.7 25.6 27.7 26.6 26 27.4 26 29.8 26 31.4 26.4 32.3 26.4 32.8 26.4 33.2 26.2 33.3 25.8 33.3L19.7 33.3C19.3 33.3 19.1 33.1 19 32.8 18.8 31.6 18.6 30.2 18.6 28.9 18.6 23 22.8 21.3 26.3 19.5 28.5 18.4 30.4 17.3 30.4 14.7 30.4 12.1 28.4 10.1 25.9 10.1L23.6 10.1C21.8 10.1 20.2 11.1 19 13.8 18.9 14.2 18.7 14.3 18.5 14.3 18.2 14.3 18 14.1 17.8 14L12.6 11.3C12.4 11.2 12.2 11.1 12.2 10.9 12.2 10.5 12.9 9.5 13.4 8.5 15.4 5.5 18.3 3.3 23.6 3.3zM23.4 36.4C25.7 36.4 27.7 38.4 27.7 40.7 27.7 43 25.7 44.9 23.4 44.9 21.1 44.9 19.1 43 19.1 40.7 19.1 38.4 21.1 36.4 23.4 36.4z');
            this.register('dragrun', 'M24 2.4C12.1 2.4 2.4 12.1 2.4 24 2.4 36 12.1 45.6 24 45.6 36 45.6 45.6 36 45.6 24 45.6 12.1 36 2.4 24 2.4zM23.9 7.8C24 7.8 24 7.8 24 7.8 27 7.8 29.8 8.6 32.2 10L30.4 13.1C32.3 14.2 33.8 15.7 34.9 17.6L38 15.8C39.4 18.2 40.3 21 40.3 24 40.3 24 40.3 24 40.3 24.1L36.7 24C36.7 26.3 36.1 28.4 35 30.3L38.1 32.1C36.7 34.6 34.6 36.7 32.1 38.1L30.3 35C28.4 36.1 26.3 36.7 24 36.7L24.1 40.3C24 40.3 24 40.3 24 40.3 21 40.3 18.2 39.4 15.8 38L17.6 34.9C15.7 33.8 14.2 32.3 13.1 30.4L10 32.2C8.6 29.8 7.8 27 7.8 24 7.8 24 7.8 24 7.8 23.9L11.3 24C11.3 21.7 12 19.6 13 17.7L9.9 15.9C11.3 13.4 13.4 11.3 15.9 9.9L17.7 13C19.6 12 21.7 11.3 24 11.3L23.9 7.8zM24 18.8C21.1 18.8 18.8 21.1 18.8 24 18.8 26.9 21.1 29.2 24 29.2 26.9 29.2 29.2 26.9 29.2 24 29.2 21.1 26.9 18.8 24 18.8z');
            this.register('dragplay', 'M24 .2C10.8 .2 .2 10.8 .2 24 .2 37.2 10.8 47.8 24 47.8 37.2 47.8 47.8 37.2 47.8 24 47.8 10.8 37.2 .2 24 .2zM13.8 7.8L42.2 24 13.8 40.3 13.8 7.8z');
            this.register('burger', 'M24 1.47C20.77 1.48 18.16 4.17 18.16 7.49 18.16 10.82 20.77 13.52 24 13.52 27.23 13.52 29.84 10.82 29.84 7.49 29.84 4.17 27.23 1.48 24 1.47Zm0 16.42c-3.23 0-5.84 2.7-5.84 6.02 0 3.33 2.61 6.02 5.84 6.02 3.23 0 5.84-2.7 5.84-6.02C29.84 20.59 27.23 17.9 24 17.9Zm0 16.42c-3.23 0-5.84 2.7-5.84 6.02 0 3.33 2.61 6.02 5.84 6.02 3.23 0 5.84-2.7 5.84-6.02C29.84 37.01 27.23 34.32 24 34.32Z');
        }
        static getPath(icon) {
            return Icon.icons[icon];
        }
        static getNames() {
            let names = new Array();
            for (let tmp in Icon.icons)
                names.push(tmp);
            return names;
        }
        static register(iconName, iconPath) {
            if (Icon.icons[iconName] !== undefined)
                throw ('Icon \'' + iconName + '\' is already registered. To change it, use override');
            Icon.icons[iconName] = iconPath;
        }
        static override(iconName, iconPath) {
            Icon.icons[iconName] = iconPath;
        }
        static parse(icon) {
            let ico = new Icon();
            ico.icon = icon;
            return ico;
        }
        static drawIcon(ctx, icon, size, fill) {
            ctx.save();
            let scale = size / 48;
            ctx.scale(scale, scale);
            ctx.svgPath(Icon.getPath(icon));
            ctx.fillStyle = fill;
            ctx.fill();
            ctx.restore();
        }
        static drawIconAndBadge(ctx, icon, size, fill, badgeText, badgeSize, badgeFill, textFill) {
            ctx.save();
            let scale = size / 48;
            badgeSize /= scale;
            let textHeight = badgeSize * 0.75;
            ctx.font = 'bold ' + textHeight + 'px sans-serif';
            let textSize = ctx.measureText(badgeText);
            let textWidth = textSize.width;
            let badgeWidth = Math.max(badgeSize, textWidth * 1.25);
            ctx.scale(scale, scale);
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 0, 48, 48);
            ctx.roundRect(1, 48 - 5 - badgeSize, badgeWidth + 4, badgeSize + 4, badgeSize / 2, badgeSize / 2, badgeSize / 2, badgeSize / 2, true);
            ctx.closePath();
            ctx.clip();
            ctx.svgPath(Icon.getPath(icon));
            ctx.fillStyle = fill;
            ctx.fill();
            ctx.restore();
            ctx.fillStyle = badgeFill;
            ctx.beginPath();
            ctx.roundRect(3, 48 - 3 - badgeSize, badgeWidth, badgeSize, badgeSize / 2, badgeSize / 2, badgeSize / 2, badgeSize / 2);
            ctx.closePath();
            ctx.fill();
            ctx.textBaseline = 'middle';
            ctx.fillStyle = textFill;
            ctx.fillText(badgeText, 3 + ((badgeWidth - textWidth) / 2), 48 - (3 + (badgeSize / 2)));
            ctx.restore();
        }
    }
    Icon.baseUrl = '';
    Icon.forceExternal = false;
    Icon.loadingReqs = {};
    Icon.iconsCache = {};
    Icon.style = {
        color: '#444444'
    };
    Icon.icons = {};
    Ui.Icon = Icon;
})(Ui || (Ui = {}));
Ui.Icon.initialize();
var Ui;
(function (Ui) {
    class DualIcon extends Ui.CanvasElement {
        constructor(init) {
            super(init);
            if (init) {
                if (init.icon !== undefined)
                    this.icon = init.icon;
                if (init.fill !== undefined)
                    this.fill = init.fill;
                if (init.stroke !== undefined)
                    this.stroke = init.stroke;
                if (init.strokeWidth !== undefined)
                    this.strokeWidth = init.strokeWidth;
            }
        }
        set icon(icon) {
            this._icon = icon;
            this.invalidateDraw();
        }
        get fill() {
            if (this._fill === undefined)
                return Ui.Color.create(this.getStyleProperty('fill'));
            else
                return this._fill;
        }
        set fill(fill) {
            this._fill = fill;
            this.invalidateDraw();
        }
        get stroke() {
            if (this._stroke === undefined)
                return Ui.Color.create(this.getStyleProperty('stroke'));
            else
                return this._stroke;
        }
        set stroke(stroke) {
            this._stroke = stroke;
            this.invalidateDraw();
        }
        get strokeWidth() {
            if (this._strokeWidth === undefined)
                return this.getStyleProperty('strokeWidth');
            else
                return this._strokeWidth;
        }
        set strokeWidth(strokeWidth) {
            this._strokeWidth = strokeWidth;
            this.invalidateDraw();
        }
        updateCanvas(ctx) {
            if (!this._icon)
                return;
            let strokeWidth = this.strokeWidth;
            ctx.save();
            let scale = Math.min(this.layoutWidth, this.layoutHeight) / 48;
            ctx.scale(scale, scale);
            ctx.translate(strokeWidth, strokeWidth);
            let scale2 = (48 - (strokeWidth * 2)) / 48;
            ctx.scale(scale2, scale2);
            let path = Ui.Icon.getPath(this._icon);
            if (path == undefined)
                throw `Icon '${this._icon}' NOT AVAILABLE for DualIcon`;
            ctx.svgPath(path);
            ctx.strokeStyle = this.stroke.getCssRgba();
            ctx.lineWidth = strokeWidth * 2;
            ctx.stroke();
            ctx.fillStyle = this.fill.getCssRgba();
            ctx.fill();
            ctx.restore();
        }
    }
    DualIcon.style = {
        fill: '#ffffff',
        stroke: '#000000',
        strokeWidth: 2
    };
    Ui.DualIcon = DualIcon;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Event extends Core.Object {
        constructor() {
            super();
            this.bubbles = true;
            this.cancelable = true;
            this.cancelBubble = false;
            this.stop = false;
        }
        stopPropagation() {
            this.cancelBubble = true;
        }
        stopImmediatePropagation() {
            this.stop = true;
        }
        getIsPropagationStopped() {
            return this.stop || this.cancelBubble;
        }
        setType(type) {
            this.type = type;
        }
        setBubbles(bubbles) {
            this.bubbles = bubbles;
        }
        dispatchEvent(target) {
            this.target = target;
            if (this.bubbles) {
                let stack = [];
                let current = this.target;
                while (current != undefined) {
                    stack.push(current);
                    current = current.parent;
                }
                for (let i = stack.length - 1; (i >= 0) && (!this.cancelBubble) && (!this.stop); i--) {
                    current = stack[i];
                    if (this.type in current && current[this.type] instanceof Core.Events) {
                        let handlers = current[this.type].list;
                        for (let i2 = 0; (i2 < handlers.length) && (!this.stop); i2++) {
                            let handler = handlers[i2];
                            if (handler.capture)
                                handler.handler(this);
                        }
                    }
                }
                for (let i = 0; (i < stack.length) && (!this.cancelBubble) && (!this.stop); i++) {
                    current = stack[i];
                    if (this.type in current && current[this.type] instanceof Core.Events) {
                        let handlers = current[this.type].list;
                        for (let i2 = 0; (i2 < handlers.length) && (!this.stop); i2++) {
                            let handler = handlers[i2];
                            if (!handler.capture)
                                handler.handler(this);
                        }
                    }
                }
            }
            else {
                if (this.type in this.target && this.target[this.type] instanceof Core.Events) {
                    let handlers = this.target[this.type].list;
                    for (let i2 = 0; (i2 < handlers.length) && (!this.stop); i2++) {
                        let handler = handlers[i2];
                        if (handler.capture)
                            handler.handler(this);
                    }
                    for (let i2 = 0; (i2 < handlers.length) && (!this.stop); i2++) {
                        let handler = handlers[i2];
                        if (!handler.capture)
                            handler.handler(this);
                    }
                }
            }
        }
    }
    Ui.Event = Event;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class EmuPointerEvent extends Ui.Event {
        constructor(type, pointer) {
            super();
            this.clientX = 0;
            this.clientY = 0;
            this.pointerType = 'mouse';
            this.setType(type);
            this.pointer = pointer;
            this.clientX = this.pointer.getX();
            this.clientY = this.pointer.getY();
            this.pointerType = this.pointer.getType();
        }
    }
    Ui.EmuPointerEvent = EmuPointerEvent;
    class PointerWatcher extends Core.Object {
        constructor(element, pointer) {
            super();
            this.downed = new Core.Events();
            this.moved = new Core.Events();
            this.upped = new Core.Events();
            this.cancelled = new Core.Events();
            this.element = element;
            this.pointer = pointer;
        }
        getAbsoluteDelta() {
            if (!this.pointer) {
                return { x: 0, y: 0 };
            }
            let initial = { x: this.pointer.getInitialX(), y: this.pointer.getInitialY() };
            let current = { x: this.pointer.getX(), y: this.pointer.getY() };
            return { x: current.x - initial.x, y: current.y - initial.y };
        }
        getDelta() {
            if (!this.pointer) {
                return { x: 0, y: 0 };
            }
            let initial = new Ui.Point(this.pointer.getInitialX(), this.pointer.getInitialY());
            let current = new Ui.Point(this.pointer.getX(), this.pointer.getY());
            initial = this.element.pointFromWindow(initial);
            current = this.element.pointFromWindow(current);
            return { x: current.x - initial.x, y: current.y - initial.y };
        }
        getPosition() {
            let current = this.pointer ? new Ui.Point(this.pointer.getX(), this.pointer.getY()) : new Ui.Point();
            return this.element.pointFromWindow(current);
        }
        getIsInside() {
            let pos = this.getPosition();
            if ((pos.x >= 0) && (pos.x <= this.element.layoutWidth) &&
                (pos.y >= 0) && (pos.y <= this.element.layoutHeight))
                return true;
            return false;
        }
        getDirection() {
            let delta = this.getDelta();
            if (Math.abs(delta.x) > Math.abs(delta.y)) {
                if (delta.x < 0)
                    return 'left';
                else
                    return 'right';
            }
            else {
                if (delta.y < 0)
                    return 'top';
                else
                    return 'bottom';
            }
        }
        getSpeed() {
            if ((this.pointer === undefined) || (this.pointer.history.length < 2))
                return { x: 0, y: 0 };
            else {
                let measure;
                let i = this.pointer.history.length;
                let now = { time: (new Date().getTime()) / 1000, x: this.pointer.x, y: this.pointer.y };
                do {
                    measure = this.pointer.history[--i];
                } while ((i > 0) && ((now.time - measure.time) < 0.08));
                let deltaTime = now.time - measure.time;
                return {
                    x: (now.x - measure.x) / deltaTime,
                    y: (now.y - measure.y) / deltaTime
                };
            }
        }
        getIsCaptured() {
            return (this.pointer !== undefined) && (this.pointer.captureWatcher === this);
        }
        capture() {
            if (this.pointer)
                this.pointer.capture(this);
        }
        release() {
            if (this.pointer)
                this.pointer.release(this);
        }
        cancel() {
            if (this.pointer != undefined) {
                this.cancelled.fire({ target: this });
                this.pointer.unwatch(this);
            }
        }
        down() {
            if (this.pointer != undefined)
                this.downed.fire({ target: this });
        }
        move() {
            if (this.pointer != undefined)
                this.moved.fire({ target: this });
        }
        up() {
            if (this.pointer != undefined)
                this.upped.fire({ target: this });
        }
        unwatch() {
            if (this.pointer != undefined)
                this.pointer.unwatch(this);
        }
    }
    Ui.PointerWatcher = PointerWatcher;
    class Pointer extends Core.Object {
        constructor(type, id) {
            super();
            this.x = 0;
            this.y = 0;
            this.initialX = 0;
            this.initialY = 0;
            this.altKey = false;
            this.ctrlKey = false;
            this.shiftKey = false;
            this.cumulMove = 0;
            this.chainLevel = 0;
            this.captureWatcher = undefined;
            this.history = undefined;
            this.buttons = 0;
            this.button = 0;
            this.ptrmoved = new Core.Events();
            this.ptrupped = new Core.Events();
            this.ptrdowned = new Core.Events();
            this.ptrcanceled = new Core.Events();
            this.type = type;
            this.id = id;
            this.start = (new Date().getTime()) / 1000;
            this.watchers = [];
            this.history = [];
        }
        capture(watcher) {
            let watchers = this.watchers.slice();
            for (let i = 0; i < watchers.length; i++) {
                if (watchers[i] !== watcher)
                    watchers[i].cancel();
            }
            this.captureWatcher = watcher;
        }
        release(watcher) {
            this.captureWatcher = undefined;
        }
        getType() {
            return this.type;
        }
        getIsDown() {
            return this.buttons !== 0;
        }
        getIsCaptured() {
            return (this.captureWatcher !== undefined);
        }
        getX() {
            return this.x;
        }
        getY() {
            return this.y;
        }
        getInitialX() {
            return this.initialX;
        }
        getInitialY() {
            return this.initialY;
        }
        setInitialPosition(x, y) {
            this.initialX = x;
            this.initialY = y;
        }
        getButtons() {
            return this.buttons;
        }
        setButtons(buttons) {
            this.buttons = buttons;
        }
        getChainLevel() {
            return this.chainLevel;
        }
        getAltKey() {
            return this.altKey;
        }
        setAltKey(altKey) {
            this.altKey = altKey;
        }
        getCtrlKey() {
            return this.ctrlKey;
        }
        setCtrlKey(ctrlKey) {
            this.ctrlKey = ctrlKey;
        }
        getShiftKey() {
            return this.shiftKey;
        }
        setShiftKey(shiftKey) {
            this.shiftKey = shiftKey;
        }
        setControls(altKey, ctrlKey, shiftKey) {
            this.altKey = altKey;
            this.ctrlKey = ctrlKey;
            this.shiftKey = shiftKey;
        }
        move(x, y) {
            if (x === undefined)
                x = this.x;
            if (y === undefined)
                y = this.y;
            if ((this.x !== x) || (this.y !== y)) {
                let deltaX = this.x - x;
                let deltaY = this.y - y;
                this.cumulMove += Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                this.x = x;
                this.y = y;
                let time = (new Date().getTime()) / 1000;
                this.history.push({ time: time, x: this.x, y: this.y });
                while ((this.history.length > 2) && (time - this.history[0].time > Ui.Pointer.HISTORY_TIMELAPS)) {
                    this.history.shift();
                }
            }
            let watchers = this.watchers.slice();
            for (let i = 0; i < watchers.length; i++) {
                if (this.watchers.indexOf(watchers[i]) != -1)
                    watchers[i].move();
            }
            if (this.captureWatcher === undefined) {
                let target = Ui.Element.elementFromPoint(new Ui.Point(this.x, this.y));
                if (target != undefined) {
                    let pointerEvent = new EmuPointerEvent('ptrmoved', this);
                    pointerEvent.dispatchEvent(target);
                }
            }
            this.ptrmoved.fire({ target: this });
        }
        getIsHold() {
            return (((new Date().getTime()) / 1000) - this.start) >= Ui.Pointer.HOLD_DELAY;
        }
        getDelta() {
            let deltaX = this.x - this.initialX;
            let deltaY = this.y - this.initialY;
            return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        }
        getCumulMove() {
            return this.cumulMove;
        }
        getIsMove() {
            if (this.type == 'mouse' && this.button == 0)
                return this.cumulMove >= Pointer.MOUSE_MOVE_DELTA;
            else
                return this.cumulMove >= Pointer.MOVE_DELTA;
        }
        getPosition(element) {
            let current = new Ui.Point(this.getX(), this.getY());
            return element.pointFromWindow(current);
        }
        getIsInside(element) {
            let pos = this.getPosition(element);
            if ((pos.x >= 0) && (pos.x <= element.layoutWidth) &&
                (pos.y >= 0) && (pos.y <= element.layoutHeight))
                return true;
            return false;
        }
        down(x, y, buttons, button) {
            this.start = (new Date().getTime()) / 1000;
            this.x = x;
            this.initialX = x;
            this.y = y;
            this.initialY = y;
            this.history = [];
            this.history.push({ time: this.start, x: this.initialX, y: this.initialY });
            this.buttons = buttons;
            this.cumulMove = 0;
            this.button = button;
            let watchers = this.watchers.slice();
            for (let i = 0; i < watchers.length; i++)
                watchers[i].down();
            let target = Ui.Element.elementFromPoint(new Ui.Point(this.x, this.y));
            let pointerEvent = new EmuPointerEvent('ptrdowned', this);
            if (target !== undefined)
                pointerEvent.dispatchEvent(target);
            this.ptrdowned.fire({ target: this });
        }
        up() {
            let watchers = this.watchers.slice();
            for (let i = 0; i < watchers.length; i++)
                watchers[i].up();
            if (this.type == 'touch')
                this.watchers = [];
            this.buttons = 0;
            let pointerEvent = new EmuPointerEvent('ptrupped', this);
            if (this.captureWatcher === undefined) {
                let target = Ui.Element.elementFromPoint(new Ui.Point(this.x, this.y));
                if (target != undefined)
                    pointerEvent.dispatchEvent(target);
            }
            this.captureWatcher = undefined;
            this.ptrupped.fire({ target: this });
        }
        cancel() {
            let watchers = this.watchers.slice();
            for (let watcher of watchers)
                watcher.cancel();
            this.captureWatcher = undefined;
            this.ptrcanceled.fire({ target: this });
        }
        watch(element) {
            let watcher = new PointerWatcher(element, this);
            this.watchers.push(watcher);
            return watcher;
        }
        unwatch(watcher) {
            for (let i = 0; i < this.watchers.length; i++) {
                if (this.watchers[i] === watcher) {
                    this.watchers.splice(i, 1);
                    break;
                }
            }
        }
    }
    Pointer.HOLD_DELAY = 0.75;
    Pointer.MOUSE_MOVE_DELTA = 5;
    Pointer.MOVE_DELTA = 15;
    Pointer.HISTORY_TIMELAPS = 0.5;
    Ui.Pointer = Pointer;
    class PointerManager extends Core.Object {
        constructor(app) {
            super();
            this.touches = undefined;
            this.lastUpdate = undefined;
            this.lastTouchX = -1;
            this.lastTouchY = -1;
            this.lastDownTouchX = -1;
            this.lastDownTouchY = -1;
            this.mouse = undefined;
            this.pointers = {};
            this.app = app;
            if ('PointerEvent' in window) {
                window.addEventListener('pointerdown', e => this.onPointerDown(e), { passive: false });
                window.addEventListener('pointermove', e => this.onPointerMove(e), { passive: false });
                window.addEventListener('pointerup', e => this.onPointerUp(e), { passive: false });
                window.addEventListener('pointercancel', e => this.onPointerCancel(e), { passive: false });
            }
            else {
                this.mouse = new Pointer('mouse', 0);
                window.addEventListener('mousedown', e => this.onMouseDown(e));
                window.addEventListener('mousemove', e => this.onMouseMove(e));
                window.addEventListener('mouseup', e => this.onMouseUp(e));
                document.addEventListener('selectstart', e => this.onSelectStart(e));
                window.addEventListener('keydown', (event) => {
                    if ((event.which === 16) || (event.which === 17) || (event.which === 18)) {
                        this.mouse.setControls(event.altKey, event.ctrlKey, event.shiftKey);
                        this.mouse.move(this.mouse.x, this.mouse.y);
                    }
                });
                window.addEventListener('keyup', (event) => {
                    if ((event.which === 16) || (event.which === 17) || (event.which === 18)) {
                        this.mouse.setControls(event.altKey, event.ctrlKey, event.shiftKey);
                        this.mouse.move(this.mouse.x, this.mouse.y);
                    }
                });
                document.body.addEventListener('touchstart', e => this.updateTouches(e), { passive: false, capture: true });
                document.body.addEventListener('touchmove', e => this.updateTouches(e), { passive: false, capture: true });
                document.body.addEventListener('touchend', e => this.updateTouches(e), { passive: false, capture: true });
                document.body.addEventListener('touchcancel', e => this.updateTouches(e), { passive: false, capture: true });
            }
        }
        onSelectStart(event) {
            if (this.mouse && this.mouse.getIsCaptured()) {
                event.preventDefault();
                return;
            }
            let selectable = false;
            let current = event.target;
            while (current != undefined) {
                if (current.selectable === true) {
                    selectable = true;
                    break;
                }
                current = current.parentNode;
            }
            if (!selectable)
                event.preventDefault();
            else if (this.mouse !== undefined)
                this.mouse.capture(undefined);
        }
        onMouseDown(event) {
            let deltaTime = (((new Date().getTime()) / 1000) - this.lastUpdate);
            let deltaX = (this.lastTouchX - event.clientX);
            let deltaY = (this.lastTouchY - event.clientY);
            let deltaPos = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            let downDeltaX = this.lastDownTouchX - event.clientX;
            let downDeltaY = this.lastDownTouchY - event.clientY;
            let downDeltaPos = Math.sqrt(downDeltaX * downDeltaX + downDeltaY * downDeltaY);
            if ((deltaTime < 1) || ((deltaTime < 10) && ((deltaPos < 20) || (downDeltaPos < 20))))
                return;
            let buttons = 0;
            if (event.button === 0)
                buttons |= 1;
            else if (event.button === 1)
                buttons |= 2;
            else if (event.button === 2)
                buttons |= 4;
            this.mouse.setControls(event.altKey, event.ctrlKey, event.shiftKey);
            let oldButtons = this.mouse.getButtons();
            if (oldButtons === 0)
                this.mouse.down(event.clientX, event.clientY, buttons, event.button);
            else
                this.mouse.setButtons(oldButtons | buttons);
        }
        onMouseMove(event) {
            this.mouse.setControls(event.altKey, event.ctrlKey, event.shiftKey);
            let deltaTime = (((new Date().getTime()) / 1000) - this.lastUpdate);
            let deltaX = (this.lastTouchX - event.clientX);
            let deltaY = (this.lastTouchY - event.clientY);
            let deltaPos = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            let downDeltaX = this.lastDownTouchX - event.clientX;
            let downDeltaY = this.lastDownTouchY - event.clientY;
            let downDeltaPos = Math.sqrt(downDeltaX * downDeltaX + downDeltaY * downDeltaY);
            if ((deltaTime < 1) || ((deltaTime < 10) && ((deltaPos < 20) || (downDeltaPos < 20))))
                return;
            this.mouse.move(event.clientX, event.clientY);
        }
        onMouseUp(event) {
            this.mouse.setControls(event.altKey, event.ctrlKey, event.shiftKey);
            let deltaTime = (((new Date().getTime()) / 1000) - this.lastUpdate);
            let deltaX = (this.lastTouchX - event.clientX);
            let deltaY = (this.lastTouchY - event.clientY);
            let deltaPos = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            let downDeltaX = this.lastDownTouchX - event.clientX;
            let downDeltaY = this.lastDownTouchY - event.clientY;
            let downDeltaPos = Math.sqrt(downDeltaX * downDeltaX + downDeltaY * downDeltaY);
            if ((deltaTime < 1) || ((deltaTime < 10) && ((deltaPos < 20) || (downDeltaPos < 20))))
                return;
            this.mouse.move(event.clientX, event.clientY);
            this.mouse.up();
        }
        onWindowLoad() {
            try {
                if (document.body === undefined) {
                    let htmlBody = document.createElement('body');
                    document.body = htmlBody;
                }
            }
            catch (e) { }
        }
        onPointerDown(event) {
            if (!(event.target.tagName == 'INPUT' || event.target.tagName == 'TEXTAREA'))
                event.target.setPointerCapture(event.pointerId);
            if (this.pointers[event.pointerId] === undefined) {
                let type;
                if (event.pointerType === 'pen')
                    type = 'pen';
                else if (event.pointerType === 'mouse')
                    type = 'mouse';
                else
                    type = 'touch';
                let pointer = new Pointer(type, event.pointerId);
                this.pointers[event.pointerId] = pointer;
            }
            this.pointers[event.pointerId].setControls(event.altKey, event.ctrlKey, event.shiftKey);
            this.pointers[event.pointerId].down(event.clientX, event.clientY, event.buttons, event.button);
            if (this.pointers[event.pointerId].getIsCaptured())
                event.preventDefault();
        }
        onPointerMove(event) {
            if (this.pointers[event.pointerId] === undefined) {
                let type;
                if (event.pointerType === 'pen')
                    type = 'pen';
                else if (event.pointerType === 'mouse')
                    type = 'mouse';
                else
                    type = 'touch';
                let pointer = new Pointer(type, event.pointerId);
                this.pointers[event.pointerId] = pointer;
            }
            this.pointers[event.pointerId].setControls(event.altKey, event.ctrlKey, event.shiftKey);
            this.pointers[event.pointerId].move(event.clientX, event.clientY);
            if (this.pointers[event.pointerId].getIsCaptured())
                event.preventDefault();
        }
        onPointerUp(event) {
            event.target.releasePointerCapture(event.pointerId);
            if (this.pointers[event.pointerId] !== undefined) {
                this.pointers[event.pointerId].setControls(event.altKey, event.ctrlKey, event.shiftKey);
                this.pointers[event.pointerId].up();
                if (this.pointers[event.pointerId].getIsCaptured())
                    event.preventDefault();
                if (this.pointers[event.pointerId].getType() == 'touch')
                    delete (this.pointers[event.pointerId]);
            }
        }
        onPointerCancel(event) {
            event.target.releasePointerCapture(event.pointerId);
            if (this.pointers[event.pointerId] !== undefined) {
                this.pointers[event.pointerId].setControls(event.altKey, event.ctrlKey, event.shiftKey);
                this.pointers[event.pointerId].cancel();
                if (this.pointers[event.pointerId].getType() == 'touch')
                    delete (this.pointers[event.pointerId]);
            }
        }
        updateTouches(event) {
            this.lastUpdate = (new Date().getTime()) / 1000;
            let eventTaken = false;
            for (let id in this.pointers) {
                let found = false;
                for (let i = 0; (i < event.touches.length) && !found; i++) {
                    if (parseInt(id) == event.touches[i].identifier) {
                        found = true;
                        this.pointers[id].setControls(event.altKey, event.ctrlKey, event.shiftKey);
                        this.pointers[id].move(event.touches[i].clientX, event.touches[i].clientY);
                        eventTaken = eventTaken || this.pointers[id].getIsCaptured();
                    }
                }
                if (!found) {
                    this.pointers[id].setControls(event.altKey, event.ctrlKey, event.shiftKey);
                    this.pointers[id].up();
                    delete (this.pointers[id]);
                }
            }
            for (let i = 0; i < event.touches.length; i++) {
                this.lastTouchX = event.touches[i].clientX;
                this.lastTouchY = event.touches[i].clientY;
                if (this.pointers[event.touches[i].identifier] == undefined) {
                    let pointer = new Pointer('touch', event.touches[i].identifier);
                    this.pointers[event.touches[i].identifier] = pointer;
                    pointer.setControls(event.altKey, event.ctrlKey, event.shiftKey);
                    pointer.down(event.touches[i].clientX, event.touches[i].clientY, 1, 0);
                    eventTaken = eventTaken || pointer.getIsCaptured();
                }
            }
            if (event.type === 'touchstart') {
                for (let i = 0; i < event.changedTouches.length; i++) {
                    this.lastDownTouchX = event.changedTouches[i].clientX;
                    this.lastDownTouchY = event.changedTouches[i].clientY;
                }
            }
            if (eventTaken) {
                event.preventDefault();
                event.stopPropagation();
            }
        }
    }
    Ui.PointerManager = PointerManager;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class DragEffectIcon extends Ui.DualIcon {
        onStyleChange() {
            let size = this.getStyleProperty('size');
            this.width = size;
            this.height = size;
        }
    }
    DragEffectIcon.style = {
        fill: '#333333',
        stroke: '#ffffff',
        strokeWidth: 4,
        size: 16
    };
    Ui.DragEffectIcon = DragEffectIcon;
    class DragEvent extends Ui.Event {
        constructor() {
            super();
            this.clientX = 0;
            this.clientY = 0;
            this.ctrlKey = false;
            this.altKey = false;
            this.shiftKey = false;
            this.metaKey = false;
            this.dataTransfer = undefined;
            this.effectAllowed = undefined;
            this.deltaX = 0;
            this.deltaY = 0;
        }
        preventDefault() {
        }
    }
    Ui.DragEvent = DragEvent;
    class DragNativeData extends Core.Object {
        constructor(dataTransfer) {
            super();
            this.dataTransfer = undefined;
            this.dataTransfer = dataTransfer;
        }
        getTypes() {
            return this.dataTransfer.dataTransfer.types;
        }
        hasTypes(...args) {
            let types = this.getTypes();
            for (let i = 0; i < types.length; i++) {
                for (let i2 = 0; i2 < args.length; i2++)
                    if (types[i].toLowerCase() === args[i2].toLowerCase())
                        return true;
            }
            return false;
        }
        hasType(type) {
            return this.hasTypes(type);
        }
        hasFiles() {
            return this.hasType('files');
        }
        getFiles() {
            return this.dataTransfer.dataTransfer.files;
        }
        getData(type) {
            return this.dataTransfer.dataTransfer.getData(type);
        }
    }
    Ui.DragNativeData = DragNativeData;
    class DragWatcher extends Core.Object {
        constructor(element, dataTransfer) {
            super();
            this.effectAllowed = undefined;
            this.x = 0;
            this.y = 0;
            this.dropped = new Core.Events();
            this.leaved = new Core.Events();
            this.moved = new Core.Events();
            this.dataTransfer = dataTransfer;
            this.element = element;
        }
        getPosition() {
            return new Ui.Point(this.x, this.y);
        }
        getElement() {
            return this.element;
        }
        getDataTransfer() {
            return this.dataTransfer;
        }
        getEffectAllowed() {
            return this.effectAllowed;
        }
        setEffectAllowed(effect) {
            this.effectAllowed = effect;
        }
        move(x, y) {
            this.x = x;
            this.y = y;
            this.moved.fire({ target: this, x: x, y: y });
        }
        leave() {
            this.leaved.fire({ target: this });
        }
        drop(dropEffect) {
            this.dropped.fire({ target: this, effect: dropEffect, x: this.x, y: this.y });
        }
        release() {
            if (this.dataTransfer)
                this.dataTransfer.releaseDragWatcher(this);
        }
    }
    Ui.DragWatcher = DragWatcher;
    class DragEmuDataTransfer extends Core.Object {
        constructor(draggable, imageElement, x, y, delayed, pointerEvent, touchEvent, mouseEvent) {
            super();
            this.startX = 0;
            this.startY = 0;
            this.dropX = 0;
            this.dropY = 0;
            this.x = 0;
            this.y = 0;
            this.hasStarted = false;
            this.delayed = false;
            this.started = new Core.Events();
            this.ended = new Core.Events();
            this.onKeyUpDown = (e) => {
                this.pointer.ctrlKey = e.ctrlKey;
                this.pointer.altKey = e.altKey;
                this.pointer.shiftKey = e.shiftKey;
                this.pointer.move(this.pointer.x, this.pointer.y);
            };
            this.onPointerMove = (e) => {
                let deltaX;
                let deltaY;
                let delta;
                let dragEvent;
                let ofs;
                let watcher = e.target;
                if (watcher.getIsCaptured()) {
                    let clientX = watcher.pointer.getX();
                    let clientY = watcher.pointer.getY();
                    this.x = clientX;
                    this.y = clientY;
                    document.body.removeChild(this.image);
                    let overElement = Ui.Element.elementFromPoint(new Ui.Point(clientX, clientY));
                    document.body.appendChild(this.image);
                    deltaX = clientX - this.startX;
                    deltaY = clientY - this.startY;
                    ofs = this.delayed ? -10 : 0;
                    this.image.style.left = (this.startImagePoint.x + deltaX + ofs) + 'px';
                    this.image.style.top = (this.startImagePoint.y + deltaY + ofs) + 'px';
                    if (overElement != undefined) {
                        let oldDropEffectIcon = this.dropEffectIcon;
                        let dragEvent = new DragEvent();
                        dragEvent.setType('dragover');
                        dragEvent.clientX = clientX;
                        dragEvent.clientY = clientY;
                        dragEvent.dataTransfer = this;
                        let effectAllowed = [];
                        dragEvent.dispatchEvent(overElement);
                        if (this.dragWatcher !== undefined)
                            effectAllowed = this.dragWatcher.getEffectAllowed();
                        if ((this.dragWatcher !== undefined) && !overElement.getIsChildOf(this.dragWatcher.getElement())) {
                            this.dragWatcher.leave();
                            this.dragWatcher = undefined;
                        }
                        if (this.dragWatcher !== undefined)
                            this.dragWatcher.move(clientX, clientY);
                        this.dropEffect = DragEmuDataTransfer.getMatchingDropEffect(this.effectAllowed, effectAllowed, watcher.pointer.getType(), watcher.pointer.getCtrlKey(), watcher.pointer.getAltKey(), watcher.pointer.getShiftKey());
                        if (this.dropEffect.length > 1)
                            this.dropEffectIcon = 'dragchoose';
                        else if (this.dropEffect.length > 0)
                            this.dropEffectIcon = this.dropEffect[0].dragicon;
                        else
                            this.dropEffectIcon = undefined;
                        if (this.dropEffectIcon !== oldDropEffectIcon) {
                            if (this.imageEffect !== undefined) {
                                this.imageEffect.isLoaded = false;
                                this.image.removeChild(this.imageEffect.drawing);
                                this.imageEffect = undefined;
                            }
                            if (this.dropEffectIcon !== undefined) {
                                this.imageEffect = new DragEffectIcon();
                                this.imageEffect.icon = this.dropEffectIcon;
                                this.imageEffect.parent = Ui.App.current;
                                this.imageEffect.isLoaded = true;
                                this.imageEffect.parentVisible = true;
                                this.imageEffect.style = Ui.App.style;
                                this.imageEffect.setParentDisabled(false);
                                let size = this.imageEffect.measure(0, 0);
                                this.imageEffect.arrange(-size.width + (this.startX - this.startImagePoint.x - ofs), -size.height + (this.startY - this.startImagePoint.y - ofs), size.width, size.height);
                                this.image.appendChild(this.imageEffect.drawing);
                            }
                        }
                        this.overElement = overElement;
                    }
                    else
                        this.overElement = undefined;
                }
                else {
                    if (watcher.pointer.getIsMove()) {
                        if (this.delayed)
                            watcher.cancel();
                        else
                            this.onTimer();
                    }
                }
            };
            this.onPointerUp = (e) => {
                if (this.timer !== undefined) {
                    this.timer.abort();
                    this.timer = undefined;
                }
                let watcher = e.target;
                this.watcher.moved.disconnect(this.onPointerMove);
                this.watcher.upped.disconnect(this.onPointerUp);
                this.watcher.cancelled.disconnect(this.onPointerCancel);
                window.removeEventListener('keydown', this.onKeyUpDown, true);
                window.removeEventListener('keyup', this.onKeyUpDown, true);
                if (!watcher.getIsCaptured())
                    watcher.cancel();
                else {
                    if (this.dragWatcher !== undefined) {
                        this.removeImage();
                        this.dragWatcher.leave();
                        if (this.dropEffect.length === 1) {
                            this.dragWatcher.drop(this.dropEffect[0].action);
                            this.ended.fire({ target: this });
                        }
                        else if (this.dropEffect.length > 1) {
                            let popup = new Ui.Popup();
                            popup.onclosed = () => this.ended.fire({ target: this });
                            let vbox = new Ui.VBox();
                            popup.content = vbox;
                            for (let i = 0; i < this.dropEffect.length; i++) {
                                let button = new Ui.FlatButton();
                                button.text = this.dropEffect[i].text;
                                button['Ui.DragEvent.dropEffect'] = this.dropEffect[i];
                                button.pressed.connect((e) => {
                                    if (this.dragWatcher)
                                        this.dragWatcher.drop(e.target['Ui.DragEvent.dropEffect'].action);
                                    popup.close();
                                });
                                vbox.append(button);
                            }
                            popup.openAt(this.x, this.y);
                        }
                    }
                    else {
                        this.dropX = watcher.pointer.getX();
                        this.dropY = watcher.pointer.getY();
                        this.dropFailsTimer = new Anim.Clock({
                            duration: 0.25, ease: new Anim.PowerEase({ mode: 'out' }),
                            ontimeupdate: e => this.onDropFailsTimerUpdate(e.target, e.progress)
                        });
                        this.dropFailsTimer.begin();
                        this.ended.fire({ target: this });
                    }
                }
            };
            this.onPointerCancel = (e) => {
                if (this.timer !== undefined) {
                    this.timer.abort();
                    this.timer = undefined;
                }
            };
            this.dropEffect = [];
            this.effectAllowed = [];
            this.draggable = draggable;
            this.imageElement = imageElement;
            this.startX = x;
            this.startY = y;
            this.delayed = delayed;
            this.dragDelta = this.draggable.pointFromWindow(new Ui.Point(this.startX, this.startY));
            let onContextMenu = (e) => {
                e.stopImmediatePropagation();
                e.preventDefault();
            };
            if (pointerEvent) {
                if (pointerEvent.type == 'touch')
                    this.draggable.drawing.addEventListener('contextmenu', onContextMenu, { capture: true });
                this.pointer = new Ui.Pointer(pointerEvent.pointerType, pointerEvent.pointerId);
                this.pointer.setInitialPosition(pointerEvent.clientX, pointerEvent.clientY);
                this.pointer.ctrlKey = pointerEvent.ctrlKey;
                this.pointer.altKey = pointerEvent.altKey;
                this.pointer.shiftKey = pointerEvent.shiftKey;
                this.pointer.down(pointerEvent.clientX, pointerEvent.clientY, pointerEvent.buttons, pointerEvent.button);
                let onPointerMove = (e) => {
                    this.pointer.ctrlKey = e.ctrlKey;
                    this.pointer.altKey = e.altKey;
                    this.pointer.shiftKey = e.shiftKey;
                    this.pointer.move(e.clientX, e.clientY);
                };
                let onPointerUp = (e) => {
                    if (this.pointer.getIsCaptured()) {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }
                    this.pointer.ctrlKey = e.ctrlKey;
                    this.pointer.altKey = e.altKey;
                    this.pointer.shiftKey = e.shiftKey;
                    this.pointer.up();
                    window.removeEventListener('pointermove', onPointerMove, { capture: true });
                    window.removeEventListener('pointerup', onPointerUp, { capture: true });
                    window.removeEventListener('pointercancel', onPointerCancel, { capture: true });
                    if (pointerEvent.type == 'touch')
                        this.draggable.drawing.removeEventListener('contextmenu', onContextMenu, { capture: true });
                };
                let onPointerCancel = (e) => {
                    this.pointer.ctrlKey = e.ctrlKey;
                    this.pointer.altKey = e.altKey;
                    this.pointer.shiftKey = e.shiftKey;
                    this.pointer.cancel();
                    window.removeEventListener('pointermove', onPointerMove, { capture: true });
                    window.removeEventListener('pointerup', onPointerUp, { capture: true });
                    window.removeEventListener('pointercancel', onPointerCancel, { capture: true });
                    if (pointerEvent.type == 'touch')
                        this.draggable.drawing.removeEventListener('contextmenu', onContextMenu, { capture: true });
                };
                window.addEventListener('pointermove', onPointerMove, { capture: true, passive: false });
                window.addEventListener('pointerup', onPointerUp, { capture: true, passive: false });
                window.addEventListener('pointercancel', onPointerCancel, { capture: true, passive: false });
            }
            else if (touchEvent) {
                this.draggable.drawing.addEventListener('contextmenu', onContextMenu, { capture: true });
                let touch = touchEvent.targetTouches[0];
                this.pointer = new Ui.Pointer('touch', touch.identifier);
                this.pointer.setInitialPosition(touch.clientX, touch.clientY);
                this.pointer.ctrlKey = touchEvent.ctrlKey;
                this.pointer.altKey = touchEvent.altKey;
                this.pointer.shiftKey = touchEvent.shiftKey;
                this.pointer.down(touch.clientX, touch.clientY, 1, 1);
                let onTouchMove = (e) => {
                    let touch;
                    for (let i = 0; touch == undefined && i < e.touches.length; i++)
                        if (e.touches[i].identifier == this.pointer.id)
                            touch = e.touches[i];
                    if (!touch)
                        return;
                    this.pointer.ctrlKey = e.ctrlKey;
                    this.pointer.altKey = e.altKey;
                    this.pointer.shiftKey = e.shiftKey;
                    this.pointer.move(touch.clientX, touch.clientY);
                    e.stopImmediatePropagation();
                    if (this.pointer.getIsCaptured())
                        e.preventDefault();
                };
                let onTouchEnd = (e) => {
                    this.pointer.ctrlKey = e.ctrlKey;
                    this.pointer.altKey = e.altKey;
                    this.pointer.shiftKey = e.shiftKey;
                    this.pointer.up();
                    window.removeEventListener('touchmove', onTouchMove, { capture: true });
                    window.removeEventListener('touchend', onTouchEnd, { capture: true });
                    window.removeEventListener('touchcancel', onTouchCancel, { capture: true });
                    this.draggable.drawing.removeEventListener('contextmenu', onContextMenu, { capture: true });
                    e.stopImmediatePropagation();
                    if (this.pointer.getIsCaptured())
                        e.preventDefault();
                };
                let onTouchCancel = (e) => {
                    this.pointer.ctrlKey = e.ctrlKey;
                    this.pointer.altKey = e.altKey;
                    this.pointer.shiftKey = e.shiftKey;
                    this.pointer.cancel();
                    window.removeEventListener('touchmove', onTouchMove, { capture: true });
                    window.removeEventListener('touchend', onTouchEnd, { capture: true });
                    window.removeEventListener('touchcancel', onTouchCancel, { capture: true });
                    this.draggable.drawing.removeEventListener('contextmenu', onContextMenu, { capture: true });
                };
                window.addEventListener('touchmove', onTouchMove, { capture: true, passive: false });
                window.addEventListener('touchend', onTouchEnd, { capture: true, passive: false });
                window.addEventListener('touchcancel', onTouchCancel, { capture: true, passive: false });
            }
            else if (mouseEvent) {
                this.pointer = new Ui.Pointer(mouseEvent.type, 0);
                this.pointer.setInitialPosition(mouseEvent.clientX, mouseEvent.clientY);
                this.pointer.ctrlKey = mouseEvent.ctrlKey;
                this.pointer.altKey = mouseEvent.altKey;
                this.pointer.shiftKey = mouseEvent.shiftKey;
                this.pointer.down(mouseEvent.clientX, mouseEvent.clientY, mouseEvent.buttons, mouseEvent.button);
                let onMouseMove = (e) => {
                    this.pointer.ctrlKey = e.ctrlKey;
                    this.pointer.altKey = e.altKey;
                    this.pointer.shiftKey = e.shiftKey;
                    if (e.button == 0)
                        this.pointer.move(e.clientX, e.clientY);
                };
                let onMouseUp = (e) => {
                    this.pointer.ctrlKey = e.ctrlKey;
                    this.pointer.altKey = e.altKey;
                    this.pointer.shiftKey = e.shiftKey;
                    if (e.button == 0) {
                        if (this.pointer.getIsCaptured()) {
                            e.preventDefault();
                            e.stopImmediatePropagation();
                        }
                        this.pointer.up();
                        window.removeEventListener('mousemove', onMouseMove, true);
                        window.removeEventListener('mouseup', onMouseUp, true);
                    }
                };
                window.addEventListener('mousemove', onMouseMove, true);
                window.addEventListener('mouseup', onMouseUp, true);
            }
            this.watcher = this.pointer.watch(Ui.App.current);
            this.watcher.moved.connect(this.onPointerMove);
            this.watcher.upped.connect(this.onPointerUp);
            this.watcher.cancelled.connect(this.onPointerCancel);
            window.addEventListener('keydown', this.onKeyUpDown, true);
            window.addEventListener('keyup', this.onKeyUpDown, true);
            if (this.delayed)
                this.timer = new Core.DelayedTask(0.5, () => this.onTimer());
        }
        setData(data) {
            this._data = data;
        }
        getData() {
            return this._data;
        }
        hasData() {
            return this._data !== undefined;
        }
        getPosition() {
            return new Ui.Point(this.x, this.y);
        }
        getDragDelta() {
            return this.dragDelta;
        }
        generateImage(element) {
            let res;
            let child;
            if (('tagName' in element) && (element.tagName.toUpperCase() == 'IMG')) {
                res = element.cloneNode(false);
                res.oncontextmenu = function (e) { e.preventDefault(); };
            }
            else if (('tagName' in element) && (element.tagName.toUpperCase() == 'CANVAS')) {
                res = document.createElement('img');
                res.oncontextmenu = function (e) { e.preventDefault(); };
                res.style.cssText = element.style.cssText;
                res.setAttribute('src', element.toDataURL('image/png'));
            }
            else if (!Core.Navigator.isFirefox && (element.toDataURL !== undefined)) {
                res = document.createElement('img');
                res.oncontextmenu = function (e) { e.preventDefault(); };
                res.style.cssText = element.style.cssText;
                res.setAttribute('src', element.toDataURL('image/png'));
            }
            else {
                res = element.cloneNode(false);
                if ('style' in res) {
                    res.style.webkitUserSelect = 'none';
                    res.style.webkitUserCallout = 'none';
                }
                for (let i = 0; i < element.childNodes.length; i++) {
                    child = element.childNodes[i];
                    res.appendChild(this.generateImage(child));
                }
            }
            if ('setAttribute' in res)
                res.setAttribute('draggable', false);
            res.onselectstart = function (e) {
                e.preventDefault();
                return false;
            };
            if ('style' in res)
                res.style.touchAction = 'none';
            return res;
        }
        onTimer() {
            this.timer = undefined;
            this.started.fire({ target: this });
            if (this.hasData()) {
                this.hasStarted = true;
                this.image = document.createElement('div');
                this.image.style.touchAction = 'none';
                this.image.style.zIndex = '100000';
                this.image.style.position = 'absolute';
                let generateImage = (el) => {
                    let image = this.generateImage(el.drawing);
                    if ('removeProperty' in image.style)
                        image.style.removeProperty('transform');
                    else if (Core.Navigator.isGecko)
                        image.style.removeProperty('-moz-transform');
                    else if (Core.Navigator.isWebkit)
                        image.style.removeProperty('-webkit-transform');
                    image.style.left = '0px';
                    image.style.top = '0px';
                    image.style.touchAction = 'none';
                    image.oncontextmenu = e => e.preventDefault();
                    return image;
                };
                if (this._data instanceof Ui.Selection) {
                    let sel = this._data;
                    let els = sel.elements;
                    for (let i = Math.max(0, els.length - 6); i < els.length; i++) {
                        let invPos = els.length - (i + 1);
                        let op = 0.1;
                        if (invPos == 0)
                            op = 1;
                        else if (invPos == 1)
                            op = 0.95;
                        else if (invPos == 2)
                            op = 0.7;
                        else if (invPos == 3)
                            op = 0.5;
                        else if (invPos == 4)
                            op = 0.2;
                        let image = generateImage(els[i]);
                        image.style.left = `${invPos * 5}px`;
                        image.style.top = `${invPos * 5}px`;
                        image.style.opacity = op.toString();
                        this.image.appendChild(image);
                    }
                }
                else {
                    let image = generateImage(this.imageElement);
                    this.image.appendChild(image);
                }
                this.image.style.opacity = '0.8';
                let ofs = this.delayed ? -10 : 0;
                this.startImagePoint = this.imageElement.pointToWindow(new Ui.Point());
                this.image.style.left = (this.startImagePoint.x + ofs) + 'px';
                this.image.style.top = (this.startImagePoint.y + ofs) + 'px';
                document.body.appendChild(this.image);
                this.watcher.capture();
                this.scrollControlTimer = new Anim.Clock({
                    duration: 'forever',
                    ontimeupdate: (e) => this.onScrollClockTick(e.target, e.deltaTick)
                });
                this.scrollControlTimer.begin();
                this.watcher.upped.connect(() => {
                    if (this.scrollControlTimer) {
                        this.scrollControlTimer.stop();
                        this.scrollControlTimer = undefined;
                    }
                });
            }
            else {
                this.watcher.cancel();
            }
        }
        capture(element, effect) {
            if ((this.dragWatcher !== undefined) && (this.dragWatcher.getElement() === element))
                throw ('Drag already captured by the given element');
            if (this.dragWatcher !== undefined)
                this.dragWatcher.leave();
            this.dragWatcher = new DragWatcher(element, this);
            this.dragWatcher.setEffectAllowed(effect);
            return this.dragWatcher;
        }
        releaseDragWatcher(dragWatcher) {
            if (this.dragWatcher === dragWatcher) {
                this.dragWatcher.leave();
                this.dragWatcher = undefined;
            }
        }
        onScrollClockTick(clock, delta) {
            let speed = this.watcher.getSpeed();
            let speedVal = Math.sqrt(speed.x * speed.x + speed.y * speed.y);
            if (speedVal < 2 && this.overElement) {
                let div = this.overElement.drawing;
                while (div) {
                    let horizontalAllowed = div.style.overflowX == 'auto' || div.style.overflowX == 'scroll';
                    let verticalAllowed = div.style.overflowY == 'auto' || div.style.overflowY == 'scroll';
                    if (horizontalAllowed || verticalAllowed) {
                        let rect = div.getBoundingClientRect();
                        let x = this.watcher.pointer.getX();
                        let y = this.watcher.pointer.getY();
                        let activeWidth = this.watcher.pointer.type == 'touch' ? 40 : 20;
                        let leftAllowed = horizontalAllowed && (x - rect.left < activeWidth) && (x - rect.left > 0);
                        let rightAllowed = horizontalAllowed && (x - rect.right > -(activeWidth + Ui.NativeScrollableContent.nativeScrollBarWidth)) && (x - rect.right < 0);
                        let topAllowed = verticalAllowed && (y - rect.top < activeWidth) && (y - rect.top > 0);
                        let bottomAllowed = verticalAllowed && (y - rect.bottom > -(activeWidth + Ui.NativeScrollableContent.nativeScrollBarHeight)) && (y - rect.bottom < 0);
                        leftAllowed = leftAllowed && div.scrollLeft > 0;
                        topAllowed = topAllowed && div.scrollTop > 0;
                        bottomAllowed = bottomAllowed && (div.scrollHeight - (div.clientHeight + div.scrollTop) > 0);
                        rightAllowed = rightAllowed && (div.scrollWidth - (div.clientWidth + div.scrollLeft) > 0);
                        delta = delta * 200;
                        if (leftAllowed)
                            div.scrollLeft -= delta;
                        else if (rightAllowed)
                            div.scrollLeft += delta;
                        if (topAllowed)
                            div.scrollTop -= delta;
                        else if (bottomAllowed)
                            div.scrollTop += delta;
                        if (leftAllowed || topAllowed || bottomAllowed || rightAllowed)
                            break;
                    }
                    div = div.parentElement;
                }
            }
        }
        removeImage() {
            document.body.removeChild(this.image);
        }
        onDropFailsTimerUpdate(clock, progress) {
            if (progress >= 1)
                this.removeImage();
            else {
                let deltaX = (this.dropX - this.startX) * (1 - progress);
                let deltaY = (this.dropY - this.startY) * (1 - progress);
                this.image.style.left = (this.startImagePoint.x + deltaX) + 'px';
                this.image.style.top = (this.startImagePoint.y + deltaY) + 'px';
            }
        }
        static getMergedEffectAllowed(effectAllowed1, effectAllowed2) {
            if ((effectAllowed1 === undefined) || (effectAllowed1 === 'all'))
                return effectAllowed2;
            else {
                let effectAllowed = [];
                for (let i = 0; i < effectAllowed1.length; i++) {
                    for (let i2 = 0; i2 < effectAllowed2.length; i2++) {
                        if (effectAllowed1[i] === effectAllowed2[i2].action)
                            effectAllowed.push(effectAllowed2[i2]);
                    }
                }
                return effectAllowed;
            }
        }
        static getMatchingDropEffect(srcEffectAllowed, dstEffectAllowed, pointerType, ctrlKey, altKey, shiftKey) {
            let effectAllowed = DragEmuDataTransfer.getMergedEffectAllowed(srcEffectAllowed, dstEffectAllowed);
            let dropEffect = effectAllowed;
            if (effectAllowed.length > 1) {
                if (pointerType === 'mouse') {
                    if (!altKey) {
                        if (ctrlKey) {
                            for (let i = 0; i < effectAllowed.length; i++) {
                                if (effectAllowed[i].secondary === true)
                                    dropEffect = [effectAllowed[i]];
                            }
                            if ((dropEffect === effectAllowed) && (effectAllowed.length > 1))
                                dropEffect = [effectAllowed[1]];
                        }
                        else {
                            for (let i = 0; i < effectAllowed.length; i++) {
                                if (effectAllowed[i].primary === true)
                                    dropEffect = [effectAllowed[i]];
                            }
                            if (dropEffect === effectAllowed)
                                dropEffect = [effectAllowed[0]];
                        }
                    }
                }
            }
            return dropEffect;
        }
    }
    Ui.DragEmuDataTransfer = DragEmuDataTransfer;
    class DragNativeDataTransfer extends Core.Object {
        constructor() {
            super();
            this.dropEffect = 'none';
            this.nativeData = new DragNativeData(this);
        }
        getPosition() {
            var _a;
            return (_a = this.position) !== null && _a !== void 0 ? _a : new Ui.Point();
        }
        setPosition(position) {
            this.position = position;
        }
        getData() {
            return this.nativeData;
        }
        setDataTransfer(dataTransfer) {
            this.dataTransfer = dataTransfer;
        }
        capture(element, effect) {
            if ((this.dragWatcher !== undefined) && (this.dragWatcher.getElement() === element))
                throw ('Drag already captured by the given element');
            if (this.dragWatcher !== undefined)
                this.dragWatcher.leave();
            this.dragWatcher = new DragWatcher(element, this);
            this.dragWatcher.setEffectAllowed(effect);
            return this.dragWatcher;
        }
        releaseDragWatcher(dragWatcher) {
            if (this.dragWatcher === dragWatcher) {
                this.dragWatcher.leave();
                this.dragWatcher = undefined;
            }
        }
    }
    Ui.DragNativeDataTransfer = DragNativeDataTransfer;
    class DragNativeManager extends Core.Object {
        constructor() {
            super();
            this.nativeTarget = undefined;
            this.dataTransfer = new DragNativeDataTransfer();
            window.addEventListener('dragover', (e) => this.onDragOver(e));
            window.addEventListener('dragenter', (e) => this.onDragEnter(e));
            window.addEventListener('dragleave', (e) => this.onDragLeave(e));
            window.addEventListener('drop', (e) => this.onDrop(e));
        }
        onDragOver(event) {
            this.dataTransfer.setDataTransfer(event.dataTransfer);
            let point = new Ui.Point(event.clientX, event.clientY);
            this.dataTransfer.setPosition(point);
            let overElement = Ui.Element.elementFromPoint(point);
            if (overElement !== undefined) {
                let dragEvent = new DragEvent();
                dragEvent.setType('dragover');
                dragEvent.clientX = event.clientX;
                dragEvent.clientY = event.clientY;
                dragEvent.dataTransfer = this.dataTransfer;
                dragEvent.dispatchEvent(overElement);
                if ((this.dataTransfer.dragWatcher !== undefined) &&
                    !overElement.getIsChildOf(this.dataTransfer.dragWatcher.getElement())) {
                    this.dataTransfer.dragWatcher.leave();
                    this.dataTransfer.dragWatcher = undefined;
                }
            }
            if (this.dataTransfer.dragWatcher !== undefined) {
                let dropEffect = DragEmuDataTransfer.getMergedEffectAllowed(this.nativeToCustom(event.dataTransfer.effectAllowed), this.dataTransfer.dragWatcher.effectAllowed);
                this.dataTransfer.dragWatcher.move(event.clientX, event.clientY);
                event.dataTransfer.dropEffect = this.customToNative(dropEffect);
            }
            else
                event.dataTransfer.dropEffect = 'none';
            event.stopImmediatePropagation();
            event.preventDefault();
            return false;
        }
        onDragEnter(e) {
            this.nativeTarget = e.target;
        }
        onDragLeave(e) {
            if (this.nativeTarget !== e.target)
                return;
            this.nativeTarget = undefined;
            if (this.dataTransfer.dragWatcher !== undefined) {
                this.dataTransfer.dragWatcher.leave();
                this.dataTransfer.dragWatcher = undefined;
            }
        }
        onDrop(event) {
            this.dataTransfer.setDataTransfer(event.dataTransfer);
            if (this.dataTransfer.dragWatcher !== undefined) {
                this.dataTransfer.dragWatcher.leave();
                let dropEffect = DragEmuDataTransfer.getMergedEffectAllowed(this.nativeToCustom(event.dataTransfer.effectAllowed), this.dataTransfer.dragWatcher.effectAllowed);
                event.dataTransfer.dropEffect = this.customToNative(dropEffect);
                if (dropEffect.length > 0)
                    this.dataTransfer.dragWatcher.drop(dropEffect[0].action);
                this.dataTransfer.dragWatcher = undefined;
            }
            event.stopImmediatePropagation();
            event.preventDefault();
        }
        nativeToCustom(effectAllowed) {
            if (effectAllowed === 'copy')
                return ['copy'];
            else if (effectAllowed === 'link')
                return ['link'];
            else if (effectAllowed === 'move')
                return ['move'];
            else if (effectAllowed === 'copyLink')
                return ['copy', 'link'];
            else if (effectAllowed === 'copyMove')
                return ['move', 'copy'];
            else if (effectAllowed === 'linkMove')
                return ['move', 'link'];
            else if (effectAllowed === 'all')
                return ['move', 'copy', 'link'];
            return undefined;
        }
        customToNative(effectAllowed) {
            let containsLink = false;
            let containsCopy = false;
            let containsMove = false;
            for (let i = 0; i < effectAllowed.length; i++) {
                if (effectAllowed[i].action === 'link')
                    containsLink = true;
                else if (effectAllowed[i].action === 'move')
                    containsMove = true;
                else if (effectAllowed[i].action === 'copy')
                    containsCopy = true;
            }
            if (containsLink && containsCopy && containsMove)
                return 'all';
            else if (containsLink && containsCopy)
                return 'copyLink';
            else if (containsLink && containsMove)
                return 'linkMove';
            else if (containsMove && containsCopy)
                return 'copyMove';
            else if (containsLink)
                return 'link';
            else if (containsMove)
                return 'move';
            else if (containsCopy)
                return 'copy';
            else
                return 'none';
        }
    }
    Ui.DragNativeManager = DragNativeManager;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class WheelEvent extends Ui.Event {
        constructor() {
            super();
            this.deltaX = 0;
            this.deltaY = 0;
            this.clientX = 0;
            this.clientY = 0;
            this.ctrlKey = false;
            this.altKey = false;
            this.shiftKey = false;
            this.metaKey = false;
            this.setType('wheelchanged');
        }
        setClientX(clientX) {
            this.clientX = clientX;
        }
        setClientY(clientY) {
            this.clientY = clientY;
        }
        setDeltaX(deltaX) {
            this.deltaX = deltaX;
        }
        setDeltaY(deltaY) {
            this.deltaY = deltaY;
        }
        setCtrlKey(ctrlKey) {
            this.ctrlKey = ctrlKey;
        }
        setAltKey(altKey) {
            this.altKey = altKey;
        }
        setShiftKey(shiftKey) {
            this.shiftKey = shiftKey;
        }
        setMetaKey(metaKey) {
            this.metaKey = metaKey;
        }
    }
    Ui.WheelEvent = WheelEvent;
    class WheelWatcher extends Core.Object {
        constructor(init) {
            super();
            this.element = init.element;
            this.onchanged = init.onchanged;
            this.element.drawing.addEventListener('mousewheel', (e) => this.onMouseWheel(e));
            this.element.drawing.addEventListener('DOMMouseScroll', (e) => this.onMouseWheel(e));
        }
        onMouseWheel(event) {
            let deltaX = 0;
            let deltaY = 0;
            if ((event.wheelDeltaX != undefined) && (event.wheelDeltaY != undefined)) {
                deltaX = -event.wheelDeltaX / 5;
                deltaY = -event.wheelDeltaY / 5;
            }
            else if (event.wheelDelta != undefined)
                deltaY = -event.wheelDelta / 2;
            else if (event.detail != undefined)
                deltaY = event.detail * 20;
            let wheelEvent = new Ui.WheelEvent();
            wheelEvent.setClientX(event.clientX);
            wheelEvent.setClientY(event.clientY);
            wheelEvent.setDeltaX(deltaX);
            wheelEvent.setDeltaY(deltaY);
            wheelEvent.setCtrlKey(event.ctrlKey);
            wheelEvent.setAltKey(event.altKey);
            wheelEvent.setShiftKey(event.shiftKey);
            wheelEvent.setMetaKey(event.metaKey);
            this.onchanged(wheelEvent);
            if (wheelEvent.getIsPropagationStopped())
                event.preventDefault();
        }
    }
    Ui.WheelWatcher = WheelWatcher;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class LBox extends Ui.Container {
        constructor(init) {
            super(init);
            this._paddingTop = 0;
            this._paddingBottom = 0;
            this._paddingLeft = 0;
            this._paddingRight = 0;
            if (init) {
                if (init.padding !== undefined)
                    this.padding = init.padding;
                if (init.paddingTop !== undefined)
                    this.paddingTop = init.paddingTop;
                if (init.paddingBottom !== undefined)
                    this.paddingBottom = init.paddingBottom;
                if (init.paddingLeft !== undefined)
                    this.paddingLeft = init.paddingLeft;
                if (init.paddingRight !== undefined)
                    this.paddingRight = init.paddingRight;
                if (init.content !== undefined)
                    this.content = init.content;
            }
        }
        setContent(content) {
            if ((this.children.length === 1) && (content === this.firstChild))
                return;
            while (this.firstChild != undefined)
                this.removeChild(this.firstChild);
            if (content != undefined) {
                if (content instanceof Array) {
                    let elements = content;
                    for (let i = 0; i < elements.length; i++)
                        this.append(content[i]);
                }
                else
                    this.append(content);
            }
        }
        set content(content) {
            this.setContent(content);
        }
        set padding(padding) {
            this.paddingTop = padding;
            this.paddingBottom = padding;
            this.paddingLeft = padding;
            this.paddingRight = padding;
        }
        get paddingTop() {
            return this._paddingTop;
        }
        set paddingTop(paddingTop) {
            if (this._paddingTop != paddingTop) {
                this._paddingTop = paddingTop;
                this.invalidateMeasure();
            }
        }
        get paddingBottom() {
            return this._paddingBottom;
        }
        set paddingBottom(paddingBottom) {
            if (this._paddingBottom != paddingBottom) {
                this._paddingBottom = paddingBottom;
                this.invalidateMeasure();
            }
        }
        get paddingLeft() {
            return this._paddingLeft;
        }
        set paddingLeft(paddingLeft) {
            if (this._paddingLeft != paddingLeft) {
                this._paddingLeft = paddingLeft;
                this.invalidateMeasure();
            }
        }
        get paddingRight() {
            return this._paddingRight;
        }
        set paddingRight(paddingRight) {
            if (this._paddingRight != paddingRight) {
                this._paddingRight = paddingRight;
                this.invalidateMeasure();
            }
        }
        append(child) {
            this.appendChild(child);
        }
        prepend(child) {
            this.prependChild(child);
        }
        insertBefore(child, beforeChild) {
            this.insertChildBefore(child, beforeChild);
        }
        remove(child) {
            this.removeChild(child);
        }
        measureCore(width, height) {
            let left = this.paddingLeft;
            let right = this.paddingRight;
            let top = this.paddingTop;
            let bottom = this.paddingBottom;
            let constraintWidth = Math.max(width - (left + right), 0);
            let constraintHeight = Math.max(height - (top + bottom), 0);
            let minWidth = 0;
            let minHeight = 0;
            for (let i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                let size = child.measure(constraintWidth, constraintHeight);
                if (size.width > minWidth)
                    minWidth = size.width;
                if (size.height > minHeight)
                    minHeight = size.height;
            }
            minWidth += left + right;
            minHeight += top + bottom;
            return { width: minWidth, height: minHeight };
        }
        arrangeCore(width, height) {
            let left = this.paddingLeft;
            let right = this.paddingRight;
            let top = this.paddingTop;
            let bottom = this.paddingBottom;
            width -= left + right;
            height -= top + bottom;
            for (let i = 0; i < this.children.length; i++)
                this.children[i].arrange(left, top, width, height);
        }
    }
    Ui.LBox = LBox;
    class LPBox extends LBox {
        constructor(init) {
            super(init);
        }
        appendAtLayer(child, layer) {
            if (layer === undefined)
                layer = 1;
            child['Ui.LPBox.layer'] = layer;
            let i = 0;
            for (; (i < this.children.length) && (this.children[i]['Ui.LPBox.layer'] <= layer); i++) { }
            this.insertChildAt(child, i);
        }
        prependAtLayer(child, layer) {
            if (layer === undefined)
                layer = 1;
            child['Ui.LPBox.layer'] = layer;
            let i = 0;
            for (; (i < this.children.length) && (this.children[i]['Ui.LPBox.layer'] < layer); i++) { }
            i = Math.max(0, i);
            this.insertChildAt(child, i);
        }
    }
    Ui.LPBox = LPBox;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Box extends Ui.Container {
        constructor(init) {
            super(init);
            this._paddingTop = 0;
            this._paddingBottom = 0;
            this._paddingLeft = 0;
            this._paddingRight = 0;
            this._uniform = false;
            this._spacing = 0;
            this.star = 0;
            this.vertical = true;
            this.uniformSize = 0;
            if (init) {
                if (init.orientation !== undefined)
                    this.orientation = init.orientation;
                if (init.padding !== undefined)
                    this.padding = init.padding;
                if (init.paddingTop !== undefined)
                    this.paddingTop = init.paddingTop;
                if (init.paddingBottom !== undefined)
                    this.paddingBottom = init.paddingBottom;
                if (init.paddingLeft !== undefined)
                    this.paddingLeft = init.paddingLeft;
                if (init.paddingRight !== undefined)
                    this.paddingRight = init.paddingRight;
                if (init.uniform !== undefined)
                    this.uniform = init.uniform;
                if (init.spacing !== undefined)
                    this.spacing = init.spacing;
                if (init.content !== undefined)
                    this.content = init.content;
            }
        }
        set content(content) {
            while (this.firstChild !== undefined)
                this.removeChild(this.firstChild);
            if (content != undefined) {
                if (content instanceof Ui.Element)
                    this.append(content);
                else {
                    let ar = content;
                    for (let i = 0; i < ar.length; i++)
                        this.append(ar[i]);
                }
            }
        }
        get orientation() {
            if (this.vertical)
                return 'vertical';
            else
                return 'horizontal';
        }
        set orientation(orientation) {
            let vertical = true;
            if (orientation !== 'vertical')
                vertical = false;
            if (this.vertical !== vertical) {
                this.vertical = vertical;
                this.invalidateMeasure();
            }
        }
        set padding(padding) {
            this.paddingTop = padding;
            this.paddingBottom = padding;
            this.paddingLeft = padding;
            this.paddingRight = padding;
        }
        get paddingTop() {
            return this._paddingTop;
        }
        set paddingTop(paddingTop) {
            if (this._paddingTop != paddingTop) {
                this._paddingTop = paddingTop;
                this.invalidateMeasure();
            }
        }
        get paddingBottom() {
            return this._paddingBottom;
        }
        set paddingBottom(paddingBottom) {
            if (this._paddingBottom != paddingBottom) {
                this._paddingBottom = paddingBottom;
                this.invalidateMeasure();
            }
        }
        get paddingLeft() {
            return this._paddingLeft;
        }
        set paddingLeft(paddingLeft) {
            if (this._paddingLeft != paddingLeft) {
                this._paddingLeft = paddingLeft;
                this.invalidateMeasure();
            }
        }
        get paddingRight() {
            return this._paddingRight;
        }
        set paddingRight(paddingRight) {
            if (this._paddingRight != paddingRight) {
                this._paddingRight = paddingRight;
                this.invalidateMeasure();
            }
        }
        get uniform() {
            return this._uniform;
        }
        set uniform(uniform) {
            if (this._uniform != uniform) {
                this._uniform = uniform;
                this.invalidateMeasure();
            }
        }
        get spacing() {
            return this._spacing;
        }
        set spacing(spacing) {
            if (this._spacing != spacing) {
                this._spacing = spacing;
                this.invalidateMeasure();
            }
        }
        append(child, resizable) {
            if (resizable !== undefined)
                child.resizable = resizable === true;
            this.appendChild(child);
        }
        prepend(child, resizable) {
            if (resizable !== undefined)
                child.resizable = resizable === true;
            this.prependChild(child);
        }
        insertAt(child, position, resizable) {
            if (resizable !== undefined)
                child.resizable = resizable === true;
            this.insertChildAt(child, position);
        }
        insertBefore(child, beforeChild) {
            this.insertChildBefore(child, beforeChild);
        }
        moveAt(child, position) {
            this.moveChildAt(child, position);
        }
        remove(child) {
            this.removeChild(child);
        }
        measureUniform(width, height) {
            let constraintSize = this.vertical ? height : width;
            let constraintOpSize = this.vertical ? width : height;
            let countVisible = 0;
            for (let i = 0; i < this.children.length; i++)
                if (!this.children[i].isCollapsed)
                    countVisible++;
            constraintSize -= this._spacing * Math.max(0, countVisible - 1);
            let childConstraintSize = constraintSize / Math.max(1, countVisible);
            let countResizable = 0;
            let uniformSize = 0;
            let minOpSize = 0;
            let loop = true;
            while (loop) {
                for (let i = 0; i < this.children.length; i++) {
                    let child = this.children[i];
                    if (child.isCollapsed) {
                        child.measure(0, 0);
                        continue;
                    }
                    if (child.resizable)
                        countResizable++;
                    let size;
                    if (this.vertical)
                        size = child.measure(constraintOpSize, childConstraintSize);
                    else
                        size = child.measure(childConstraintSize, constraintOpSize);
                    if ((this.vertical ? size.width : size.height) > minOpSize)
                        minOpSize = this.vertical ? size.width : size.height;
                    if ((this.vertical ? size.height : size.width) > uniformSize)
                        uniformSize = this.vertical ? size.height : size.width;
                }
                if ((minOpSize > constraintOpSize) || (uniformSize > childConstraintSize)) {
                    if (uniformSize > childConstraintSize)
                        childConstraintSize = uniformSize;
                    constraintOpSize = minOpSize;
                    minOpSize = 0;
                    uniformSize = 0;
                    countResizable = 0;
                }
                else
                    loop = false;
            }
            this.uniformSize = uniformSize;
            let minSize = this.uniformSize * countVisible;
            minSize += this._spacing * (Math.max(0, countVisible - 1));
            if (this.vertical)
                return { width: minOpSize, height: minSize };
            else
                return { width: minSize, height: minOpSize };
        }
        measureNonUniformVertical(width, height) {
            let i;
            let child;
            let size;
            let constraintWidth = width;
            let constraintHeight = height;
            let countVisible = 0;
            for (i = 0; i < this.children.length; i++)
                if (!this.children[i].isCollapsed)
                    countVisible++;
            constraintHeight -= this._spacing * Math.max(0, countVisible - 1);
            let countResizable;
            let minWidth;
            let minHeight;
            let loop = true;
            let star = 0;
            let resizableMinHeight = 0;
            while (loop) {
                countResizable = 0;
                minWidth = 0;
                minHeight = 0;
                for (i = 0; i < this.children.length; i++) {
                    child = this.children[i];
                    if (child.isCollapsed) {
                        child.measure(0, 0);
                        continue;
                    }
                    if (!child.resizable) {
                        size = child.measure(constraintWidth, 0);
                        if (size.width > minWidth)
                            minWidth = size.width;
                        minHeight += size.height;
                    }
                    else {
                        child.boxStarDone = false;
                        countResizable++;
                    }
                }
                resizableMinHeight = 0;
                if (countResizable > 0) {
                    let remainHeight = constraintHeight - minHeight;
                    let starFound = true;
                    star = remainHeight / countResizable;
                    do {
                        resizableMinHeight = 0;
                        starFound = true;
                        for (i = 0; i < this.children.length; i++) {
                            child = this.children[i];
                            if (child.resizable) {
                                if (!child.boxStarDone) {
                                    size = child.measure(constraintWidth, star);
                                    if (size.width > minWidth)
                                        minWidth = size.width;
                                    if (size.height > star) {
                                        child.boxStarDone = true;
                                        starFound = false;
                                        remainHeight -= size.height;
                                        minHeight += size.height;
                                        countResizable--;
                                        star = remainHeight / countResizable;
                                        break;
                                    }
                                    else
                                        resizableMinHeight += size.height;
                                }
                            }
                        }
                    } while (!starFound);
                }
                if (minWidth > constraintWidth)
                    constraintWidth = minWidth;
                else
                    loop = false;
            }
            minHeight += this._spacing * Math.max(0, countVisible - 1);
            if (countResizable > 0) {
                minHeight += resizableMinHeight;
                this.star = star;
            }
            else
                this.star = 0;
            return { width: minWidth, height: minHeight };
        }
        measureNonUniformHorizontal(width, height) {
            let i;
            let child;
            let size;
            let constraintWidth = width;
            let constraintHeight = height;
            let countVisible = 0;
            for (i = 0; i < this.children.length; i++)
                if (!this.children[i].isCollapsed)
                    countVisible++;
            constraintWidth -= this._spacing * Math.max(0, countVisible - 1);
            let countResizable;
            let minWidth;
            let minHeight;
            let loop = true;
            let star = 0;
            let resizableMinWidth = 0;
            while (loop) {
                countResizable = 0;
                minWidth = 0;
                minHeight = 0;
                for (i = 0; i < this.children.length; i++) {
                    child = this.children[i];
                    if (child.isCollapsed) {
                        child.measure(0, 0);
                        continue;
                    }
                    if (!child.resizable) {
                        size = child.measure(0, constraintHeight);
                        if (size.height > minHeight)
                            minHeight = size.height;
                        minWidth += size.width;
                    }
                    else {
                        child.boxStarDone = false;
                        countResizable++;
                    }
                }
                resizableMinWidth = 0;
                if (countResizable > 0) {
                    let remainWidth = constraintWidth - minWidth;
                    let starFound = true;
                    star = remainWidth / countResizable;
                    do {
                        resizableMinWidth = 0;
                        starFound = true;
                        for (i = 0; i < this.children.length; i++) {
                            child = this.children[i];
                            if (child.resizable) {
                                if (!child.boxStarDone) {
                                    size = child.measure(star, constraintHeight);
                                    if (size.height > minHeight)
                                        minHeight = size.height;
                                    if (size.width > star) {
                                        child.boxStarDone = true;
                                        starFound = false;
                                        remainWidth -= size.width;
                                        minWidth += size.width;
                                        countResizable--;
                                        star = remainWidth / countResizable;
                                        break;
                                    }
                                    else
                                        resizableMinWidth += size.width;
                                }
                            }
                        }
                    } while (!starFound);
                }
                if (minHeight > constraintHeight)
                    constraintHeight = minHeight;
                else
                    loop = false;
            }
            minWidth += this._spacing * Math.max(0, countVisible - 1);
            if (countResizable > 0) {
                minWidth += resizableMinWidth;
                this.star = star;
            }
            else
                this.star = 0;
            return { width: minWidth, height: minHeight };
        }
        measureCore(width, height) {
            return this.measureForOrientation(width, height, this.vertical ? 'vertical' : 'horizontal');
        }
        measureForOrientation(width, height, orientation) {
            let left = this.paddingLeft;
            let right = this.paddingRight;
            let top = this.paddingTop;
            let bottom = this.paddingBottom;
            let constraintWidth = Math.max(0, width - (left + right));
            let constraintHeight = Math.max(0, height - (top + bottom));
            let size;
            this.vertical = orientation == 'vertical';
            if (this._uniform)
                size = this.measureUniform(constraintWidth, constraintHeight);
            else {
                if (this.vertical)
                    size = this.measureNonUniformVertical(constraintWidth, constraintHeight);
                else
                    size = this.measureNonUniformHorizontal(constraintWidth, constraintHeight);
            }
            size.width += left + right;
            size.height += top + bottom;
            return size;
        }
        arrangeCore(width, height) {
            let left = this._paddingLeft;
            let right = this._paddingRight;
            let top = this._paddingTop;
            let bottom = this._paddingBottom;
            width -= left + right;
            height -= top + bottom;
            let offset = this.vertical ? top : left;
            let countResizable = 0;
            let minSize = 0;
            let maxSize = 0;
            let count = this.children.length;
            let countVisible = 0;
            for (let i = 0; i < count; i++) {
                let child = this.children[i];
                let size = this.vertical ? child.measureHeight : child.measureWidth;
                if (!child.isCollapsed)
                    countVisible++;
                if (child.resizable) {
                    countResizable++;
                    child['Ui.Box.StarDone'] = false;
                }
                else
                    minSize += size;
                if (size > maxSize)
                    maxSize = size;
            }
            minSize += Math.max(0, countVisible - 1) * this._spacing;
            let star = 0;
            let uniformSize = 0;
            if (countResizable > 0) {
                if (this._uniform)
                    uniformSize = ((this.vertical ? height : width) - (this._spacing * (countVisible - 1))) / countVisible;
                else {
                    let remainSize = (this.vertical ? height : width) - minSize;
                    let starFound = true;
                    star = remainSize / countResizable;
                    do {
                        starFound = true;
                        for (let i = 0; i < count; i++) {
                            let child = this.children[i];
                            if (child.resizable) {
                                let size = this.vertical ? child.measureHeight : child.measureWidth;
                                if (!child['Ui.Box.StarDone']) {
                                    if (size > star) {
                                        child['Ui.Box.StarDone'] = true;
                                        starFound = false;
                                        remainSize -= size;
                                        minSize += size;
                                        countResizable--;
                                        star = remainSize / countResizable;
                                        break;
                                    }
                                }
                            }
                        }
                    } while (!starFound);
                }
            }
            else {
                if (this._uniform)
                    uniformSize = maxSize;
            }
            let isFirst = true;
            for (let i = 0; i < count; i++) {
                let child = this.children[i];
                if (child.isCollapsed)
                    continue;
                let size = this.vertical ? child.measureHeight : child.measureWidth;
                if (this._uniform) {
                    if (isFirst)
                        isFirst = false;
                    else
                        offset += this._spacing;
                    if (this.vertical)
                        child.arrange(left, offset, width, uniformSize);
                    else
                        child.arrange(offset, top, uniformSize, height);
                    offset += uniformSize;
                }
                else {
                    if (child.resizable && ((this.vertical ? child.measureHeight : child.measureWidth) < star)) {
                        if (isFirst)
                            isFirst = false;
                        else
                            offset += this._spacing;
                        if (this.vertical)
                            child.arrange(left, offset, width, star);
                        else
                            child.arrange(offset, top, star, height);
                        offset += star;
                    }
                    else if (size > 0) {
                        if (isFirst)
                            isFirst = false;
                        else
                            offset += this._spacing;
                        if (this.vertical) {
                            child.arrange(left, offset, width, child.measureHeight);
                            offset += child.measureHeight;
                        }
                        else {
                            child.arrange(offset, top, child.measureWidth, height);
                            offset += child.measureWidth;
                        }
                    }
                }
            }
        }
    }
    Ui.Box = Box;
    class VBox extends Box {
        constructor(init) {
            super(init);
            this.orientation = 'vertical';
        }
    }
    Ui.VBox = VBox;
    class HBox extends Box {
        constructor(init) {
            super(init);
            this.orientation = 'horizontal';
        }
    }
    Ui.HBox = HBox;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class OverWatcher extends Core.Object {
        constructor(init) {
            super();
            this._isOver = false;
            if (init.onentered)
                this.enter = init.onentered;
            if (init.onleaved)
                this.leave = init.onleaved;
            this.element = init.element;
            this.element.drawing.addEventListener('mouseenter', (e) => {
                if (this._isOver || this.element.isDisabled)
                    return;
                this._isOver = true;
                if (this.enter)
                    this.enter(this);
            });
            this.element.drawing.addEventListener('mouseleave', (e) => {
                if (e.target != this.element.drawing || !this._isOver)
                    return;
                this._isOver = false;
                if (this.leave)
                    this.leave(this);
            });
        }
        get isOver() {
            return this._isOver;
        }
    }
    Ui.OverWatcher = OverWatcher;
    class Overable extends Ui.LBox {
        constructor(init) {
            super(init);
            this.entered = new Core.Events();
            this.leaved = new Core.Events();
            this.watcher = new OverWatcher({
                element: this,
                onentered: () => this.entered.fire({ target: this }),
                onleaved: () => this.leaved.fire({ target: this })
            });
            if (init) {
                if (init.onentered)
                    this.entered.connect(init.onentered);
                if (init.onleaved)
                    this.leaved.connect(init.onleaved);
            }
        }
        set onentered(value) { this.entered.connect(value); }
        set onleaved(value) { this.leaved.connect(value); }
        get isOver() {
            return this.watcher.isOver;
        }
    }
    Ui.Overable = Overable;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class FocusInWatcher extends Core.Object {
        constructor(init) {
            super();
            this._isDelayFocusIn = false;
            this._isFocusIn = false;
            if (init.onfocusin)
                this.focusin = init.onfocusin;
            if (init.onfocusout)
                this.focusout = init.onfocusout;
            this.element = init.element;
            this.element.drawing.addEventListener('focusin', () => {
                if (!this.element.isDisabled) {
                    this._isFocusIn = true;
                    this.delayFocus();
                }
            });
            this.element.drawing.addEventListener('focusout', () => {
                this._isFocusIn = false;
                this.delayFocus();
            });
        }
        delayFocus() {
            if (!this.delayTask)
                this.delayTask = new Core.DelayedTask(0, () => this.onDelayFocus());
        }
        onDelayFocus() {
            this.delayTask = undefined;
            if (this._isDelayFocusIn != this._isFocusIn) {
                this._isDelayFocusIn = this._isFocusIn;
                if (this.focusout && !this._isDelayFocusIn)
                    this.focusout(this);
                if (this.focusin && this._isDelayFocusIn)
                    this.focusin(this);
            }
        }
        get isFocusIn() {
            return this._isDelayFocusIn;
        }
    }
    Ui.FocusInWatcher = FocusInWatcher;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class RippleEffect extends Core.Object {
        constructor(element) {
            super();
            this.element = element;
            this.isAnimated = false;
            this.element.drawing.style.overflow = 'hidden';
            this.ripple = document.createElement('div');
            this.ripple.style.transformOrigin = 'center center';
            this.ripple.style.transform = 'scale(0) translate3d(0,0,0)';
            this.ripple.style.position = 'absolute';
            this.ripple.style.display = 'block';
            this.ripple.style.margin = '0';
            this.ripple.style.padding = '0';
            this.ripple.style.borderRadius = '100%';
            this.ripple.style.width = '10px';
            this.ripple.style.height = '10px';
            this.fill = Ui.Color.create('rgba(0,0,0,0.1)');
        }
        async anim(x, y) {
            if (this.isAnimated)
                return;
            this.isAnimated = true;
            if (x == undefined)
                x = this.element.layoutWidth / 2;
            if (y == undefined)
                y = this.element.layoutHeight / 2;
            let upPromise = new Promise((resolve) => this.upResolve = resolve);
            this.element.drawing.appendChild(this.ripple);
            this.ripple.style.transform = 'scale(0) translate3d(0,0,0)';
            await new Promise((resolve) => setTimeout(() => resolve(), 0));
            let scale = 2.5 * Math.ceil(Math.max(this.element.layoutWidth, this.element.layoutHeight) / 10);
            this.ripple.style.left = `${Math.round(x - 5)}px`;
            this.ripple.style.top = `${Math.round(y - 5)}px`;
            this.ripple.style.transition = 'transform 0.5s ease-out, opacity 0.1s';
            this.ripple.style.transform = `scale(${scale}) translate3d(0,0,0)`;
            await new Promise((resolve) => setTimeout(() => resolve(), 500));
            await upPromise;
            this.ripple.style.opacity = '0';
            await new Promise((resolve) => setTimeout(() => resolve(), 100));
            this.ripple.style.transition = '';
            this.ripple.style.opacity = '1';
            this.ripple.style.transform = 'scale(0) translate3d(0,0,0)';
            this.element.drawing.removeChild(this.ripple);
            this.isAnimated = false;
        }
        down(x, y) {
            this.anim(x, y);
        }
        up() {
            if (this.upResolve)
                this.upResolve();
        }
        press(x, y) {
            if (!this.isAnimated) {
                this.down(x, y);
                this.up();
            }
        }
        set fill(fill) {
            this.ripple.style.background = Ui.Color.create(fill).getCssRgba();
        }
        set pressable(pressable) {
            pressable.pressed.connect((e) => {
                if (e.x && e.y) {
                    let p = this.element.pointFromWindow(new Ui.Point(e.x, e.y));
                    this.press(p.x, p.y);
                }
                else
                    this.press();
            });
            pressable.downed.connect((e) => {
                if (e.x && e.y) {
                    let p = this.element.pointFromWindow(new Ui.Point(e.x, e.y));
                    this.down(p.x, p.y);
                }
                else
                    this.down();
            });
            pressable.upped.connect(() => this.up());
        }
    }
    Ui.RippleEffect = RippleEffect;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class PressWatcher extends Core.Object {
        constructor(init) {
            var _a, _b;
            super();
            this._isDown = false;
            this.lastTime = undefined;
            this.lock = false;
            this.allowMiddleButton = false;
            this.element = init.element;
            if (init.onpressed)
                this.press = init.onpressed;
            if (init.ondowned)
                this.down = init.ondowned;
            if (init.onupped)
                this.up = init.onupped;
            if (init.onactivated)
                this.activate = init.onactivated;
            if (init.ondelayedpress)
                this.delayedpress = init.ondelayedpress;
            this.pointerElement = (_a = init.pointerElement) !== null && _a !== void 0 ? _a : this.element;
            this.keyboardElement = (_b = init.keyboardElement) !== null && _b !== void 0 ? _b : this.element;
            if ('PointerEvent' in window)
                this.pointerElement.drawing.addEventListener('pointerdown', (e) => this.onPointerDown(e), { passive: true });
            this.pointerElement.drawing.addEventListener('click', e => {
                if (this.lock || this.element.isDisabled)
                    return;
                e.stopImmediatePropagation();
                this.x = e.clientX;
                this.y = e.clientY;
                this.onPress(e.clientX, e.clientY, e.altKey, e.shiftKey, e.ctrlKey);
            });
            this.keyboardElement.drawing.addEventListener('keydown', (e) => this.onKeyDown(e));
            this.keyboardElement.drawing.addEventListener('keyup', (e) => this.onKeyUp(e));
        }
        get isDown() {
            return this._isDown;
        }
        onPointerDown(event) {
            if (this.lock || this.element.isDisabled || this._isDown)
                return;
            if (event.pointerType == 'touch')
                return;
            if (event.pointerType == 'mouse' && !(event.button == 0 || (this.allowMiddleButton && event.button == 1)))
                return;
            this._pointerId = event.pointerId;
            this._isDown = true;
            this.x = event.clientX;
            this.y = event.clientY;
            let onPointerCancel = (e) => {
                if (e.pointerId != this._pointerId)
                    return;
                window.removeEventListener('pointercancel', onPointerCancel, true);
                window.removeEventListener('pointerup', onPointerUp, true);
                this._pointerId = undefined;
                e.stopPropagation();
                this.onUp();
            };
            let onPointerUp = (e) => {
                if (e.pointerId != this._pointerId)
                    return;
                window.removeEventListener('pointercancel', onPointerCancel, true);
                window.removeEventListener('pointerup', onPointerUp, true);
                this._pointerId = undefined;
                this.x = e.clientX;
                this.y = e.clientY;
                e.stopPropagation();
                this.onUp();
                if (e.pointerType == 'mouse' && event.button == 1 && this.allowMiddleButton)
                    this.onPress(e.clientX, e.clientY, e.altKey, e.shiftKey, e.ctrlKey, true);
            };
            window.addEventListener('pointercancel', onPointerCancel, true);
            window.addEventListener('pointerup', onPointerUp, true);
            event.stopPropagation();
            this.onDown();
        }
        onKeyDown(event) {
            let key = event.which;
            if (!this.lock && !this.element.isDisabled && (key == 13 || key == 32)) {
                event.preventDefault();
                event.stopImmediatePropagation();
                this.x = undefined;
                this.y = undefined;
                this.onDown();
            }
        }
        onKeyUp(event) {
            let key = event.which;
            if (!this.lock && !this.element.isDisabled && this._isDown && (key == 13 || key == 32)) {
                event.preventDefault();
                event.stopImmediatePropagation();
                this.x = undefined;
                this.y = undefined;
                this.onUp();
                this.onPress(undefined, undefined, event.altKey, event.shiftKey, event.ctrlKey);
            }
        }
        onDown() {
            this._isDown = true;
            if (this.down)
                this.down(this);
        }
        onUp() {
            this._isDown = false;
            if (this.up)
                this.up(this);
        }
        onPress(x, y, altKey, shiftKey, ctrlKey, middleButton) {
            this.x = x;
            this.y = y;
            this.altKey = altKey;
            this.shiftKey = shiftKey;
            this.ctrlKey = ctrlKey;
            this.middleButton = middleButton;
            if (this.press)
                this.press(this);
            let currentTime = (new Date().getTime()) / 1000;
            if ((this.lastTime !== undefined) && (currentTime - this.lastTime < 0.30)) {
                this.onActivate(x, y);
                if (this.delayedTimer != undefined) {
                    this.delayedTimer.abort();
                    this.delayedTimer = undefined;
                }
            }
            else {
                this.delayedTimer = new Core.DelayedTask(0.30, () => {
                    this.onDelayedPress(x, y, altKey, shiftKey, ctrlKey, middleButton);
                });
            }
            this.lastTime = currentTime;
        }
        onActivate(x, y) {
            if (this.activate)
                this.activate(this);
        }
        onDelayedPress(x, y, altKey, shiftKey, ctrlKey, middleButton) {
            this.x = x;
            this.y = y;
            this.altKey = altKey;
            this.shiftKey = shiftKey;
            this.ctrlKey = ctrlKey;
            this.middleButton = middleButton;
            if (this.delayedTimer) {
                if (!this.delayedTimer.isDone)
                    this.delayedTimer.abort();
                this.delayedTimer = undefined;
            }
            if (this.delayedpress)
                this.delayedpress(this);
        }
    }
    Ui.PressWatcher = PressWatcher;
    class Pressable extends Ui.Overable {
        constructor(init) {
            super(init);
            this.downed = new Core.Events();
            this.upped = new Core.Events();
            this.pressed = new Core.Events();
            this.activated = new Core.Events();
            this.delayedpress = new Core.Events();
            this.drawing.style.cursor = 'pointer';
            this.focusable = true;
            this.role = 'button';
            this.pressWatcher = new PressWatcher({
                element: this,
                onpressed: (watcher) => this.onPress(watcher.x, watcher.y, watcher.altKey, watcher.shiftKey, watcher.ctrlKey, watcher.middleButton),
                ondowned: (watcher) => this.onDown(watcher.x, watcher.y),
                onupped: (watcher) => this.onUp(watcher.x, watcher.y),
                onactivated: (watcher) => this.onActivate(watcher.x, watcher.y),
                ondelayedpress: (watcher) => this.onDelayedPress(watcher.x, watcher.y, watcher.altKey, watcher.shiftKey, watcher.ctrlKey, watcher.middleButton)
            });
            if (init) {
                if (init.lock !== undefined)
                    this.lock = init.lock;
                if (init.onpressed !== undefined)
                    this.pressed.connect(init.onpressed);
                if (init.ondowned !== undefined)
                    this.downed.connect(init.ondowned);
                if (init.onupped !== undefined)
                    this.upped.connect(init.onupped);
                if (init.onactivated !== undefined)
                    this.activated.connect(init.onactivated);
                if (init.ondelayedpress !== undefined)
                    this.delayedpress.connect(init.ondelayedpress);
                if (init.allowMiddleButton !== undefined)
                    this.allowMiddleButton = init.allowMiddleButton;
            }
        }
        set ondowned(value) { this.downed.connect(value); }
        set onupped(value) { this.upped.connect(value); }
        set onpressed(value) { this.pressed.connect(value); }
        set onactivated(value) { this.activated.connect(value); }
        set ondelayedpress(value) { this.delayedpress.connect(value); }
        set title(title) {
            this.drawing.setAttribute('title', title);
        }
        get title() {
            return this.drawing.getAttribute('title');
        }
        get isDown() {
            return this.pressWatcher.isDown;
        }
        set lock(lock) {
            this.pressWatcher.lock = lock;
            if (lock)
                this.drawing.style.cursor = '';
            else
                this.drawing.style.cursor = 'pointer';
        }
        get lock() {
            return this.pressWatcher.lock;
        }
        set allowMiddleButton(value) {
            this.pressWatcher.allowMiddleButton = value;
        }
        get allowMiddleButton() {
            return this.pressWatcher.allowMiddleButton;
        }
        onDown(x, y) {
            this.downed.fire({ target: this, x: x, y: y });
        }
        onUp(x, y) {
            this.upped.fire({ target: this, x: x, y: y });
        }
        press() {
            if (!this.isDisabled && !this.lock)
                this.onPress();
        }
        onPress(x, y, altKey, shiftKey, ctrlKey, middleButton) {
            this.pressed.fire({ target: this, x: x, y: y, altKey: altKey, shiftKey: shiftKey, ctrlKey: ctrlKey, middleButton: middleButton });
        }
        onActivate(x, y) {
            this.activated.fire({ target: this, x: x, y: y });
        }
        onDelayedPress(x, y, altKey, shiftKey, ctrlKey, middleButton) {
            this.delayedpress.fire({ target: this, x: x, y: y, altKey: altKey, shiftKey: shiftKey, ctrlKey: ctrlKey, middleButton: middleButton });
        }
        onDisable() {
            super.onDisable();
            this.drawing.style.cursor = '';
        }
        onEnable() {
            super.onEnable();
            if (this.lock)
                this.drawing.style.cursor = '';
            else
                this.drawing.style.cursor = 'pointer';
        }
    }
    Ui.Pressable = Pressable;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class DraggableWatcher extends Core.Object {
        constructor(init) {
            super();
            this.allowedMode = 'all';
            this.onDraggablePointerDown = (event) => {
                if (this.element.isDisabled || (this.data === undefined))
                    return;
                if (event.pointerType == 'mouse' && event.button != 0)
                    return;
                if (event.pointerType == 'touch')
                    return;
                event.stopImmediatePropagation();
                let delayed = false;
                let dataTransfer = new Ui.DragEmuDataTransfer(this.element, this.image ? this.image : this.element, event.clientX, event.clientY, delayed, event);
                this.dataTransfer = dataTransfer;
                this._dragDelta = this.element.pointFromWindow(new Ui.Point(event.clientX, event.clientY));
                dataTransfer.started.connect(e => this.onDragStart(dataTransfer));
                dataTransfer.ended.connect(e => this.onDragEnd(dataTransfer));
            };
            this.onDraggableMouseDown = (event) => {
                if (this.element.isDisabled || (this.data === undefined) || event.button != 0)
                    return;
                event.stopImmediatePropagation();
                let delayed = false;
                let dataTransfer = new Ui.DragEmuDataTransfer(this.element, this.image ? this.image : this.element, event.clientX, event.clientY, delayed, undefined, undefined, event);
                this.dataTransfer = dataTransfer;
                this._dragDelta = this.element.pointFromWindow(new Ui.Point(event.clientX, event.clientY));
                dataTransfer.started.connect(e => this.onDragStart(dataTransfer));
                dataTransfer.ended.connect(e => this.onDragEnd(dataTransfer));
            };
            this.onDraggableTouchStart = (event) => {
                if (this.element.isDisabled || (this.data === undefined) || (event.targetTouches.length != 1))
                    return;
                let delayed = true;
                let dataTransfer = new Ui.DragEmuDataTransfer(this.element, this.image ? this.image : this.element, event.targetTouches[0].clientX, event.targetTouches[0].clientY, delayed, undefined, event);
                this.dataTransfer = dataTransfer;
                this._dragDelta = this.element.pointFromWindow(new Ui.Point(event.targetTouches[0].clientX, event.targetTouches[0].clientY));
                dataTransfer.started.connect(e => this.onDragStart(dataTransfer));
                dataTransfer.ended.connect(e => this.onDragEnd(dataTransfer));
            };
            this.element = init.element;
            this.data = init.data;
            if (init.image)
                this.image = init.image;
            if (init.start !== undefined)
                this.start = init.start;
            if (init.end !== undefined)
                this.end = init.end;
            if ('PointerEvent' in window)
                this.element.drawing.addEventListener('pointerdown', this.onDraggablePointerDown, { passive: false });
            if ('TouchEvent' in window)
                this.element.drawing.addEventListener('touchstart', this.onDraggableTouchStart, { passive: false });
            if (!('PointerEvent' in window) && !('TouchEvent' in window))
                this.element.drawing.addEventListener('mousedown', this.onDraggableMouseDown);
        }
        get dragDelta() {
            return this._dragDelta;
        }
        dispose() {
            if ('PointerEvent' in window)
                this.element.drawing.removeEventListener('pointerdown', this.onDraggablePointerDown);
            if ('TouchEvent' in window)
                this.element.drawing.removeEventListener('touchstart', this.onDraggableTouchStart);
            if (!('PointerEvent' in window) && !('TouchEvent' in window))
                this.element.drawing.removeEventListener('mousedown', this.onDraggableMouseDown);
        }
        onDragStart(dataTransfer) {
            let selection = Ui.Selectionable.getParentSelectionHandler(this.element);
            if (selection && (selection.elements.indexOf(this.image) != -1))
                dataTransfer.setData(selection);
            else if (selection && (selection.elements.indexOf(this.element) != -1))
                dataTransfer.setData(selection);
            else
                dataTransfer.setData(this.data);
            dataTransfer.effectAllowed = this.allowedMode;
            if (this.start)
                this.start(this);
        }
        onDragEnd(dataTransfer) {
            let action = 'none';
            if (dataTransfer.dropEffect && dataTransfer.dropEffect.length > 0)
                action = dataTransfer.dropEffect[0].action;
            if (this.end)
                this.end(this, action);
        }
    }
    Ui.DraggableWatcher = DraggableWatcher;
    class Draggable extends Ui.Pressable {
        constructor(init) {
            super(init);
            this.allowedMode = 'all';
            this.dragstarted = new Core.Events();
            this.dragended = new Core.Events();
            this.drawing.oncontextmenu = (e) => e.preventDefault();
            this.draggableWatcher = new DraggableWatcher({
                element: this,
                data: this.draggableData,
                start: (watcher) => {
                    if (watcher.dataTransfer)
                        this.onDragStart(watcher.dataTransfer);
                },
                end: (watcher) => {
                    if (watcher.dataTransfer)
                        this.onDragEnd(watcher.dataTransfer);
                }
            });
            if (init) {
                if (init.ondragstarted)
                    this.dragstarted.connect(init.ondragstarted);
                if (init.ondragended)
                    this.dragended.connect(init.ondragended);
            }
        }
        set ondragstarted(value) { this.dragstarted.connect(value); }
        set ondragended(value) { this.dragended.connect(value); }
        get draggableData() {
            return this.draggableWatcher ? this.draggableWatcher.data : undefined;
        }
        set draggableData(data) {
            this.draggableWatcher.data = data;
        }
        setAllowedMode(allowedMode) {
            this.allowedMode = allowedMode;
        }
        get dragDelta() {
            return this._dragDelta;
        }
        onDragStart(dataTransfer) {
            this.dragstarted.fire({ target: this, dataTransfer: dataTransfer });
        }
        onDragEnd(dataTransfer) {
            this.dragended.fire({ target: this, effect: dataTransfer.dropEffect });
        }
    }
    Ui.Draggable = Draggable;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class SelectionableWatcher extends Core.Object {
        constructor(init) {
            var _a;
            super();
            this._isSelected = false;
            this.element = init.element;
            this.element.focusable = true;
            if (init.selectionActions)
                this.selectionActions = init.selectionActions;
            this.element['Ui.SelectionableWatcher.watcher'] = this;
            if (init.draggableElement)
                this.draggableElement = init.draggableElement;
            if (init.onselected)
                this.select = init.onselected;
            if (init.onunselected)
                this.unselect = init.onunselected;
            new Ui.PressWatcher({
                element: this.element,
                keyboardElement: this.element,
                pointerElement: (_a = init.pressElement) !== null && _a !== void 0 ? _a : this.element,
                ondelayedpress: (w) => this.onDelayedPress(w),
                onactivated: (w) => this.onSelectionableActivate(w)
            });
            if (init.draggable === true)
                this.draggable = init.draggable;
        }
        static getSelectionableWatcher(element) {
            return element['Ui.SelectionableWatcher.watcher'];
        }
        static getIsSelectionableItem(element) {
            return (element instanceof Selectionable) || (SelectionableWatcher.getSelectionableWatcher(element) != undefined);
        }
        get draggableElement() {
            return this._draggableElement;
        }
        set draggableElement(element) {
            this._draggableElement = element;
            if (this.draggableWatcher) {
                this.draggableWatcher.dispose();
                if (element) {
                    this.draggableWatcher = new Ui.DraggableWatcher({
                        element: element,
                        data: this.element,
                        image: this.element,
                        start: (w) => this.onSelectionableDragStart(w),
                        end: (w) => this.onSelectionableDragEnd(w)
                    });
                }
                else {
                    this.draggableWatcher = undefined;
                }
            }
        }
        get draggable() {
            return this.draggableWatcher !== undefined;
        }
        set draggable(value) {
            var _a;
            if (value !== this.draggable) {
                if (value)
                    this.draggableWatcher = new Ui.DraggableWatcher({
                        element: this._draggableElement ? this._draggableElement : this.element,
                        data: this.element,
                        image: this.element,
                        start: (w) => this.onSelectionableDragStart(w),
                        end: (w) => this.onSelectionableDragEnd(w)
                    });
                else {
                    (_a = this.draggableWatcher) === null || _a === void 0 ? void 0 : _a.dispose();
                    this.draggableWatcher = undefined;
                }
            }
        }
        get isSelected() {
            return this._isSelected;
        }
        set isSelected(value) {
            if (this._isSelected != value) {
                let selection = this.getParentSelectionHandler();
                if (selection) {
                    if (value)
                        selection.append(this);
                    else
                        selection.remove(this);
                }
            }
        }
        onSelect(selection) {
            this._isSelected = true;
            this.handler = selection;
            if (this.select)
                this.select(selection);
        }
        onUnselect(selection) {
            this._isSelected = false;
            this.handler = undefined;
            if (this.unselect)
                this.unselect(selection);
        }
        onDelayedPress(watcher) {
            let selection = this.getParentSelectionHandler();
            if (selection) {
                if (watcher.ctrlKey) {
                    if (this.isSelected)
                        selection.remove(this);
                    else
                        selection.append([this]);
                }
                else if (watcher.shiftKey)
                    selection.extend(this);
                else
                    selection.watchers = [this];
            }
        }
        getParentSelectionHandler() {
            return Selectionable.getParentSelectionHandler(this.element);
        }
        onSelectionableDragStart(watcher) {
            let selection = this.getParentSelectionHandler();
            if (selection && (selection.watchers.indexOf(this) == -1))
                selection.watchers = [this];
        }
        onSelectionableDragEnd(watcher) {
            if (this.isSelected) {
                let handler = this.getParentSelectionHandler();
                if (handler !== undefined)
                    handler.clear();
            }
        }
        onSelectionableActivate(watcher) {
            if (this.element.isLoaded) {
                let handler = this.getParentSelectionHandler();
                if (handler !== undefined) {
                    handler.elements = [this.element];
                    if (handler.getDefaultAction() !== undefined)
                        handler.executeDefaultAction();
                    else
                        handler.clear();
                }
            }
        }
    }
    Ui.SelectionableWatcher = SelectionableWatcher;
    class Selectionable extends Ui.LBox {
        constructor(init) {
            super(init);
            this.selected = new Core.Events();
            this.unselected = new Core.Events();
            this.selectionWatcher = new SelectionableWatcher({
                element: this,
                selectionActions: this.getSelectionActions(),
                onselected: (s) => this.onSelect(s),
                onunselected: (s) => this.onUnselect(s)
            });
        }
        set onselected(value) { this.selected.connect(value); }
        set onunselected(value) { this.unselected.connect(value); }
        get isSelected() {
            return this.selectionWatcher.isSelected;
        }
        set isSelected(isSelected) {
            this.selectionWatcher.isSelected = isSelected;
        }
        onSelect(selection) {
            this.selected.fire({ target: this });
        }
        onUnselect(selection) {
            this.unselected.fire({ target: this });
        }
        getSelectionActions() {
            return {};
        }
        getParentSelectionHandler() {
            return Selectionable.getParentSelectionHandler(this);
        }
        static getParentSelectionHandler(element) {
            let parent = element.parent;
            while (parent !== undefined) {
                if ('getSelectionHandler' in parent)
                    return parent.getSelectionHandler();
                parent = parent.parent;
            }
            return undefined;
        }
    }
    Ui.Selectionable = Selectionable;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Selection extends Core.Object {
        constructor() {
            super();
            this._allowMultiple = true;
            this.changed = new Core.Events();
            this.onElementUnload = (e) => {
                let watcher = Ui.SelectionableWatcher.getSelectionableWatcher(e.target);
                if (watcher)
                    this.remove(watcher);
            };
            this._watchers = [];
        }
        set onchanged(value) { this.changed.connect(value); }
        get allowMultiple() {
            return this._allowMultiple;
        }
        set allowMultiple(value) {
            this._allowMultiple = value;
            if (value && this._watchers.length > 1) {
                let last = this._watchers[this._watchers.length - 1];
                this.clear();
                this.internalAppend(last);
            }
        }
        clear() {
            let change = false;
            while (this._watchers.length > 0) {
                if (this.internalRemove(this._watchers[0]))
                    change = true;
            }
            if (change)
                this.changed.fire({ target: this });
        }
        appendRange(start, end) {
            let change = false;
            let res = this.findRangeElements(start, end);
            res.forEach(el => { if (this.internalAppend(el))
                change = true; });
            if (change)
                this.changed.fire({ target: this });
        }
        append(elements) {
            let change = false;
            if (elements instanceof Ui.SelectionableWatcher) {
                if (this.internalAppend(elements))
                    change = true;
            }
            else
                elements.forEach(el => { if (this.internalAppend(el))
                    change = true; });
            if (change)
                this.changed.fire({ target: this });
        }
        extend(end) {
            if (this._watchers.length == 0)
                this.append(end);
            else {
                let focusElement = this._watchers.find(el => el.element.hasFocus);
                if (!focusElement)
                    focusElement = this._watchers[0];
                this.watchers = this.findRangeElements(focusElement, end);
            }
        }
        findRangeElements(start, end) {
            let start_parents = new Array();
            let parent = start.element.parent;
            while (parent) {
                start_parents.push(parent);
                parent = parent.parent;
            }
            let common_parent;
            parent = end.element.parent;
            while (parent && !common_parent) {
                let pos = start_parents.indexOf(parent);
                if (pos != -1)
                    common_parent = parent;
                parent = parent.parent;
            }
            let all = new Array();
            let add_selectionable = (el) => {
                let w = Ui.SelectionableWatcher.getSelectionableWatcher(el);
                if (w)
                    all.push(w);
                else if (el instanceof Ui.Container)
                    el.children.forEach(el2 => add_selectionable(el2));
            };
            if (common_parent)
                add_selectionable(common_parent);
            let start_pos = all.indexOf(start);
            let end_pos = all.indexOf(end);
            let res = new Array();
            for (let i = Math.min(start_pos, end_pos); i <= Math.max(start_pos, end_pos); i++)
                res.push(all[i]);
            return res;
        }
        internalAppend(watcher) {
            if (this._watchers.indexOf(watcher) != -1)
                return false;
            if (!this.allowMultiple)
                this.clear();
            this._watchers.push(watcher);
            watcher.element.unloaded.connect(this.onElementUnload);
            watcher.onSelect(this);
            return true;
        }
        remove(watcher) {
            let change = false;
            if (watcher instanceof Ui.SelectionableWatcher) {
                if (this.internalRemove(watcher))
                    change = true;
            }
            else
                watcher.forEach(w => { if (this.internalRemove(w))
                    change = true; });
            if (change)
                this.changed.fire({ target: this });
        }
        internalRemove(watcher) {
            let foundPos = this._watchers.indexOf(watcher);
            if (foundPos != -1) {
                this._watchers.splice(foundPos, 1);
                watcher.element.unloaded.disconnect(this.onElementUnload);
                watcher.onUnselect(this);
                return true;
            }
            return false;
        }
        get watchers() {
            return this._watchers.slice();
        }
        set watchers(watchers) {
            let removeList = new Array();
            let addList = new Array();
            watchers.forEach(w => {
                if (this._watchers.indexOf(w) == -1)
                    addList.push(w);
            });
            this._watchers.forEach(w => {
                if (watchers.indexOf(w) == -1)
                    removeList.push(w);
            });
            removeList.forEach(el => this.internalRemove(el));
            addList.forEach(el => this.internalAppend(el));
            if (addList.length > 0 || removeList.length > 0)
                this.changed.fire({ target: this });
        }
        get elements() {
            return this._watchers.map(w => w.element);
        }
        set elements(elements) {
            this.watchers = elements.map(el => Ui.SelectionableWatcher.getSelectionableWatcher(el)).filter(w => w != undefined);
        }
        getElementActions(watcher) {
            let actions = watcher.selectionActions ? Core.Util.clone(watcher.selectionActions) : {};
            let current = watcher.element.parent;
            while (current != undefined) {
                if ('getContextActions' in current)
                    actions = current.getContextActions(watcher.element, actions);
                current = current.parent;
            }
            return actions;
        }
        getActions() {
            let actions;
            if (this._watchers.length === 0)
                return {};
            else {
                if (this._watchers.length === 1) {
                    actions = {};
                    let allActions = this.getElementActions(this._watchers[0]);
                    for (let actionName in allActions) {
                        let action = allActions[actionName];
                        if ((!action.testRight || action.testRight(this._watchers[0])) &&
                            (!action.testMultipleRight || action.testMultipleRight(this._watchers)))
                            actions[actionName] = allActions[actionName];
                    }
                    return actions;
                }
                else {
                    actions = {};
                    let allActions = this.getElementActions(this._watchers[0]);
                    for (let actionName in allActions) {
                        let action = allActions[actionName];
                        if (action.multiple === true) {
                            let compat = true;
                            for (let i = 1; compat && (i < this._watchers.length); i++) {
                                let otherCompat = false;
                                let otherActions = this.getElementActions(this._watchers[i]);
                                for (let otherActionKey in otherActions) {
                                    let otherAction = otherActions[otherActionKey];
                                    if ((otherAction.multiple === true) && (otherAction.callback === action.callback)) {
                                        otherCompat = true;
                                        break;
                                    }
                                }
                                compat = compat && otherCompat;
                            }
                            if (compat) {
                                let allowed = true;
                                if (action.testRight) {
                                    for (let i = 0; allowed && (i < this._watchers.length); i++) {
                                        allowed = allowed && action.testRight(this._watchers[i]);
                                    }
                                }
                                if (allowed && action.testMultipleRight) {
                                    allowed = action.testMultipleRight(this._watchers);
                                }
                                if (allowed)
                                    actions[actionName] = allActions[actionName];
                            }
                        }
                    }
                    return actions;
                }
            }
        }
        getDefaultAction() {
            let actions = this.getActions();
            for (let actionName in actions) {
                if (actions[actionName]['default'] === true)
                    return actions[actionName];
            }
            return undefined;
        }
        executeDefaultAction() {
            let action = this.getDefaultAction();
            if (action !== undefined && action.callback) {
                action.callback(this);
                this.clear();
                return true;
            }
            else {
                return false;
            }
        }
        getDeleteAction() {
            let actions = this.getActions();
            if (actions == undefined)
                return undefined;
            else if ('delete' in actions)
                return actions['delete'];
            else if (actions.suppress !== undefined)
                return actions.suppress;
            else
                return undefined;
        }
        executeDeleteAction() {
            let action = this.getDeleteAction();
            if (action !== undefined && action.callback) {
                action.callback(this);
                this.clear();
                return true;
            }
            else {
                return false;
            }
        }
    }
    Ui.Selection = Selection;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class ContextMenuWatcher extends Core.Object {
        constructor(init) {
            super();
            this.lock = false;
            this.onContextMenu = (e) => {
                if (!this.lock && !this.element.isDisabled) {
                    this.onPress(e.clientX, e.clientY, e.altKey, e.shiftKey, e.ctrlKey);
                    e.stopImmediatePropagation();
                    e.preventDefault();
                }
            };
            this.element = init.element;
            if (init.press !== undefined)
                this.press = init.press;
            if (init.lock !== undefined)
                this.lock = init.lock;
            this.element.drawing.addEventListener('contextmenu', this.onContextMenu);
        }
        onPress(x, y, altKey, shiftKey, ctrlKey) {
            this.x = x;
            this.y = y;
            this.altKey = altKey;
            this.shiftKey = shiftKey;
            this.ctrlKey = ctrlKey;
            if (this.press)
                this.press(this);
        }
        dispose() {
            this.element.drawing.removeEventListener('contextmenu', this.onContextMenu);
        }
    }
    Ui.ContextMenuWatcher = ContextMenuWatcher;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Label extends Ui.Element {
        constructor(init) {
            super(init);
            this._text = '';
            this._orientation = 'horizontal';
            this.textMeasureValid = false;
            this.textWidth = 0;
            this.textHeight = 0;
            if (!init || init.verticalAlign == undefined)
                this.verticalAlign = 'center';
            if (!init || init.horizontalAlign == undefined)
                this.horizontalAlign = 'center';
            if (!init || init.selectable == undefined)
                this.selectable = false;
            if (init) {
                if (init.text !== undefined)
                    this.text = init.text;
                if (init.fontSize !== undefined)
                    this.fontSize = init.fontSize;
                if (init.fontFamily !== undefined)
                    this.fontFamily = init.fontFamily;
                if (init.fontWeight !== undefined)
                    this.fontWeight = init.fontWeight;
                if (init.color !== undefined)
                    this.color = init.color;
                if (init.orientation !== undefined)
                    this.orientation = init.orientation;
                if (init.textTransform !== undefined)
                    this.textTransform = init.textTransform;
                if (init.textAlign !== undefined)
                    this.textAlign = init.textAlign;
            }
        }
        get text() {
            return this._text;
        }
        set text(text) {
            if (this._text != text) {
                this._text = text;
                if ('textContent' in this.labelDrawing)
                    this.labelDrawing.textContent = this._text;
                else
                    this.labelDrawing.innerText = this._text;
                this.textMeasureValid = false;
                this.invalidateMeasure();
            }
        }
        set fontSize(fontSize) {
            if (this._fontSize !== fontSize) {
                this._fontSize = fontSize;
                this.labelDrawing.style.fontSize = this.fontSize + 'px';
                this.labelDrawing.style.lineHeight = this.fontSize + 'px';
                this.textMeasureValid = false;
                this.invalidateMeasure();
            }
        }
        get fontSize() {
            if (this._fontSize !== undefined)
                return this._fontSize;
            else
                return this.getStyleProperty('fontSize');
        }
        set fontFamily(fontFamily) {
            if (this._fontFamily !== fontFamily) {
                this._fontFamily = fontFamily;
                this.labelDrawing.style.fontFamily = this.fontFamily;
                this.textMeasureValid = false;
                this.invalidateMeasure();
            }
        }
        get fontFamily() {
            if (this._fontFamily !== undefined)
                return this._fontFamily;
            else
                return this.getStyleProperty('fontFamily');
        }
        set fontWeight(fontWeight) {
            if (this._fontWeight !== fontWeight) {
                this._fontWeight = fontWeight;
                this.labelDrawing.style.fontWeight = this.fontWeight;
                this.textMeasureValid = false;
                this.invalidateMeasure();
            }
        }
        get fontWeight() {
            if (this._fontWeight !== undefined)
                return this._fontWeight;
            else
                return this.getStyleProperty('fontWeight');
        }
        set textTransform(textTransform) {
            if (this._textTransform !== textTransform) {
                this._textTransform = textTransform;
                this.labelDrawing.style.textTransform = this.textTransform;
                this.textMeasureValid = false;
                this.invalidateMeasure();
            }
        }
        get textTransform() {
            if (this._textTransform !== undefined)
                return this._textTransform;
            else
                return this.getStyleProperty('textTransform');
        }
        get textAlign() {
            if (this._textAlign !== undefined)
                return this._textAlign;
            else
                return this.getStyleProperty('textAlign');
        }
        set textAlign(textAlign) {
            if (this._textAlign !== textAlign) {
                this._textAlign = textAlign;
                this.drawing.style.textAlign = this.textAlign;
            }
        }
        set color(color) {
            if (this._color !== color) {
                this._color = Ui.Color.create(color);
                this.labelDrawing.style.color = this.getColor().getCssRgba();
            }
        }
        getColor() {
            if (this._color !== undefined)
                return this._color;
            else
                return Ui.Color.create(this.getStyleProperty('color'));
        }
        get orientation() {
            return this._orientation;
        }
        set orientation(orientation) {
            if (this._orientation != orientation) {
                this._orientation = orientation;
                this.invalidateMeasure();
            }
        }
        onStyleChange() {
            this.labelDrawing.style.fontSize = this.fontSize + 'px';
            this.labelDrawing.style.lineHeight = this.fontSize + 'px';
            this.labelDrawing.style.fontFamily = this.fontFamily;
            this.labelDrawing.style.fontWeight = this.fontWeight;
            this.labelDrawing.style.textTransform = this.textTransform;
            this.labelDrawing.style.textAlign = this.textAlign;
            this.labelDrawing.style.color = this.getColor().getCssRgba();
            this.textMeasureValid = false;
            this.invalidateMeasure();
        }
        renderDrawing() {
            this.labelDrawing = document.createElement('div');
            this.labelDrawing.style.whiteSpace = 'nowrap';
            this.labelDrawing.style.display = 'inline';
            this.labelDrawing.style.position = 'absolute';
            this.labelDrawing.style.left = '0px';
            this.labelDrawing.style.top = '0px';
            return this.labelDrawing;
        }
        invalidateTextMeasure() {
            if (this.textMeasureValid) {
                this.textMeasureValid = false;
                this.invalidateMeasure();
            }
        }
        measureCore(width, height) {
            if (!this.textMeasureValid) {
                this.textMeasureValid = true;
                let text = this._text;
                if (this.textTransform == 'uppercase')
                    text = text.toUpperCase();
                else if (this.textTransform == 'lowercase')
                    text = text.toLowerCase();
                let size = Ui.Label.measureText(text, this.fontSize, this.fontFamily, this.fontWeight);
                this.textWidth = size.width;
                this.textHeight = size.height;
            }
            if (this._orientation === 'vertical')
                return { width: this.textHeight, height: this.textWidth };
            else
                return { width: this.textWidth, height: this.textHeight };
        }
        arrangeCore(width, height) {
            if (this._orientation == 'vertical') {
                let matrix = Ui.Matrix.createTranslate(this.labelDrawing.offsetHeight, 0);
                matrix = matrix.rotate(90);
                this.labelDrawing.style.transform = matrix.toString();
                this.labelDrawing.style.transformOrigin = '0% 0%';
            }
            else {
                this.labelDrawing.style.removeProperty('transform');
            }
        }
        static measureTextCanvas(text, fontSize, fontFamily, fontWeight) {
            if (Ui.Label.measureBox === undefined)
                this.createMeasureCanvas();
            Ui.Label.measureContext.font = 'normal ' + fontWeight + ' ' + fontSize + 'px ' + fontFamily;
            let res = Ui.Label.measureContext.measureText(text);
            res.height = fontSize;
            return res;
        }
        static createMeasureCanvas() {
            let measureWindow = window;
            if (measureWindow.document.body === undefined) {
                let body = measureWindow.document.createElement('body');
                measureWindow.document.body = body;
            }
            Ui.Label.measureBox = measureWindow.document.createElement('canvas');
            Ui.Label.measureBox.style.visibility = 'hidden';
            Ui.Label.measureBox.style.position = 'absolute';
            Ui.Label.measureBox.style.left = '0px';
            Ui.Label.measureBox.style.top = '0px';
            Ui.Label.measureBox.style.outline = 'none';
            Ui.Label.measureBox.setAttribute('width', '10');
            Ui.Label.measureBox.setAttribute('height', '10');
            measureWindow.document.body.appendChild(Ui.Label.measureBox);
            Ui.Label.measureContext = Ui.Label.measureBox.getContext('2d');
        }
        static isFontAvailable(fontFamily, fontWeight) {
            let i;
            if (Ui.Label.measureBox === undefined)
                Ui.Label.createMeasureCanvas();
            let ctx = Ui.Label.measureContext;
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.clearRect(0, 0, 10, 10);
            ctx.textBaseline = 'top';
            ctx.font = 'normal ' + fontWeight + ' 10px ' + fontFamily;
            ctx.fillStyle = 'rgba(255,255,255,1)';
            ctx.fillText('@', 0, 0);
            let wantedImageData = ctx.getImageData(0, 0, 10, 10);
            let empty = true;
            for (i = 0; empty && (i < wantedImageData.data.length); i += 4) {
                if (wantedImageData.data[i + 3] !== 0)
                    empty = false;
            }
            if (empty)
                return false;
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.clearRect(0, 0, 10, 10);
            ctx.fillStyle = 'rgba(255,255,255,1)';
            ctx.font = 'normal ' + fontWeight + ' 10px Sans-Serif';
            ctx.fillText('@', 0, 0);
            let refImageData = ctx.getImageData(0, 0, 10, 10);
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.clearRect(0, 0, 10, 10);
            ctx.fillStyle = 'rgba(255,255,255,1)';
            ctx.font = 'normal ' + fontWeight + ' 10px ' + fontFamily + ',Sans-Serif';
            ctx.fillText('@', 0, 0);
            let imageData = ctx.getImageData(0, 0, 10, 10);
            for (i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i + 3] !== refImageData.data[i + 3])
                    return true;
            }
            return false;
        }
        static measureTextHtml(text, fontSize, fontFamily, fontWeight) {
            if (Ui.Label.measureBox === undefined)
                this.createMeasureHtml();
            Ui.Label.measureBox.style.fontSize = fontSize + 'px';
            Ui.Label.measureBox.style.fontFamily = fontFamily;
            Ui.Label.measureBox.style.fontWeight = fontWeight;
            if ('textContent' in Ui.Label.measureBox)
                Ui.Label.measureBox.textContent = text;
            else
                Ui.Label.measureBox.innerText = text;
            return { width: Ui.Label.measureBox.offsetWidth, height: Ui.Label.measureBox.offsetHeight };
        }
        static createMeasureHtml() {
            let measureWindow = window;
            if (Core.Navigator.isGecko)
                measureWindow = Ui.App.getRootWindow();
            if (measureWindow.document.body === undefined) {
                let body = measureWindow.document.createElement('body');
                measureWindow.document.body = body;
            }
            Ui.Label.measureBox = measureWindow.document.createElement('div');
            Ui.Label.measureBox.style.whiteSpace = 'nowrap';
            Ui.Label.measureBox.style.position = 'absolute';
            Ui.Label.measureBox.style.left = '0px';
            Ui.Label.measureBox.style.top = '0px';
            Ui.Label.measureBox.style.position = 'absolute';
            Ui.Label.measureBox.style.display = 'inline';
            Ui.Label.measureBox.style.visibility = 'hidden';
            measureWindow.document.body.appendChild(Ui.Label.measureBox);
        }
        static measureText(text, fontSize, fontFamily, fontWeight) {
            if ((text === '') || (text === undefined))
                return { width: 0, height: fontSize };
            return Ui.Label.measureTextCanvas(text, fontSize, fontFamily, fontWeight);
        }
    }
    Label.measureBox = undefined;
    Label.measureContext = undefined;
    Label.style = {
        color: Ui.Color.create('#444444'),
        fontSize: 16,
        fontFamily: 'Sans-serif',
        fontWeight: 'normal',
        textTransform: 'none',
        textAlign: 'left'
    };
    Ui.Label = Label;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class MovableBase extends Ui.Container {
        constructor(init) {
            super(init);
            this._moveHorizontal = true;
            this._moveVertical = true;
            this.posX = 0;
            this.posY = 0;
            this.speedX = 0;
            this.speedY = 0;
            this.startPosX = 0;
            this.startPosY = 0;
            this._inertia = false;
            this._isDown = false;
            this._lock = false;
            this.isInMoveEvent = false;
            this.cumulMove = 0;
            this.history = [];
            this.upped = new Core.Events();
            this.downed = new Core.Events();
            this.moved = new Core.Events();
            this.drawing.style.touchAction = 'none';
            if ('PointerEvent' in window)
                this.drawing.addEventListener('pointerdown', (e) => this.onPointerDown(e), { passive: false });
            else if ('TouchEvent' in window)
                this.drawing.addEventListener('touchstart', (e) => this.onTouchStart(e));
            else
                this.drawing.addEventListener('mousedown', (e) => this.onMouseDown(e));
            this.drawing.addEventListener('click', (e) => { e.stopImmediatePropagation(); e.preventDefault(); });
            if (init) {
                if (init.lock !== undefined)
                    this.lock = init.lock;
                if (init.inertia !== undefined)
                    this.inertia = init.inertia;
                if (init.moveHorizontal !== undefined)
                    this.moveHorizontal = init.moveHorizontal;
                if (init.moveVertical !== undefined)
                    this.moveVertical = init.moveVertical;
                if (init.onupped)
                    this.upped.connect(init.onupped);
                if (init.ondowned)
                    this.downed.connect(init.ondowned);
                if (init.onmoved)
                    this.moved.connect(init.onmoved);
            }
        }
        set onupped(value) { this.upped.connect(value); }
        set ondowned(value) { this.downed.connect(value); }
        set onmoved(value) { this.moved.connect(value); }
        set lock(lock) {
            this._lock = lock;
            if (lock)
                this.stopInertia();
        }
        get lock() {
            return this._lock;
        }
        get isDown() {
            return this._isDown;
        }
        get inertia() {
            return this._inertia;
        }
        set inertia(inertiaActive) {
            this._inertia = inertiaActive;
        }
        get moveHorizontal() {
            return this._moveHorizontal;
        }
        set moveHorizontal(moveHorizontal) {
            this._moveHorizontal = moveHorizontal;
            this.updateTouchAction();
        }
        get moveVertical() {
            return this._moveVertical;
        }
        set moveVertical(moveVertical) {
            this._moveVertical = moveVertical;
            this.updateTouchAction();
        }
        updateTouchAction() {
            if (this._moveHorizontal && this._moveVertical)
                this.drawing.style.touchAction = 'none';
            else if (this._moveHorizontal)
                this.drawing.style.touchAction = 'pan-y';
            else if (this._moveVertical)
                this.drawing.style.touchAction = 'pan-x';
            else
                this.drawing.style.touchAction = 'auto';
        }
        getSpeed() {
            if (this.history.length < 2)
                return { x: 0, y: 0 };
            else {
                let measure;
                let i = this.history.length;
                let now = this.history[--i];
                do {
                    measure = this.history[--i];
                } while ((i > 0) && ((now.time - measure.time) < 0.08));
                let deltaTime = now.time - measure.time;
                return {
                    x: (now.x - measure.x) / deltaTime,
                    y: (now.y - measure.y) / deltaTime
                };
            }
        }
        setPosition(x, y, dontSignal = false) {
            if ((x !== undefined) && (this._moveHorizontal)) {
                if (isNaN(x))
                    this.posX = 0;
                else
                    this.posX = x;
            }
            if ((y !== undefined) && (this._moveVertical)) {
                if (isNaN(y))
                    this.posY = 0;
                else
                    this.posY = y;
            }
            if (!this.isInMoveEvent && !dontSignal) {
                this.isInMoveEvent = true;
                this.moved.fire({ target: this });
                this.onMove(this.posX, this.posY);
                this.isInMoveEvent = false;
            }
        }
        get positionX() {
            return this.posX;
        }
        get positionY() {
            return this.posY;
        }
        onMove(x, y) {
        }
        onDown() {
            this.history = [];
            this.cumulMove = 0;
            this._isDown = true;
            this.downed.fire({ target: this });
        }
        onUp(abort) {
            this._isDown = false;
            this.upped.fire({
                target: this, speedX: this.speedX, speedY: this.speedY,
                deltaX: (this.posX - this.startPosX),
                deltaY: (this.posY - this.startPosY),
                cumulMove: this.cumulMove,
                abort: abort
            });
        }
        onTouchStart(event) {
            if (this._isDown || this.isDisabled || this._lock)
                return;
            if (event.targetTouches.length != 1)
                return;
            let initialPosition = new Ui.Point(event.targetTouches[0].clientX, event.targetTouches[0].clientY);
            this._pointerId = event.targetTouches[0].identifier;
            this.stopInertia();
            this.startPosX = this.posX;
            this.startPosY = this.posY;
            this.onDown();
            let onTouchMove = (e) => {
                let touch;
                for (let i = 0; touch == undefined && i < e.touches.length; i++)
                    if (e.touches[i].identifier == this._pointerId)
                        touch = e.touches[i];
                if (!touch)
                    return;
                e.stopPropagation();
                e.preventDefault();
                let initial = this.pointFromWindow(initialPosition);
                let current = this.pointFromWindow(new Ui.Point(touch.clientX, touch.clientY));
                let delta = { x: current.x - initial.x, y: current.y - initial.y };
                let time = (new Date().getTime()) / 1000;
                this.history.push({ time: time, x: this.startPosX + delta.x, y: this.startPosY + delta.y });
                while ((this.history.length > 2) && (time - this.history[0].time > Ui.Pointer.HISTORY_TIMELAPS)) {
                    this.history.shift();
                }
                this.setPosition(this.startPosX + delta.x, this.startPosY + delta.y);
            };
            let onTouchCancel = (e) => {
                this.drawing.removeEventListener('touchmove', onTouchMove);
                this.drawing.removeEventListener('touchend', onTouchEnd);
                this.drawing.removeEventListener('touchcancel', onTouchCancel);
                this._pointerId = undefined;
                this.onUp(true);
            };
            let onTouchEnd = (e) => {
                this.drawing.removeEventListener('touchmove', onTouchMove);
                this.drawing.removeEventListener('touchend', onTouchEnd);
                this.drawing.removeEventListener('touchcancel', onTouchCancel);
                this._pointerId = undefined;
                e.stopPropagation();
                e.preventDefault();
                if (this.history.length > 0) {
                    let time = (new Date().getTime()) / 1000;
                    this.history.push({ time: time, x: this.history[this.history.length - 1].x, y: this.history[this.history.length - 1].y });
                }
                let speed = this.getSpeed();
                this.speedX = speed.x;
                this.speedY = speed.y;
                if (this.inertia)
                    this.startInertia();
                this.onUp(false);
            };
            this.drawing.addEventListener('touchmove', onTouchMove, { passive: false });
            this.drawing.addEventListener('touchend', onTouchEnd, { passive: false });
            this.drawing.addEventListener('touchcancel', onTouchCancel, { passive: false });
        }
        onPointerDown(event) {
            if (this._isDown || this.isDisabled || this._lock)
                return;
            if (event.pointerType == 'mouse' && event.button != 0)
                return;
            let initialPosition = new Ui.Point(event.clientX, event.clientY);
            this.stopInertia();
            this.startPosX = this.posX;
            this.startPosY = this.posY;
            this.onDown();
            this._pointerId = event.pointerId;
            this.drawing.setPointerCapture(event.pointerId);
            let onPointerMove = (e) => {
                if (e.pointerId != this._pointerId)
                    return;
                e.stopImmediatePropagation();
                e.preventDefault();
                let initial = this.pointFromWindow(initialPosition);
                let current = this.pointFromWindow(new Ui.Point(e.clientX, e.clientY));
                let delta = { x: current.x - initial.x, y: current.y - initial.y };
                let time = (new Date().getTime()) / 1000;
                this.history.push({ time: time, x: this.startPosX + delta.x, y: this.startPosY + delta.y });
                while ((this.history.length > 2) && (time - this.history[0].time > Ui.Pointer.HISTORY_TIMELAPS)) {
                    this.history.shift();
                }
                this.setPosition(this.startPosX + delta.x, this.startPosY + delta.y);
            };
            let onPointerCancel = (e) => {
                if (e.pointerId != this._pointerId)
                    return;
                this.drawing.removeEventListener('pointermove', onPointerMove);
                this.drawing.removeEventListener('pointercancel', onPointerCancel);
                this.drawing.removeEventListener('pointerup', onPointerUp);
                this.drawing.releasePointerCapture(event.pointerId);
                this._pointerId = undefined;
                e.stopImmediatePropagation();
                e.preventDefault();
                this.onUp(true);
            };
            let onPointerUp = (e) => {
                if (e.pointerId != this._pointerId)
                    return;
                this.drawing.removeEventListener('pointermove', onPointerMove);
                this.drawing.removeEventListener('pointercancel', onPointerCancel);
                this.drawing.removeEventListener('pointerup', onPointerUp);
                this.drawing.releasePointerCapture(event.pointerId);
                this._pointerId = undefined;
                e.stopImmediatePropagation();
                e.preventDefault();
                let initial = this.pointFromWindow(initialPosition);
                let current = this.pointFromWindow(new Ui.Point(e.clientX, e.clientY));
                let delta = { x: current.x - initial.x, y: current.y - initial.y };
                let time = (new Date().getTime()) / 1000;
                this.history.push({ time: time, x: this.startPosX + delta.x, y: this.startPosY + delta.y });
                let speed = this.getSpeed();
                this.speedX = speed.x;
                this.speedY = speed.y;
                if (this.inertia)
                    this.startInertia();
                this.onUp(false);
                if (Core.Navigator.isFirefox) {
                    let clickProtect = (e) => {
                        if (e.button == 0) {
                            e.preventDefault();
                            e.stopImmediatePropagation();
                        }
                    };
                    window.addEventListener('click', clickProtect, { capture: true });
                    setTimeout(() => {
                        window.removeEventListener('click', clickProtect, { capture: true });
                    }, 10);
                }
            };
            this.drawing.addEventListener('pointermove', onPointerMove);
            this.drawing.addEventListener('pointercancel', onPointerCancel);
            this.drawing.addEventListener('pointerup', onPointerUp);
            event.stopImmediatePropagation();
            event.preventDefault();
        }
        onMouseDown(event) {
            if (this._isDown || this.isDisabled || this._lock || event.button != 0)
                return;
            let initialPosition = new Ui.Point(event.clientX, event.clientY);
            this.stopInertia();
            this.startPosX = this.posX;
            this.startPosY = this.posY;
            this.onDown();
            let onMouseMove = (e) => {
                if (e.button != 0)
                    return;
                e.stopPropagation();
                e.preventDefault();
                let initial = this.pointFromWindow(initialPosition);
                let current = this.pointFromWindow(new Ui.Point(e.clientX, e.clientY));
                let delta = { x: current.x - initial.x, y: current.y - initial.y };
                let time = (new Date().getTime()) / 1000;
                this.history.push({ time: time, x: this.startPosX + delta.x, y: this.startPosY + delta.y });
                while ((this.history.length > 2) && (time - this.history[0].time > Ui.Pointer.HISTORY_TIMELAPS)) {
                    this.history.shift();
                }
                this.setPosition(this.startPosX + delta.x, this.startPosY + delta.y);
            };
            let onMouseUp = (e) => {
                if (e.button != 0)
                    return;
                window.removeEventListener('mousemove', onMouseMove, true);
                window.removeEventListener('mouseup', onMouseUp, true);
                this._pointerId = undefined;
                e.stopPropagation();
                e.preventDefault();
                let initial = this.pointFromWindow(initialPosition);
                let current = this.pointFromWindow(new Ui.Point(e.clientX, e.clientY));
                let delta = { x: current.x - initial.x, y: current.y - initial.y };
                let time = (new Date().getTime()) / 1000;
                this.history.push({ time: time, x: this.startPosX + delta.x, y: this.startPosY + delta.y });
                let speed = this.getSpeed();
                this.speedX = speed.x;
                this.speedY = speed.y;
                if (this.inertia)
                    this.startInertia();
                this.onUp(false);
            };
            window.addEventListener('mousemove', onMouseMove, true);
            window.addEventListener('mouseup', onMouseUp, true);
        }
        startInertia() {
            if (this.inertiaClock == undefined) {
                this.inertiaClock = new Anim.Clock({ duration: 'forever', target: this });
                this.inertiaClock.timeupdate.connect((e) => {
                    if (e.deltaTick === 0)
                        return;
                    let oldPosX = this.posX;
                    let oldPosY = this.posY;
                    let posX = this.posX + (this.speedX * e.deltaTick);
                    let posY = this.posY + (this.speedY * e.deltaTick);
                    this.setPosition(posX, posY);
                    if ((this.posX == oldPosX) && (this.posY == oldPosY)) {
                        this.stopInertia();
                        return;
                    }
                    this.speedX -= this.speedX * e.deltaTick * 3;
                    this.speedY -= this.speedY * e.deltaTick * 3;
                    if (Math.abs(this.speedX) < 0.1)
                        this.speedX = 0;
                    if (Math.abs(this.speedY) < 0.1)
                        this.speedY = 0;
                    if ((this.speedX === 0) && (this.speedY === 0))
                        this.stopInertia();
                });
                this.inertiaClock.begin();
            }
        }
        stopInertia() {
            if (this.inertiaClock !== undefined) {
                this.inertiaClock.stop();
                this.inertiaClock = undefined;
            }
        }
    }
    Ui.MovableBase = MovableBase;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Movable extends Ui.MovableBase {
        constructor(init) {
            super(init);
            this._cursor = 'inherit';
            this.focusable = true;
            this.drawing.style.cursor = this._cursor;
            this.drawing.addEventListener('keydown', (e) => this.onKeyDown(e));
            if (init) {
                if (init.cursor !== undefined)
                    this.cursor = init.cursor;
                if (init.content)
                    this.content = init.content;
            }
        }
        set cursor(cursor) {
            if (this._cursor != cursor && !this.isDisabled) {
                this._cursor = cursor;
                this.drawing.style.cursor = this._cursor;
            }
        }
        onKeyDown(event) {
            if (this.isDisabled)
                return;
            let key = event.which;
            if (((key == 37) || (key == 39)) && this.moveHorizontal) {
                event.preventDefault();
                event.stopPropagation();
                if (key == 37)
                    this.setPosition(this.posX - 10, undefined);
                if (key == 39)
                    this.setPosition(this.posX + 10, undefined);
            }
            if (((key == 38) || (key == 40)) && this.moveVertical) {
                event.preventDefault();
                event.stopPropagation();
                if (key == 38)
                    this.setPosition(undefined, this.posY - 10);
                if (key == 40)
                    this.setPosition(undefined, this.posY + 10);
            }
        }
        onMove(x, y) {
            this.transform = Ui.Matrix.createTranslate(this.posX, this.posY);
        }
        measureCore(width, height) {
            if (this._content)
                return this._content.measure(width, height);
            else
                return { width: 0, height: 0 };
        }
        arrangeCore(width, height) {
            if (this._content)
                this._content.arrange(0, 0, width, height);
        }
        get content() {
            return this._content;
        }
        set content(content) {
            if (this._content)
                this.removeChild(this._content);
            this._content = content;
            if (this._content)
                this.appendChild(this._content);
        }
        onDisable() {
            this.drawing.style.cursor = 'inherit';
        }
        onEnable() {
            this.drawing.style.cursor = this._cursor;
        }
    }
    Ui.Movable = Movable;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class ElementPointerManager extends Core.Object {
        constructor(init) {
            super();
            this.element = init.element;
            this.onptrdowned = init.onptrdowned;
            if ('PointerEvent' in window)
                this.element.drawing.addEventListener('pointerdown', (e) => this.onPointerDown(e), { passive: false });
            else if ('TouchEvent' in window)
                this.element.drawing.addEventListener('touchstart', (e) => this.onTouchStart(e));
            else
                this.element.drawing.addEventListener('mousedown', (e) => this.onMouseDown(e));
        }
        onPointerDown(pointerEvent) {
            let onContextMenu = (e) => {
                e.stopImmediatePropagation();
                e.preventDefault();
            };
            if (pointerEvent.type == 'touch')
                this.element.drawing.addEventListener('contextmenu', onContextMenu, { capture: true });
            let pointer = new Ui.Pointer(pointerEvent.pointerType, pointerEvent.pointerId);
            pointer.setInitialPosition(pointerEvent.clientX, pointerEvent.clientY);
            pointer.ctrlKey = pointerEvent.ctrlKey;
            pointer.altKey = pointerEvent.altKey;
            pointer.shiftKey = pointerEvent.shiftKey;
            pointer.down(pointerEvent.clientX, pointerEvent.clientY, pointerEvent.buttons, pointerEvent.button);
            let onPointerMove = (e) => {
                if (e.pointerId != pointer.id)
                    return;
                pointer.ctrlKey = e.ctrlKey;
                pointer.altKey = e.altKey;
                pointer.shiftKey = e.shiftKey;
                pointer.move(e.clientX, e.clientY);
            };
            let onPointerUp = (e) => {
                if (e.pointerId != pointer.id)
                    return;
                if (pointer.getIsCaptured()) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                }
                pointer.ctrlKey = e.ctrlKey;
                pointer.altKey = e.altKey;
                pointer.shiftKey = e.shiftKey;
                pointer.up();
                window.removeEventListener('pointermove', onPointerMove, { capture: true });
                window.removeEventListener('pointerup', onPointerUp, { capture: true });
                window.removeEventListener('pointercancel', onPointerCancel, { capture: true });
                if (pointerEvent.type == 'touch')
                    this.element.drawing.removeEventListener('contextmenu', onContextMenu, { capture: true });
            };
            let onPointerCancel = (e) => {
                if (e.pointerId != pointer.id)
                    return;
                pointer.ctrlKey = e.ctrlKey;
                pointer.altKey = e.altKey;
                pointer.shiftKey = e.shiftKey;
                pointer.cancel();
                window.removeEventListener('pointermove', onPointerMove, { capture: true });
                window.removeEventListener('pointerup', onPointerUp, { capture: true });
                window.removeEventListener('pointercancel', onPointerCancel, { capture: true });
                if (pointerEvent.type == 'touch')
                    this.element.drawing.removeEventListener('contextmenu', onContextMenu, { capture: true });
            };
            window.addEventListener('pointermove', onPointerMove, { capture: true, passive: false });
            window.addEventListener('pointerup', onPointerUp, { capture: true, passive: false });
            window.addEventListener('pointercancel', onPointerCancel, { capture: true, passive: false });
            let event = new Ui.EmuPointerEvent('ptrdowned', pointer);
            this.onptrdowned(event);
            if (event.getIsPropagationStopped())
                pointerEvent.stopPropagation();
        }
        onTouchStart(touchEvent) {
            let onContextMenu = (e) => {
                e.stopImmediatePropagation();
                e.preventDefault();
            };
            this.element.drawing.addEventListener('contextmenu', onContextMenu, { capture: true });
            let touch = touchEvent.targetTouches[0];
            let pointer = new Ui.Pointer('touch', touch.identifier);
            pointer.setInitialPosition(touch.clientX, touch.clientY);
            pointer.ctrlKey = touchEvent.ctrlKey;
            pointer.altKey = touchEvent.altKey;
            pointer.shiftKey = touchEvent.shiftKey;
            pointer.down(touch.clientX, touch.clientY, 1, 1);
            let onTouchMove = (e) => {
                let touch;
                for (let i = 0; touch == undefined && i < e.touches.length; i++)
                    if (e.touches[i].identifier == pointer.id)
                        touch = e.touches[i];
                if (!touch)
                    return;
                pointer.ctrlKey = e.ctrlKey;
                pointer.altKey = e.altKey;
                pointer.shiftKey = e.shiftKey;
                pointer.move(touch.clientX, touch.clientY);
                e.stopImmediatePropagation();
                if (pointer.getIsCaptured())
                    e.preventDefault();
            };
            let onTouchEnd = (e) => {
                pointer.ctrlKey = e.ctrlKey;
                pointer.altKey = e.altKey;
                pointer.shiftKey = e.shiftKey;
                pointer.up();
                window.removeEventListener('touchmove', onTouchMove, { capture: true });
                window.removeEventListener('touchend', onTouchEnd, { capture: true });
                window.removeEventListener('touchcancel', onTouchCancel, { capture: true });
                this.element.drawing.removeEventListener('contextmenu', onContextMenu, { capture: true });
                e.stopImmediatePropagation();
                if (pointer.getIsCaptured())
                    e.preventDefault();
            };
            let onTouchCancel = (e) => {
                pointer.ctrlKey = e.ctrlKey;
                pointer.altKey = e.altKey;
                pointer.shiftKey = e.shiftKey;
                pointer.cancel();
                window.removeEventListener('touchmove', onTouchMove, { capture: true });
                window.removeEventListener('touchend', onTouchEnd, { capture: true });
                window.removeEventListener('touchcancel', onTouchCancel, { capture: true });
                this.element.drawing.removeEventListener('contextmenu', onContextMenu, { capture: true });
            };
            window.addEventListener('touchmove', onTouchMove, { capture: true, passive: false });
            window.addEventListener('touchend', onTouchEnd, { capture: true, passive: false });
            window.addEventListener('touchcancel', onTouchCancel, { capture: true, passive: false });
            let event = new Ui.EmuPointerEvent('ptrdowned', pointer);
            this.onptrdowned(event);
            if (event.getIsPropagationStopped())
                touchEvent.stopPropagation();
        }
        onMouseDown(mouseEvent) {
            let pointer = new Ui.Pointer(mouseEvent.type, 0);
            pointer.setInitialPosition(mouseEvent.clientX, mouseEvent.clientY);
            pointer.ctrlKey = mouseEvent.ctrlKey;
            pointer.altKey = mouseEvent.altKey;
            pointer.shiftKey = mouseEvent.shiftKey;
            pointer.down(mouseEvent.clientX, mouseEvent.clientY, mouseEvent.buttons, mouseEvent.button);
            let onMouseMove = (e) => {
                pointer.ctrlKey = e.ctrlKey;
                pointer.altKey = e.altKey;
                pointer.shiftKey = e.shiftKey;
                if (e.button == 0)
                    pointer.move(e.clientX, e.clientY);
            };
            let onMouseUp = (e) => {
                pointer.ctrlKey = e.ctrlKey;
                pointer.altKey = e.altKey;
                pointer.shiftKey = e.shiftKey;
                if (e.button == 0) {
                    if (pointer.getIsCaptured()) {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }
                    pointer.up();
                    window.removeEventListener('mousemove', onMouseMove, true);
                    window.removeEventListener('mouseup', onMouseUp, true);
                }
            };
            window.addEventListener('mousemove', onMouseMove, true);
            window.addEventListener('mouseup', onMouseUp, true);
            let event = new Ui.EmuPointerEvent('ptrdowned', pointer);
            this.onptrdowned(event);
            if (event.getIsPropagationStopped())
                mouseEvent.stopPropagation();
        }
    }
    Ui.ElementPointerManager = ElementPointerManager;
    class TransformableWatcher extends Core.Object {
        constructor(init) {
            super();
            this._inertia = false;
            this._isDown = false;
            this.transformLock = false;
            this._angle = 0;
            this._scale = 1;
            this._translateX = 0;
            this._translateY = 0;
            this.startAngle = 0;
            this.startScale = 0;
            this.startTranslateX = 0;
            this.startTranslateY = 0;
            this._allowScale = true;
            this._minScale = 0.1;
            this._maxScale = 10;
            this._allowRotate = true;
            this._allowTranslate = true;
            this._allowLeftMouse = true;
            this.speedX = 0;
            this.speedY = 0;
            this.element = init.element;
            this.element.drawing.style.touchAction = 'none';
            if (init.transform != undefined)
                this.transform = init.transform;
            if (init.inertiastart != undefined)
                this.inertiastart = init.inertiastart;
            if (init.inertiaend != undefined)
                this.inertiaend = init.inertiaend;
            if (init.down != undefined)
                this.down = init.down;
            if (init.up != undefined)
                this.up = init.up;
            if (init.allowLeftMouse != undefined)
                this.allowLeftMouse = init.allowLeftMouse;
            if (init.allowScale != undefined)
                this.allowScale = init.allowScale;
            if (init.minScale != undefined)
                this.minScale = init.minScale;
            if (init.maxScale != undefined)
                this.maxScale = init.maxScale;
            if (init.allowRotate != undefined)
                this.allowRotate = init.allowRotate;
            if (init.allowTranslate != undefined)
                this.allowTranslate = init.allowTranslate;
            if (init.angle != undefined)
                this.angle = init.angle;
            if (init.scale != undefined)
                this.scale = init.scale;
            if (init.translateX != undefined)
                this.translateX = init.translateX;
            if (init.translateY != undefined)
                this.translateY = init.translateY;
            if (init.inertia != undefined)
                this.inertia = init.inertia;
            this.element.setTransformOrigin(0, 0, true);
            new Ui.WheelWatcher({
                element: this.element,
                onchanged: (e) => this.onWheel(e)
            });
            new ElementPointerManager({
                element: this.element,
                onptrdowned: (e) => this.onPointerDown(e)
            });
        }
        set allowLeftMouse(value) {
            this._allowLeftMouse = value;
        }
        set allowScale(allow) {
            this._allowScale = allow;
        }
        set minScale(minScale) {
            this._minScale = minScale;
        }
        set maxScale(maxScale) {
            this._maxScale = maxScale;
        }
        set allowRotate(allow) {
            this._allowRotate = allow;
        }
        set allowTranslate(allow) {
            this._allowTranslate = allow;
        }
        get isDown() {
            return this._isDown;
        }
        get isInertia() {
            return this.inertiaClock !== undefined;
        }
        get angle() {
            return this._angle;
        }
        set angle(angle) {
            this.setContentTransform(undefined, undefined, undefined, angle);
        }
        get scale() {
            return this._scale;
        }
        set scale(scale) {
            this.setContentTransform(undefined, undefined, scale, undefined);
        }
        scaleAt(scale, x, y) {
            if (this._allowScale) {
                if ((this._minScale !== undefined) && (scale < this._minScale))
                    scale = this._minScale;
                if ((this._maxScale !== undefined) && (scale > this._maxScale))
                    scale = this._maxScale;
                let deltaScale = scale / this._scale;
                let pos = new Ui.Point(x, y);
                let origin = new Ui.Point(this.element.layoutX + this.element.layoutWidth * this.element.transformOriginX, this.element.layoutY + this.element.layoutHeight * this.element.transformOriginY);
                let deltaMatrix = Ui.Matrix.createTranslate(pos.x, pos.y).
                    scale(deltaScale, deltaScale).
                    translate(-pos.x, -pos.y).
                    translate(origin.x, origin.y).
                    translate(this._translateX, this._translateY).
                    scale(this._scale, this._scale).
                    rotate(this._angle).
                    translate(-origin.x, -origin.y);
                let newOrigin = origin.multiply(deltaMatrix);
                this.setContentTransform(newOrigin.x - origin.x, newOrigin.y - origin.y, scale, this._angle);
            }
        }
        get translateX() {
            return this._translateX;
        }
        set translateX(translateX) {
            this.setContentTransform(translateX, undefined, undefined, undefined);
        }
        get translateY() {
            return this._translateY;
        }
        set translateY(translateY) {
            this.setContentTransform(undefined, translateY, undefined, undefined);
        }
        buildMatrix(translateX, translateY, scale, angle) {
            if (translateX === undefined)
                translateX = this._translateX;
            if (translateY === undefined)
                translateY = this._translateY;
            if (scale === undefined)
                scale = this._scale;
            if (angle === undefined)
                angle = this._angle;
            return Ui.Matrix.createTranslate(this.element.layoutWidth * this.element.transformOriginX, this.element.layoutHeight * this.element.transformOriginX).
                translate(translateX, translateY).
                scale(scale, scale).
                rotate(angle).
                translate(-this.element.layoutWidth * this.element.transformOriginX, -this.element.layoutHeight * this.element.transformOriginX);
        }
        get matrix() {
            return ((new Ui.Matrix()).
                translate(this._translateX, this._translateY).
                scale(this._scale, this._scale).
                rotate(this._angle));
        }
        getBoundaryBox(matrix) {
            if (matrix === undefined)
                matrix = this.matrix;
            let p1 = (new Ui.Point(0, 0)).multiply(matrix);
            let p2 = (new Ui.Point(this.element.layoutWidth, 0)).multiply(matrix);
            let p3 = (new Ui.Point(this.element.layoutWidth, this.element.layoutHeight)).multiply(matrix);
            let p4 = (new Ui.Point(0, this.element.layoutHeight)).multiply(matrix);
            let minX = Math.min(p1.x, Math.min(p2.x, Math.min(p3.x, p4.x)));
            let minY = Math.min(p1.y, Math.min(p2.y, Math.min(p3.y, p4.y)));
            let maxX = Math.max(p1.x, Math.max(p2.x, Math.max(p3.x, p4.x)));
            let maxY = Math.max(p1.y, Math.max(p2.y, Math.max(p3.y, p4.y)));
            return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        }
        setContentTransform(translateX, translateY, scale, angle) {
            if (translateX === undefined)
                translateX = this._translateX;
            if (translateY === undefined)
                translateY = this._translateY;
            if (scale === undefined)
                scale = this._scale;
            if (angle === undefined)
                angle = this._angle;
            this._translateX = translateX;
            this._translateY = translateY;
            this._scale = scale;
            this._angle = angle;
            if (!this.transformLock) {
                this.transformLock = true;
                let testOnly = !(((this.watcher1 === undefined) || this.watcher1.getIsCaptured()) &&
                    ((this.watcher2 === undefined) || this.watcher2.getIsCaptured()));
                if (this.transform)
                    this.transform(this, testOnly);
                this.transformLock = false;
            }
        }
        get inertia() {
            return this._inertia;
        }
        set inertia(inertiaActive) {
            this._inertia = inertiaActive;
        }
        onDown() {
            this._isDown = true;
            if (this.down)
                this.down(this);
        }
        onUp() {
            this._isDown = false;
            if (this.up)
                this.up(this);
        }
        onPointerDown(event) {
            if (!this._allowLeftMouse && event.pointerType == 'mouse' && event.pointer.button == 0)
                return;
            this.stopInertia();
            if (this.watcher1 === undefined) {
                if (this._allowTranslate)
                    this.onDown();
                let watcher = event.pointer.watch(this);
                this.watcher1 = watcher;
                watcher.moved.connect((e) => this.onPointerMove(e.target));
                watcher.upped.connect((e) => this.onPointerUp(e.target));
                watcher.cancelled.connect((e) => this.onPointerCancel(e.target));
                this.startAngle = this._angle;
                this.startScale = this._scale;
                this.startTranslateX = this._translateX;
                this.startTranslateY = this._translateY;
            }
            else if (this.watcher2 === undefined) {
                if (!this._allowTranslate)
                    this.onDown();
                this.watcher1.pointer.setInitialPosition(this.watcher1.pointer.getX(), this.watcher1.pointer.getY());
                let watcher = event.pointer.watch(this);
                this.watcher2 = watcher;
                watcher.moved.connect((e) => this.onPointerMove(e.target));
                watcher.upped.connect((e) => this.onPointerUp(e.target));
                watcher.cancelled.connect((e) => this.onPointerUp(e.target));
                this.startAngle = this._angle;
                this.startScale = this._scale;
                this.startTranslateX = this._translateX;
                this.startTranslateY = this._translateY;
            }
        }
        onPointerMove(watcher) {
            let pos1;
            let pos2;
            let start1;
            let start2;
            if ((this.watcher1 !== undefined) && (this.watcher2 !== undefined)) {
                if (!this.watcher1.getIsCaptured() && this.watcher1.pointer.getIsMove())
                    this.watcher1.capture();
                if (!this.watcher2.getIsCaptured() && this.watcher2.pointer.getIsMove())
                    this.watcher2.capture();
                pos1 = this.element.parent.pointFromWindow(new Ui.Point(this.watcher1.pointer.getX(), this.watcher1.pointer.getY()));
                pos2 = this.element.parent.pointFromWindow(new Ui.Point(this.watcher2.pointer.getX(), this.watcher2.pointer.getY()));
                start1 = this.element.parent.pointFromWindow(new Ui.Point(this.watcher1.pointer.getInitialX(), this.watcher1.pointer.getInitialY()));
                start2 = this.element.parent.pointFromWindow(new Ui.Point(this.watcher2.pointer.getInitialX(), this.watcher2.pointer.getInitialY()));
                let startVector = { x: start2.x - start1.x, y: start2.y - start1.y };
                let endVector = { x: pos2.x - pos1.x, y: pos2.y - pos1.y };
                startVector.norm = Math.sqrt((startVector.x * startVector.x) + (startVector.y * startVector.y));
                endVector.norm = Math.sqrt((endVector.x * endVector.x) + (endVector.y * endVector.y));
                let scale = endVector.norm / startVector.norm;
                startVector.x /= startVector.norm;
                startVector.y /= startVector.norm;
                endVector.x /= endVector.norm;
                endVector.y /= endVector.norm;
                let divVector = {
                    x: (startVector.x * endVector.x + startVector.y * endVector.y),
                    y: (startVector.y * endVector.x - startVector.x * endVector.y)
                };
                let angle = -(Math.atan2(divVector.y, divVector.x) * 180.0) / Math.PI;
                let deltaMatrix = Ui.Matrix.createTranslate(pos1.x - start1.x, pos1.y - start1.y).translate(start1.x, start1.y);
                if (this._allowScale) {
                    if ((this._minScale !== undefined) || (this._maxScale !== undefined)) {
                        let totalScale = this.startScale * scale;
                        if ((this._minScale !== undefined) && (totalScale < this._minScale))
                            totalScale = this._minScale;
                        if ((this._maxScale !== undefined) && (totalScale > this._maxScale))
                            totalScale = this._maxScale;
                        scale = totalScale / this.startScale;
                    }
                    deltaMatrix = deltaMatrix.scale(scale, scale);
                }
                else
                    scale = 1;
                if (this._allowRotate)
                    deltaMatrix = deltaMatrix.rotate(angle);
                else
                    angle = 0;
                deltaMatrix = deltaMatrix.translate(-start1.x, -start1.y);
                let origin = new Ui.Point(this.element.layoutWidth * this.element.transformOriginX, this.element.layoutHeight * this.element.transformOriginX);
                deltaMatrix = deltaMatrix.translate(origin.x, origin.y).
                    translate(this.startTranslateX, this.startTranslateY).
                    scale(this.startScale, this.startScale).
                    rotate(this.startAngle).
                    translate(-origin.x, -origin.y);
                origin = origin.multiply(deltaMatrix);
                this.setContentTransform(origin.x - this.element.layoutWidth * this.element.transformOriginX, origin.y - this.element.layoutHeight * this.element.transformOriginY, this.startScale * scale, this.startAngle + angle);
            }
            else if ((this.watcher1 !== undefined) && this._allowTranslate) {
                pos1 = this.element.parent.pointFromWindow(new Ui.Point(this.watcher1.pointer.getX(), this.watcher1.pointer.getY()));
                start1 = this.element.parent.pointFromWindow(new Ui.Point(this.watcher1.pointer.getInitialX(), this.watcher1.pointer.getInitialY()));
                let deltaX = pos1.x - start1.x;
                let deltaY = pos1.y - start1.y;
                let delta = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                this.setContentTransform(this.startTranslateX + (pos1.x - start1.x), this.startTranslateY + (pos1.y - start1.y), this.startScale, this.startAngle);
                let takenDeltaX = (this._translateX - this.startTranslateX);
                let takenDeltaY = (this._translateY - this.startTranslateY);
                let takenDelta = Math.sqrt(takenDeltaX * takenDeltaX + takenDeltaY * takenDeltaY);
                let test = 0;
                if (delta > 0)
                    test = (takenDelta / delta);
                if (!this.watcher1.getIsCaptured() && this.watcher1.pointer.getIsMove() && (test > 0.7))
                    this.watcher1.capture();
            }
        }
        onPointerCancel(watcher) {
            this.onPointerUp(watcher);
            this.stopInertia();
            this._angle = this.startAngle;
            this._scale = this.startScale;
            this._translateX = this.startTranslateX;
            this._translateY = this.startTranslateY;
        }
        onPointerUp(watcher) {
            if ((this.watcher1 !== undefined) && (this.watcher1 === watcher)) {
                if (this.watcher2 !== undefined) {
                    this.watcher1.unwatch();
                    this.watcher1 = this.watcher2;
                    delete (this.watcher2);
                    this.watcher1.pointer.setInitialPosition(this.watcher1.pointer.getX(), this.watcher1.pointer.getY());
                    this.startAngle = this._angle;
                    this.startScale = this._scale;
                    this.startTranslateX = this._translateX;
                    this.startTranslateY = this._translateY;
                    if (!this._allowTranslate)
                        this.onUp();
                }
                else {
                    if (this._allowTranslate)
                        this.onUp();
                    let speed = this.watcher1.getSpeed();
                    this.speedX = speed.x;
                    this.speedY = speed.y;
                    this.watcher1.unwatch();
                    delete (this.watcher1);
                    this.startInertia();
                }
            }
            if ((this.watcher2 !== undefined) && (this.watcher2 === watcher)) {
                this.watcher2.unwatch();
                delete (this.watcher2);
                this.watcher1.pointer.setInitialPosition(this.watcher1.pointer.getX(), this.watcher1.pointer.getY());
                this.startAngle = this._angle;
                this.startScale = this._scale;
                this.startTranslateX = this._translateX;
                this.startTranslateY = this._translateY;
                if (!this._allowTranslate)
                    this.onUp();
            }
        }
        onWheel(event) {
            let delta = 0;
            delta = event.deltaX + event.deltaY;
            if (event.altKey) {
                if (this._allowRotate) {
                    let angle = delta / 5;
                    let pos = this.element.parent.pointFromWindow(new Ui.Point(event.clientX, event.clientY));
                    let origin = new Ui.Point(this.element.layoutX + this.element.layoutWidth * this.element.transformOriginX, this.element.layoutY + this.element.layoutHeight * this.element.transformOriginY);
                    let deltaMatrix = Ui.Matrix.createTranslate(pos.x, pos.y).
                        rotate(angle).
                        translate(origin.x, origin.y).
                        translate(-pos.x, -pos.y).
                        translate(this._translateX, this._translateY).
                        scale(this._scale, this._scale).
                        rotate(this._angle).
                        translate(-origin.x, -origin.y);
                    let newOrigin = origin.multiply(deltaMatrix);
                    this.setContentTransform(newOrigin.x - origin.x, newOrigin.y - origin.y, this._scale, this._angle + angle);
                }
            }
            else if (event.ctrlKey) {
                if (this._allowScale) {
                    let scale = Math.pow(2, (Math.log(this._scale) / Math.log(2)) - delta / 60);
                    if ((this._minScale !== undefined) && (scale < this._minScale))
                        scale = this._minScale;
                    if ((this._maxScale !== undefined) && (scale > this._maxScale))
                        scale = this._maxScale;
                    let deltaScale = scale / this._scale;
                    let pos = this.element.parent.pointFromWindow(new Ui.Point(event.clientX, event.clientY));
                    let origin = new Ui.Point(this.element.layoutX + this.element.layoutWidth * this.element.transformOriginX, this.element.layoutY + this.element.layoutHeight * this.element.transformOriginY);
                    let deltaMatrix = Ui.Matrix.createTranslate(pos.x, pos.y).
                        scale(deltaScale, deltaScale).
                        translate(-pos.x, -pos.y).
                        translate(origin.x, origin.y).
                        translate(this._translateX, this._translateY).
                        scale(this._scale, this._scale).
                        rotate(this._angle).
                        translate(-origin.x, -origin.y);
                    let newOrigin = origin.multiply(deltaMatrix);
                    this.setContentTransform(newOrigin.x - origin.x, newOrigin.y - origin.y, scale, this._angle);
                }
            }
            else
                return;
            event.stopPropagation();
        }
        startInertia() {
            if ((this.inertiaClock === undefined) && this.inertia) {
                this.inertiaClock = new Anim.Clock({ duration: 'forever', target: this.element });
                this.inertiaClock.timeupdate.connect((e) => this.onTimeupdate(e.target, e.progress, e.deltaTick));
                this.inertiaClock.begin();
                if (this.inertiastart)
                    this.inertiastart(this);
            }
        }
        onTimeupdate(clock, progress, delta) {
            if (delta === 0)
                return;
            let oldTranslateX = this._translateX;
            let oldTranslateY = this._translateY;
            let translateX = this._translateX + (this.speedX * delta);
            let translateY = this._translateY + (this.speedY * delta);
            this.setContentTransform(translateX, translateY, undefined, undefined);
            if ((this._translateX === oldTranslateX) && (this._translateY === oldTranslateY)) {
                this.stopInertia();
                return;
            }
            this.speedX -= this.speedX * delta * 3;
            this.speedY -= this.speedY * delta * 3;
            if (Math.abs(this.speedX) < 0.1)
                this.speedX = 0;
            if (Math.abs(this.speedY) < 0.1)
                this.speedY = 0;
            if ((this.speedX === 0) && (this.speedY === 0))
                this.stopInertia();
        }
        stopInertia() {
            if (this.inertiaClock !== undefined) {
                this.inertiaClock.stop();
                delete (this.inertiaClock);
                this.setContentTransform(Math.round(this._translateX), Math.round(this._translateY), undefined, undefined);
                if (this.inertiaend)
                    this.inertiaend(this);
            }
        }
    }
    Ui.TransformableWatcher = TransformableWatcher;
    class Transformable extends Ui.LBox {
        constructor(init) {
            super();
            this._inertia = false;
            this._isDown = false;
            this.transformLock = false;
            this._angle = 0;
            this._scale = 1;
            this._translateX = 0;
            this._translateY = 0;
            this.startAngle = 0;
            this.startScale = 0;
            this.startTranslateX = 0;
            this.startTranslateY = 0;
            this._allowScale = true;
            this._minScale = 0.1;
            this._maxScale = 10;
            this._allowRotate = true;
            this._allowTranslate = true;
            this._allowLeftMouse = true;
            this.speedX = 0;
            this.speedY = 0;
            this.downed = new Core.Events();
            this.upped = new Core.Events();
            this.transformed = new Core.Events();
            this.inertiastarted = new Core.Events();
            this.inertiaended = new Core.Events();
            this.focusable = true;
            this.drawing.style.touchAction = 'none';
            this.contentBox = new Ui.LBox();
            this.contentBox.setTransformOrigin(0, 0, true);
            this.appendChild(this.contentBox);
            new ElementPointerManager({
                element: this,
                onptrdowned: (e) => this.onPointerDown(e)
            });
            new Ui.WheelWatcher({
                element: this,
                onchanged: (e) => this.onWheel(e)
            });
            if (init) {
                if (init.inertia !== undefined)
                    this.inertia = init.inertia;
                if (init.allowLeftMouse !== undefined)
                    this.allowLeftMouse = init.allowLeftMouse;
                if (init.allowScale !== undefined)
                    this.allowScale = init.allowScale;
                if (init.minScale !== undefined)
                    this.minScale = init.minScale;
                if (init.maxScale !== undefined)
                    this.maxScale = init.maxScale;
                if (init.allowRotate !== undefined)
                    this.allowRotate = init.allowRotate;
                if (init.allowTranslate !== undefined)
                    this.allowTranslate = init.allowTranslate;
                if (init.angle !== undefined)
                    this.angle = init.angle;
                if (init.scale !== undefined)
                    this.scale = init.scale;
                if (init.translateX !== undefined)
                    this.translateX = init.translateX;
                if (init.translateY !== undefined)
                    this.translateY = init.translateY;
                if (init.content !== undefined)
                    this.content = init.content;
                if (init.ondowned)
                    this.downed.connect(init.ondowned);
                if (init.onupped)
                    this.upped.connect(init.onupped);
                if (init.ontransformed)
                    this.transformed.connect(init.ontransformed);
                if (init.oninertiastarted)
                    this.inertiastarted.connect(init.oninertiastarted);
                if (init.oninertiaended)
                    this.inertiaended.connect(init.oninertiaended);
            }
        }
        set ondowned(value) { this.downed.connect(value); }
        set onupped(value) { this.upped.connect(value); }
        set ontransformed(value) { this.transformed.connect(value); }
        set oninertiastarted(value) { this.inertiastarted.connect(value); }
        set oninertiaended(value) { this.inertiaended.connect(value); }
        set allowLeftMouse(value) {
            this._allowLeftMouse = value;
        }
        set allowScale(allow) {
            this._allowScale = allow;
        }
        set minScale(minScale) {
            this._minScale = minScale;
        }
        set maxScale(maxScale) {
            this._maxScale = maxScale;
        }
        set allowRotate(allow) {
            this._allowRotate = allow;
        }
        set allowTranslate(allow) {
            this._allowTranslate = allow;
        }
        get isDown() {
            return this._isDown;
        }
        get isInertia() {
            return this.inertiaClock !== undefined;
        }
        get angle() {
            return this._angle;
        }
        set angle(angle) {
            this.setContentTransform(undefined, undefined, undefined, angle);
        }
        get scale() {
            return this._scale;
        }
        set scale(scale) {
            this.setContentTransform(undefined, undefined, scale, undefined);
        }
        get translateX() {
            return this._translateX;
        }
        set translateX(translateX) {
            this.setContentTransform(translateX, undefined, undefined, undefined);
        }
        get translateY() {
            return this._translateY;
        }
        set translateY(translateY) {
            this.setContentTransform(undefined, translateY, undefined, undefined);
        }
        buildMatrix(translateX, translateY, scale, angle) {
            if (translateX === undefined)
                translateX = this._translateX;
            if (translateY === undefined)
                translateY = this._translateY;
            if (scale === undefined)
                scale = this._scale;
            if (angle === undefined)
                angle = this._angle;
            return Ui.Matrix.createTranslate(this.layoutWidth * this.transformOriginX, this.layoutHeight * this.transformOriginX).
                translate(translateX, translateY).
                scale(scale, scale).
                rotate(angle).
                translate(-this.layoutWidth * this.transformOriginX, -this.layoutHeight * this.transformOriginX);
        }
        get matrix() {
            return Ui.Matrix.createTranslate(this.layoutWidth * this.transformOriginX, this.layoutHeight * this.transformOriginX).
                translate(this._translateX, this._translateY).
                scale(this._scale, this._scale).
                rotate(this._angle).
                translate(-this.layoutWidth * this.transformOriginX, -this.layoutHeight * this.transformOriginX);
        }
        getBoundaryBox(matrix) {
            if (matrix === undefined)
                matrix = this.matrix;
            let p1 = (new Ui.Point(0, 0)).multiply(matrix);
            let p2 = (new Ui.Point(this.layoutWidth, 0)).multiply(matrix);
            let p3 = (new Ui.Point(this.layoutWidth, this.layoutHeight)).multiply(matrix);
            let p4 = (new Ui.Point(0, this.layoutHeight)).multiply(matrix);
            let minX = Math.min(p1.x, Math.min(p2.x, Math.min(p3.x, p4.x)));
            let minY = Math.min(p1.y, Math.min(p2.y, Math.min(p3.y, p4.y)));
            let maxX = Math.max(p1.x, Math.max(p2.x, Math.max(p3.x, p4.x)));
            let maxY = Math.max(p1.y, Math.max(p2.y, Math.max(p3.y, p4.y)));
            return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        }
        setContentTransform(translateX, translateY, scale, angle) {
            if (translateX === undefined)
                translateX = this._translateX;
            if (translateY === undefined)
                translateY = this._translateY;
            if (scale === undefined)
                scale = this._scale;
            if (angle === undefined)
                angle = this._angle;
            this._translateX = translateX;
            this._translateY = translateY;
            this._scale = scale;
            this._angle = angle;
            if (!this.transformLock) {
                this.transformLock = true;
                this.transformed.fire({ target: this });
                let testOnly = !(((this.watcher1 === undefined) || this.watcher1.getIsCaptured()) &&
                    ((this.watcher2 === undefined) || this.watcher2.getIsCaptured()));
                this.onContentTransform(testOnly);
                this.transformLock = false;
            }
        }
        get inertia() {
            return this._inertia;
        }
        set inertia(inertiaActive) {
            this._inertia = inertiaActive;
        }
        onContentTransform(testOnly = false) {
            if (testOnly !== true)
                this.contentBox.transform = this.matrix;
        }
        onDown() {
            this._isDown = true;
            this.downed.fire({ target: this });
        }
        onUp() {
            this._isDown = false;
            this.upped.fire({ target: this });
        }
        onPointerDown(event) {
            if (!this._allowLeftMouse && event.pointerType == 'mouse' && event.pointer.button == 0)
                return;
            this.stopInertia();
            if (this.watcher1 === undefined) {
                if (this._allowTranslate)
                    this.onDown();
                let watcher = event.pointer.watch(this);
                this.watcher1 = watcher;
                watcher.moved.connect(e => this.onPointerMove(e.target));
                watcher.upped.connect(e => this.onPointerUp(e.target));
                watcher.cancelled.connect(e => this.onPointerCancel(e.target));
                this.startAngle = this._angle;
                this.startScale = this._scale;
                this.startTranslateX = this._translateX;
                this.startTranslateY = this._translateY;
            }
            else if (this.watcher2 === undefined) {
                if (!this._allowTranslate)
                    this.onDown();
                this.watcher1.pointer.setInitialPosition(this.watcher1.pointer.getX(), this.watcher1.pointer.getY());
                let watcher = event.pointer.watch(this);
                this.watcher2 = watcher;
                watcher.moved.connect(e => this.onPointerMove(e.target));
                watcher.upped.connect(e => this.onPointerUp(e.target));
                watcher.cancelled.connect(e => this.onPointerUp(e.target));
                this.startAngle = this._angle;
                this.startScale = this._scale;
                this.startTranslateX = this._translateX;
                this.startTranslateY = this._translateY;
            }
        }
        onPointerMove(watcher) {
            let pos1;
            let pos2;
            let start1;
            let start2;
            if ((this.watcher1 !== undefined) && (this.watcher2 !== undefined)) {
                if (!this.watcher1.getIsCaptured() && this.watcher1.pointer.getIsMove())
                    this.watcher1.capture();
                if (!this.watcher2.getIsCaptured() && this.watcher2.pointer.getIsMove())
                    this.watcher2.capture();
                pos1 = this.pointFromWindow(new Ui.Point(this.watcher1.pointer.getX(), this.watcher1.pointer.getY()));
                pos2 = this.pointFromWindow(new Ui.Point(this.watcher2.pointer.getX(), this.watcher2.pointer.getY()));
                start1 = this.pointFromWindow(new Ui.Point(this.watcher1.pointer.getInitialX(), this.watcher1.pointer.getInitialY()));
                start2 = this.pointFromWindow(new Ui.Point(this.watcher2.pointer.getInitialX(), this.watcher2.pointer.getInitialY()));
                let startVector = { x: start2.x - start1.x, y: start2.y - start1.y };
                let endVector = { x: pos2.x - pos1.x, y: pos2.y - pos1.y };
                startVector.norm = Math.sqrt((startVector.x * startVector.x) + (startVector.y * startVector.y));
                endVector.norm = Math.sqrt((endVector.x * endVector.x) + (endVector.y * endVector.y));
                let scale = endVector.norm / startVector.norm;
                startVector.x /= startVector.norm;
                startVector.y /= startVector.norm;
                endVector.x /= endVector.norm;
                endVector.y /= endVector.norm;
                let divVector = {
                    x: (startVector.x * endVector.x + startVector.y * endVector.y),
                    y: (startVector.y * endVector.x - startVector.x * endVector.y)
                };
                let angle = -(Math.atan2(divVector.y, divVector.x) * 180.0) / Math.PI;
                let deltaMatrix = Ui.Matrix.createTranslate(pos1.x - start1.x, pos1.y - start1.y).translate(start1.x, start1.y);
                if (this._allowScale) {
                    if ((this._minScale !== undefined) || (this._maxScale !== undefined)) {
                        let totalScale = this.startScale * scale;
                        if ((this._minScale !== undefined) && (totalScale < this._minScale))
                            totalScale = this._minScale;
                        if ((this._maxScale !== undefined) && (totalScale > this._maxScale))
                            totalScale = this._maxScale;
                        scale = totalScale / this.startScale;
                    }
                    deltaMatrix = deltaMatrix.scale(scale, scale);
                }
                else
                    scale = 1;
                if (this._allowRotate)
                    deltaMatrix = deltaMatrix.rotate(angle);
                else
                    angle = 0;
                deltaMatrix = deltaMatrix.translate(-start1.x, -start1.y);
                let origin = new Ui.Point(this.layoutWidth * this.transformOriginX, this.layoutHeight * this.transformOriginX);
                deltaMatrix = deltaMatrix.translate(origin.x, origin.y).
                    translate(this.startTranslateX, this.startTranslateY).
                    scale(this.startScale, this.startScale).
                    rotate(this.startAngle).
                    translate(-origin.x, -origin.y);
                origin = origin.multiply(deltaMatrix);
                this.setContentTransform(origin.x - this.layoutWidth * this.transformOriginX, origin.y - this.layoutHeight * this.transformOriginY, this.startScale * scale, this.startAngle + angle);
            }
            else if ((this.watcher1 !== undefined) && this._allowTranslate) {
                pos1 = this.pointFromWindow(new Ui.Point(this.watcher1.pointer.getX(), this.watcher1.pointer.getY()));
                start1 = this.pointFromWindow(new Ui.Point(this.watcher1.pointer.getInitialX(), this.watcher1.pointer.getInitialY()));
                let deltaX = pos1.x - start1.x;
                let deltaY = pos1.y - start1.y;
                let delta = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                this.setContentTransform(this.startTranslateX + (pos1.x - start1.x), this.startTranslateY + (pos1.y - start1.y), this.startScale, this.startAngle);
                let takenDeltaX = (this._translateX - this.startTranslateX);
                let takenDeltaY = (this._translateY - this.startTranslateY);
                let takenDelta = Math.sqrt(takenDeltaX * takenDeltaX + takenDeltaY * takenDeltaY);
                let test = 0;
                if (delta > 0)
                    test = (takenDelta / delta);
                if (!this.watcher1.getIsCaptured() && this.watcher1.pointer.getIsMove() && (test > 0.7))
                    this.watcher1.capture();
            }
        }
        onPointerCancel(watcher) {
            this.onPointerUp(watcher);
            this.stopInertia();
            this._angle = this.startAngle;
            this._scale = this.startScale;
            this._translateX = this.startTranslateX;
            this._translateY = this.startTranslateY;
        }
        onPointerUp(watcher) {
            if ((this.watcher1 !== undefined) && (this.watcher1 === watcher)) {
                if (this.watcher2 !== undefined) {
                    this.watcher1.unwatch();
                    this.watcher1 = this.watcher2;
                    delete (this.watcher2);
                    this.watcher1.pointer.setInitialPosition(this.watcher1.pointer.getX(), this.watcher1.pointer.getY());
                    this.startAngle = this._angle;
                    this.startScale = this._scale;
                    this.startTranslateX = this._translateX;
                    this.startTranslateY = this._translateY;
                    if (!this._allowTranslate)
                        this.onUp();
                }
                else {
                    if (this._allowTranslate)
                        this.onUp();
                    let speed = this.watcher1.getSpeed();
                    this.speedX = speed.x;
                    this.speedY = speed.y;
                    this.watcher1.unwatch();
                    delete (this.watcher1);
                    this.startInertia();
                }
            }
            if ((this.watcher2 !== undefined) && (this.watcher2 === watcher)) {
                this.watcher2.unwatch();
                delete (this.watcher2);
                this.watcher1.pointer.setInitialPosition(this.watcher1.pointer.getX(), this.watcher1.pointer.getY());
                this.startAngle = this._angle;
                this.startScale = this._scale;
                this.startTranslateX = this._translateX;
                this.startTranslateY = this._translateY;
                if (!this._allowTranslate)
                    this.onUp();
            }
        }
        onWheel(event) {
            let delta = 0;
            delta = event.deltaX + event.deltaY;
            if (event.altKey) {
                if (this._allowRotate) {
                    let angle = delta / 5;
                    let pos = this.pointFromWindow(new Ui.Point(event.clientX, event.clientY));
                    let origin = new Ui.Point(this.layoutWidth * this.transformOriginX, this.layoutHeight * this.transformOriginX);
                    let deltaMatrix = Ui.Matrix.createTranslate(pos.x, pos.y).
                        rotate(angle).
                        translate(-pos.x, -pos.y).
                        translate(origin.x, origin.y).
                        translate(this._translateX, this._translateY).
                        scale(this._scale, this._scale).
                        rotate(this._angle).
                        translate(-origin.x, -origin.y);
                    origin = origin.multiply(deltaMatrix);
                    this.setContentTransform(origin.x - this.layoutWidth * this.transformOriginX, origin.y - this.layoutHeight * this.transformOriginY, this._scale, this._angle + angle);
                }
            }
            else if (event.ctrlKey) {
                if (this._allowScale) {
                    let scale = Math.pow(2, (Math.log(this._scale) / Math.log(2)) - delta / 60);
                    if ((this._minScale !== undefined) && (scale < this._minScale))
                        scale = this._minScale;
                    if ((this._maxScale !== undefined) && (scale > this._maxScale))
                        scale = this._maxScale;
                    let deltaScale = scale / this._scale;
                    let pos = this.pointFromWindow(new Ui.Point(event.clientX, event.clientY));
                    let origin = new Ui.Point(this.layoutWidth * this.transformOriginX, this.layoutHeight * this.transformOriginX);
                    let deltaMatrix = Ui.Matrix.createTranslate(pos.x, pos.y).
                        scale(deltaScale, deltaScale).
                        translate(-pos.x, -pos.y).
                        translate(origin.x, origin.y).
                        translate(this._translateX, this._translateY).
                        scale(this._scale, this._scale).
                        rotate(this._angle).
                        translate(-origin.x, -origin.y);
                    origin = origin.multiply(deltaMatrix);
                    this.setContentTransform(origin.x - this.layoutWidth * this.transformOriginX, origin.y - this.layoutHeight * this.transformOriginY, scale, this._angle);
                }
            }
            else
                return;
            event.stopPropagation();
        }
        startInertia() {
            if ((this.inertiaClock === undefined) && this.inertia) {
                this.inertiaClock = new Anim.Clock({ duration: 'forever', target: this });
                this.inertiaClock.timeupdate.connect((e) => this.onTimeupdate(e.target, e.progress, e.deltaTick));
                this.inertiaClock.begin();
                this.inertiastarted.fire({ target: this });
            }
        }
        onTimeupdate(clock, progress, delta) {
            if (delta === 0)
                return;
            let oldTranslateX = this._translateX;
            let oldTranslateY = this._translateY;
            let translateX = this._translateX + (this.speedX * delta);
            let translateY = this._translateY + (this.speedY * delta);
            this.setContentTransform(translateX, translateY, undefined, undefined);
            if ((this._translateX === oldTranslateX) && (this._translateY === oldTranslateY)) {
                this.stopInertia();
                return;
            }
            this.speedX -= this.speedX * delta * 3;
            this.speedY -= this.speedY * delta * 3;
            if (Math.abs(this.speedX) < 0.1)
                this.speedX = 0;
            if (Math.abs(this.speedY) < 0.1)
                this.speedY = 0;
            if ((this.speedX === 0) && (this.speedY === 0))
                this.stopInertia();
        }
        stopInertia() {
            if (this.inertiaClock !== undefined) {
                this.inertiaClock.stop();
                delete (this.inertiaClock);
                this.setContentTransform(Math.round(this._translateX), Math.round(this._translateY), undefined, undefined);
                this.inertiaended.fire({ target: this });
            }
        }
        get content() {
            return this.contentBox.firstChild;
        }
        set content(content) {
            this.contentBox.content = content;
        }
        arrangeCore(width, height) {
            super.arrangeCore(width, height);
            this.onContentTransform();
        }
    }
    Ui.Transformable = Transformable;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Scrollable extends Ui.Container {
        constructor(init) {
            super(init);
            this._scrollHorizontal = true;
            this._scrollVertical = true;
            this.showShadows = false;
            this.lock = false;
            this.isOver = false;
            this.showClock = undefined;
            this.offsetX = 0;
            this.offsetY = 0;
            this.relativeOffsetX = 0;
            this.relativeOffsetY = 0;
            this.viewWidth = 0;
            this.viewHeight = 0;
            this.contentWidth = 0;
            this.contentHeight = 0;
            this.scrollLock = false;
            this.scrollbarVerticalNeeded = false;
            this.scrollbarHorizontalNeeded = false;
            this.scrollbarVerticalHeight = 0;
            this.scrollbarHorizontalWidth = 0;
            this.scrolled = new Core.Events();
            this.autoShowScrollbars = () => {
                if (this.showClock === undefined) {
                    this.showClock = new Anim.Clock({ duration: 'forever' });
                    this.showClock.timeupdate.connect((e) => this.onShowBarsTick(e.target, e.progress, e.deltaTick));
                    this.showClock.begin();
                }
            };
            this.autoHideScrollbars = () => {
                if (this.contentBox.isDown || this.contentBox.isInertia || this.isOver)
                    return;
                if (this.showClock === undefined) {
                    this.showClock = new Anim.Clock({ duration: 'forever' });
                    this.showClock.timeupdate.connect((e) => this.onShowBarsTick(e.target, e.progress, e.deltaTick));
                    this.showClock.begin();
                }
            };
            this.onScrollbarHorizontalMove = () => {
                if (this.scrollLock)
                    return;
                let totalWidth = this.viewWidth - this.scrollbarHorizontalBox.layoutWidth;
                let offsetX = Math.min(1, Math.max(0, this.scrollbarHorizontalBox.positionX / totalWidth));
                this.setOffset(offsetX, undefined, false, true);
                this.scrollbarHorizontalBox.setPosition(offsetX * totalWidth, undefined);
            };
            this.onScrollbarVerticalMove = () => {
                if (this.scrollLock)
                    return;
                let totalHeight = this.viewHeight - this.scrollbarVerticalBox.layoutHeight;
                let offsetY = Math.min(1, Math.max(0, this.scrollbarVerticalBox.positionY / totalHeight));
                this.setOffset(undefined, offsetY, false, true);
                this.scrollbarVerticalBox.setPosition(undefined, offsetY * totalHeight);
            };
            this.contentBox = new Ui.ScrollableContent();
            this.contentBox.scrolled.connect(() => this.onScroll());
            this.contentBox.downed.connect(this.autoShowScrollbars);
            this.contentBox.inertiaended.connect(this.autoHideScrollbars);
            this.appendChild(this.contentBox);
            new Ui.OverWatcher({
                element: this,
                onentered: () => {
                    this.isOver = true;
                    this.autoShowScrollbars();
                },
                onleaved: () => {
                    this.isOver = false;
                    this.autoHideScrollbars();
                }
            });
            new Ui.WheelWatcher({
                element: this,
                onchanged: (e) => this.onWheel(e)
            });
            this.drawing.addEventListener('keydown', (e) => this.onKeyDown(e));
            this.setScrollbarHorizontal(new Ui.Movable());
            this.setScrollbarVertical(new Ui.Movable());
            if (init) {
                if (init.maxScale !== undefined)
                    this.maxScale = init.maxScale;
                if (init.content !== undefined)
                    this.content = init.content;
                if (init.inertia !== undefined)
                    this.inertia = init.inertia;
                if (init.scrollHorizontal !== undefined)
                    this.scrollHorizontal = init.scrollHorizontal;
                if (init.scrollVertical !== undefined)
                    this.scrollVertical = init.scrollVertical;
                if (init.scale !== undefined)
                    this.scale = init.scale;
                if (init.onscrolled)
                    this.scrolled.connect(init.onscrolled);
            }
        }
        set onscrolled(value) { this.scrolled.connect(value); }
        set maxScale(maxScale) {
            this.contentBox.maxScale = maxScale;
        }
        set content(content) {
            this.setContent(content);
        }
        get content() {
            return this.contentBox.content;
        }
        setContent(content) {
            this.contentBox.content = content;
        }
        get inertia() {
            return this.contentBox.inertia;
        }
        set inertia(inertiaActive) {
            this.contentBox.inertia = inertiaActive;
        }
        get scrollHorizontal() {
            return this._scrollHorizontal;
        }
        set scrollHorizontal(scroll) {
            if (scroll !== this._scrollHorizontal) {
                this._scrollHorizontal = scroll;
                this.invalidateMeasure();
            }
        }
        get scrollVertical() {
            return this._scrollVertical;
        }
        set scrollVertical(scroll) {
            if (scroll !== this._scrollVertical) {
                this._scrollVertical = scroll;
                this.invalidateMeasure();
            }
        }
        setScrollbarVertical(scrollbarVertical) {
            if (this.scrollbarVerticalBox) {
                this.scrollbarVerticalBox.downed.disconnect(this.autoShowScrollbars);
                this.scrollbarVerticalBox.upped.disconnect(this.autoHideScrollbars);
                this.scrollbarVerticalBox.moved.disconnect(this.onScrollbarVerticalMove);
                this.removeChild(this.scrollbarVerticalBox);
            }
            if (scrollbarVertical) {
                this.scrollbarVerticalBox = scrollbarVertical;
                this.scrollbarVerticalBox.opacity = 0;
                this.scrollbarVerticalBox.moveHorizontal = false;
                this.scrollbarVerticalBox.downed.connect(this.autoShowScrollbars);
                this.scrollbarVerticalBox.upped.connect(this.autoHideScrollbars);
                this.scrollbarVerticalBox.moved.connect(this.onScrollbarVerticalMove);
                this.appendChild(this.scrollbarVerticalBox);
            }
        }
        setScrollbarHorizontal(scrollbarHorizontal) {
            if (this.scrollbarHorizontalBox) {
                this.scrollbarHorizontalBox.downed.disconnect(this.autoShowScrollbars);
                this.scrollbarHorizontalBox.upped.disconnect(this.autoHideScrollbars);
                this.scrollbarHorizontalBox.moved.disconnect(this.onScrollbarHorizontalMove);
                this.removeChild(this.scrollbarHorizontalBox);
            }
            if (scrollbarHorizontal) {
                this.scrollbarHorizontalBox = scrollbarHorizontal;
                this.scrollbarHorizontalBox.opacity = 0;
                this.scrollbarHorizontalBox.moveVertical = false;
                this.scrollbarHorizontalBox.downed.connect(this.autoShowScrollbars);
                this.scrollbarHorizontalBox.upped.connect(this.autoHideScrollbars);
                this.scrollbarHorizontalBox.moved.connect(this.onScrollbarHorizontalMove);
                this.appendChild(this.scrollbarHorizontalBox);
            }
        }
        setOffset(offsetX, offsetY, absolute = false, align = false) {
            if (absolute === undefined)
                absolute = false;
            if (offsetX === undefined)
                offsetX = this.offsetX;
            else if (!absolute)
                offsetX *= this.contentWidth - this.viewWidth;
            if (offsetY === undefined)
                offsetY = this.offsetY;
            else if (!absolute)
                offsetY *= this.contentHeight - this.viewHeight;
            if (offsetX < 0)
                offsetX = 0;
            else if (this.viewWidth + offsetX > this.contentWidth)
                offsetX = this.contentWidth - this.viewWidth;
            if (offsetY < 0)
                offsetY = 0;
            else if (this.viewHeight + offsetY > this.contentHeight)
                offsetY = this.contentHeight - this.viewHeight;
            if (this.contentWidth <= this.viewWidth)
                this.relativeOffsetX = 0;
            else
                this.relativeOffsetX = offsetX / (this.contentWidth - this.viewWidth);
            if (this.contentHeight <= this.viewHeight)
                this.relativeOffsetY = 0;
            else
                this.relativeOffsetY = offsetY / (this.contentHeight - this.viewHeight);
            if (align) {
                offsetX = Math.round(offsetX);
                offsetY = Math.round(offsetY);
            }
            if ((this.offsetX !== offsetX) || (this.offsetY !== offsetY)) {
                this.offsetX = offsetX;
                this.offsetY = offsetY;
                this.contentBox.setOffset(offsetX, offsetY);
                return true;
            }
            else
                return false;
        }
        getOffsetX() {
            return this.contentBox.offsetX;
        }
        getRelativeOffsetX() {
            return this.relativeOffsetX;
        }
        getOffsetY() {
            return this.contentBox.offsetY;
        }
        getRelativeOffsetY() {
            return this.relativeOffsetY;
        }
        get scale() {
            return this.contentBox.scale;
        }
        set scale(scale) {
            this.contentBox.scale = scale;
        }
        get isDown() {
            return this.contentBox.isDown;
        }
        get isInertia() {
            return this.contentBox.isInertia;
        }
        onWheel(event) {
            let deltaX = event.deltaX;
            let deltaY = event.deltaY;
            if (event.shiftKey) {
                deltaX = event.deltaY;
                deltaY = event.deltaX;
            }
            if (this.setOffset(this.contentBox.offsetX + deltaX * 3, this.contentBox.offsetY + deltaY * 3, true)) {
                event.stopPropagation();
            }
        }
        onKeyDown(event) {
            if (this.isDisabled)
                return;
            let key = event.which;
            if (key == 34 && this.setOffset(undefined, this.contentBox.offsetY + this.layoutHeight, true)) {
                event.stopPropagation();
                event.preventDefault();
            }
            else if (key == 33 && this.setOffset(undefined, this.contentBox.offsetY - this.layoutHeight, true)) {
                event.stopPropagation();
                event.preventDefault();
            }
        }
        onShowBarsTick(clock, progress, delta) {
            let show = this.contentBox.isDown || this.contentBox.isInertia || this.isOver;
            if (this.scrollbarVerticalBox)
                show = show || this.scrollbarVerticalBox.isDown;
            if (this.scrollbarHorizontalBox)
                show = show || this.scrollbarHorizontalBox.isDown;
            let stop = false;
            let speed = 2;
            let opacity = this.scrollbarHorizontalBox.opacity;
            if (show) {
                opacity += (delta * speed);
                if (opacity >= 1) {
                    opacity = 1;
                    stop = true;
                }
            }
            else {
                opacity -= (delta * speed);
                if (opacity <= 0) {
                    opacity = 0;
                    stop = true;
                }
            }
            if (this.scrollbarHorizontalBox)
                this.scrollbarHorizontalBox.opacity = opacity;
            if (this.scrollbarVerticalBox)
                this.scrollbarVerticalBox.opacity = opacity;
            if (stop) {
                if (this.showClock) {
                    this.showClock.stop();
                    this.showClock = undefined;
                }
            }
        }
        onScroll() {
            this.updateOffset();
            this.scrolled.fire({ target: this, offsetX: this.offsetX, offsetY: this.offsetY });
        }
        updateOffset() {
            if (this.contentBox === undefined)
                return;
            this.offsetX = this.contentBox.offsetX;
            this.offsetY = this.contentBox.offsetY;
            this.viewWidth = this.layoutWidth;
            this.viewHeight = this.layoutHeight;
            this.contentWidth = this.contentBox.contentWidth;
            this.contentHeight = this.contentBox.contentHeight;
            if (this.contentWidth <= this.viewWidth)
                this.relativeOffsetX = 0;
            else
                this.relativeOffsetX = this.offsetX / (this.contentWidth - this.viewWidth);
            if (this.contentHeight <= this.viewHeight)
                this.relativeOffsetY = 0;
            else
                this.relativeOffsetY = this.offsetY / (this.contentHeight - this.viewHeight);
            if (this.contentHeight > this.viewHeight)
                this.scrollbarVerticalNeeded = true;
            else
                this.scrollbarVerticalNeeded = false;
            if (this.contentWidth > this.viewWidth)
                this.scrollbarHorizontalNeeded = true;
            else
                this.scrollbarHorizontalNeeded = false;
            if (this.scrollbarVerticalNeeded) {
                if (this.scrollbarVerticalBox) {
                    this.scrollbarVerticalHeight = Math.max((this.viewHeight / this.contentHeight) * this.viewHeight, this.scrollbarVerticalBox.measureHeight);
                    this.scrollbarVerticalBox.arrange(this.layoutWidth - this.scrollbarVerticalBox.measureWidth, 0, this.scrollbarVerticalBox.measureWidth, this.scrollbarVerticalHeight);
                    this.scrollbarVerticalBox.show();
                }
            }
            else {
                if (this.scrollbarVerticalBox)
                    this.scrollbarVerticalBox.hide();
                this.offsetY = 0;
            }
            if (this.scrollbarHorizontalNeeded) {
                if (this.scrollbarHorizontalBox) {
                    this.scrollbarHorizontalWidth = Math.max((this.viewWidth / this.contentWidth) * this.viewWidth, this.scrollbarHorizontalBox.measureWidth);
                    this.scrollbarHorizontalBox.arrange(0, this.layoutHeight - this.scrollbarHorizontalBox.measureHeight, this.scrollbarHorizontalWidth, this.scrollbarHorizontalBox.measureHeight);
                    this.scrollbarHorizontalBox.show();
                }
            }
            else {
                if (this.scrollbarHorizontalBox)
                    this.scrollbarHorizontalBox.hide();
                this.offsetX = 0;
            }
            this.scrollLock = true;
            if (this.scrollbarHorizontalNeeded) {
                let relOffsetX = this.offsetX / (this.contentWidth - this.viewWidth);
                if (relOffsetX > 1) {
                    relOffsetX = 1;
                    this.setOffset(relOffsetX, undefined);
                }
                if (this.scrollbarHorizontalBox)
                    this.scrollbarHorizontalBox.setPosition((this.viewWidth - this.scrollbarHorizontalWidth) * relOffsetX, undefined);
            }
            if (this.scrollbarVerticalNeeded) {
                let relOffsetY = this.offsetY / (this.contentHeight - this.viewHeight);
                if (relOffsetY > 1) {
                    relOffsetY = 1;
                    this.setOffset(undefined, relOffsetY);
                }
                if (this.scrollbarVerticalBox)
                    this.scrollbarVerticalBox.setPosition(undefined, (this.viewHeight - this.scrollbarVerticalHeight) * relOffsetY);
            }
            this.scrollLock = false;
        }
        onScrollIntoView(el) {
            let matrix = Ui.Matrix.createTranslate(this.offsetX, this.offsetY).multiply(el.transformToElement(this));
            let p0 = (new Ui.Point(0, 0)).multiply(matrix);
            let p1 = (new Ui.Point(el.layoutWidth, el.layoutHeight)).multiply(matrix);
            if ((p0.y < this.offsetY) || (p0.y > this.offsetY + this.viewHeight) ||
                (p1.y > this.offsetY + this.viewHeight)) {
                if (Math.abs(this.offsetY + this.viewHeight - p1.y) < Math.abs(this.offsetY - p0.y))
                    this.setOffset(this.offsetX, p1.y - this.viewHeight, true);
                else
                    this.setOffset(this.offsetX, p0.y, true);
                this.contentBox.stopInertia();
            }
            if ((p0.x < this.offsetX) || (p0.x > this.offsetX + this.viewWidth) ||
                (p1.x > this.offsetX + this.viewWidth)) {
                if (Math.abs(this.offsetX + this.viewWidth - p1.x) < Math.abs(this.offsetX - p0.x))
                    this.setOffset(p1.x - this.viewWidth, this.offsetY, true);
                else
                    this.setOffset(p0.x, this.offsetY, true);
                this.contentBox.stopInertia();
            }
            super.onScrollIntoView(el);
        }
        measureCore(width, height) {
            let size = { width: 0, height: 0 };
            if (this.scrollbarHorizontalBox)
                this.scrollbarHorizontalBox.measure(width, height);
            if (this.scrollbarVerticalBox)
                this.scrollbarVerticalBox.measure(width, height);
            let contentSize = this.contentBox.measure(width, height);
            if (contentSize.width < width)
                size.width = contentSize.width;
            else
                size.width = width;
            if (contentSize.height < height)
                size.height = contentSize.height;
            else
                size.height = height;
            if (!this.scrollVertical)
                size.height = contentSize.height;
            if (!this.scrollHorizontal)
                size.width = contentSize.width;
            return size;
        }
        arrangeCore(width, height) {
            this.viewWidth = width;
            this.viewHeight = height;
            this.contentBox.arrange(0, 0, this.viewWidth, this.viewHeight);
            this.contentWidth = this.contentBox.contentWidth;
            this.contentHeight = this.contentBox.contentHeight;
            this.updateOffset();
        }
    }
    Ui.Scrollable = Scrollable;
    class ScrollableContent extends Ui.Transformable {
        constructor() {
            super();
            this._contentWidth = 0;
            this._contentHeight = 0;
            this.scrolled = new Core.Events();
            this.allowLeftMouse = false;
            this.clipToBounds = true;
            this.focusable = false;
            this.drawing.addEventListener('scroll', () => {
                this.translateX -= this.drawing.scrollLeft;
                this.translateY -= this.drawing.scrollTop;
                this.drawing.scrollLeft = 0;
                this.drawing.scrollTop = 0;
                this.onContentTransform();
            });
            this.allowTranslate = true;
            this.allowRotate = false;
            this.minScale = 1;
            this.maxScale = 1;
            this.setTransformOrigin(0, 0);
            this.inertia = true;
        }
        set onscrolled(value) { this.scrolled.connect(value); }
        get offsetX() {
            return -this.translateX;
        }
        get offsetY() {
            return -this.translateY;
        }
        setOffset(x, y) {
            this.setContentTransform(-x, -y, undefined, undefined);
        }
        get contentWidth() {
            return this._contentWidth;
        }
        get contentHeight() {
            return this._contentHeight;
        }
        arrangeCore(width, height) {
            super.arrangeCore(Math.max(width, this.measureWidth), Math.max(height, this.measureHeight));
            this.onContentTransform();
        }
        onContentTransform(testOnly = false) {
            let scale = this.scale;
            if (this.translateX > 0)
                this.translateX = 0;
            if (this.translateY > 0)
                this.translateY = 0;
            let viewWidth = this.layoutWidth;
            let viewHeight = this.layoutHeight;
            this._contentWidth = this.firstChild ? this.firstChild.layoutWidth * scale : 0;
            this._contentHeight = this.firstChild ? this.firstChild.layoutHeight * scale : 0;
            this.translateX = Math.max(this.translateX, -(this._contentWidth - viewWidth));
            this.translateY = Math.max(this.translateY, -(this._contentHeight - viewHeight));
            super.onContentTransform(testOnly);
            this._contentWidth = this.firstChild ? this.firstChild.layoutWidth * scale : 0;
            this._contentHeight = this.firstChild ? this.firstChild.layoutHeight * scale : 0;
            if (testOnly !== true)
                this.scrolled.fire({ target: this, offsetX: this.offsetX, offsetY: this.offsetY });
        }
    }
    Ui.ScrollableContent = ScrollableContent;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class NativeScrollableContent extends Ui.Container {
        constructor() {
            super();
            this.scrolled = new Core.Events();
            this.focusable = false;
            this.containerDrawing = this.scrollDiv;
        }
        set onscrolled(value) { this.scrolled.connect(value); }
        renderDrawing() {
            let drawing = super.renderDrawing();
            drawing.style.overflow = 'hidden';
            this.scrollDiv = document.createElement('div');
            this.scrollDiv.style.position = 'absolute';
            this.scrollDiv.style.top = '0px';
            this.scrollDiv.style.left = '0px';
            this.scrollDiv.style.right = `0px`;
            this.scrollDiv.style.bottom = `0px`;
            this.scrollDiv.style.overflow = 'scroll';
            if (!Core.Navigator.iOs && !Core.Navigator.Android)
                this.scrollDiv.classList.add('hide-scrollbar');
            this.scrollDiv.style.setProperty('transform', 'translateZ(0)');
            this.scrollDiv.style.setProperty('-webkit-overflow-scrolling', 'touch');
            this.scrollDiv.onscroll = () => this.onScroll();
            drawing.appendChild(this.scrollDiv);
            return drawing;
        }
        get content() {
            return this._content;
        }
        set content(value) {
            if (value !== this._content) {
                if (this._content !== undefined)
                    this.removeChild(this._content);
                this._content = value;
                if (this._content)
                    this.appendChild(this._content);
            }
        }
        get offsetX() {
            return this.scrollDiv.scrollLeft;
        }
        get offsetY() {
            return this.scrollDiv.scrollTop;
        }
        stopInertia() {
        }
        setOffset(x, y) {
            this.scrollDiv.scrollLeft = x;
            this.scrollDiv.scrollTop = y;
        }
        get contentWidth() {
            return this._content ? this._content.layoutWidth + this._content.marginLeft + this._content.marginRight : 0;
        }
        get contentHeight() {
            return this._content ? this._content.layoutHeight + this._content.marginTop + this._content.marginBottom : 0;
        }
        measureCore(width, height) {
            let size = { width: 0, height: 0 };
            if (this._content)
                size = this._content.measure(width, height);
            return size;
        }
        arrangeCore(width, height) {
            super.arrangeCore(Math.max(width, this.measureWidth), Math.max(height, this.measureHeight));
            if (this._content)
                this._content.arrange(0, 0, Math.max(width, this._content.measureWidth), Math.max(height, this._content.measureHeight));
        }
        onScroll() {
            this.scrolled.fire({ target: this, offsetX: this.offsetX, offsetY: this.offsetY });
        }
        getInverseLayoutTransform() {
            return Ui.Matrix.createTranslate(-this.scrollDiv.scrollLeft, -this.scrollDiv.scrollTop).multiply(super.getInverseLayoutTransform());
        }
        getLayoutTransform() {
            return super.getLayoutTransform().multiply(Ui.Matrix.createTranslate(this.scrollDiv.scrollLeft, this.scrollDiv.scrollTop));
        }
        static initialize() {
            let style = document.createElement('style');
            style.innerHTML = `
            .hide-scrollbar {
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            .hide-scrollbar::-webkit-scrollbar {
                display: none;
            }
            `;
            document.head.appendChild(style);
        }
    }
    NativeScrollableContent.nativeScrollBarWidth = 0;
    NativeScrollableContent.nativeScrollBarHeight = 0;
    Ui.NativeScrollableContent = NativeScrollableContent;
    NativeScrollableContent.initialize();
    class NativeScrollable extends Ui.Container {
        constructor(init) {
            super(init);
            this._scrollHorizontal = true;
            this._scrollVertical = true;
            this.showShadows = false;
            this.lock = false;
            this.isOver = false;
            this.offsetX = 0;
            this.offsetY = 0;
            this.relativeOffsetX = 0;
            this.relativeOffsetY = 0;
            this.viewWidth = 0;
            this.viewHeight = 0;
            this.contentWidth = 0;
            this.contentHeight = 0;
            this.scrollLock = false;
            this.scrollbarVerticalNeeded = false;
            this.scrollbarHorizontalNeeded = false;
            this.scrollbarVerticalHeight = 0;
            this.scrollbarHorizontalWidth = 0;
            this.scrolled = new Core.Events();
            this.autoShowScrollbars = () => {
                if (this.showClock === undefined) {
                    this.showClock = new Anim.Clock({ duration: 'forever' });
                    this.showClock.timeupdate.connect((e) => this.onShowBarsTick(e.target, e.progress, e.deltaTick));
                    this.showClock.begin();
                }
            };
            this.autoHideScrollbars = () => {
                if (this.isOver)
                    return;
                if (this.showClock === undefined) {
                    this.showClock = new Anim.Clock({ duration: 'forever' });
                    this.showClock.timeupdate.connect((e) => this.onShowBarsTick(e.target, e.progress, e.deltaTick));
                    this.showClock.begin();
                }
            };
            this.onScrollbarHorizontalMove = () => {
                if (this.scrollLock)
                    return;
                let totalWidth = this.viewWidth - this.scrollbarHorizontalBox.layoutWidth;
                let offsetX = Math.min(1, Math.max(0, this.scrollbarHorizontalBox.positionX / totalWidth));
                this.setOffset(offsetX, undefined, false, true);
                this.scrollbarHorizontalBox.setPosition(offsetX * totalWidth, undefined);
            };
            this.onScrollbarVerticalMove = () => {
                if (this.scrollLock)
                    return;
                let totalHeight = this.viewHeight - this.scrollbarVerticalBox.layoutHeight;
                let offsetY = Math.min(1, Math.max(0, this.scrollbarVerticalBox.positionY / totalHeight));
                this.setOffset(undefined, offsetY, false, true);
                this.scrollbarVerticalBox.setPosition(undefined, offsetY * totalHeight);
            };
            this.clipToBounds = true;
            this.contentBox = new NativeScrollableContent();
            this.contentBox.scrolled.connect(() => this.onScroll());
            this.appendChild(this.contentBox);
            new Ui.OverWatcher({
                element: this,
                onentered: () => {
                    this.isOver = true;
                    this.autoShowScrollbars();
                },
                onleaved: () => {
                    this.isOver = false;
                    this.autoHideScrollbars();
                }
            });
            this.setScrollbarHorizontal(new Ui.Movable());
            this.setScrollbarVertical(new Ui.Movable());
            if (init) {
                if (init.content !== undefined)
                    this.content = init.content;
                if (init.scrollHorizontal !== undefined)
                    this.scrollHorizontal = init.scrollHorizontal;
                if (init.scrollVertical !== undefined)
                    this.scrollVertical = init.scrollVertical;
            }
        }
        set onscrolled(value) { this.scrolled.connect(value); }
        set content(content) {
            this.contentBox.content = content;
        }
        get content() {
            return this.contentBox.content;
        }
        get scrollHorizontal() {
            return this._scrollHorizontal;
        }
        set scrollHorizontal(scroll) {
            if (scroll !== this._scrollHorizontal) {
                this._scrollHorizontal = scroll;
                this.invalidateMeasure();
            }
        }
        get scrollVertical() {
            return this._scrollVertical;
        }
        set scrollVertical(scroll) {
            if (scroll !== this._scrollVertical) {
                this._scrollVertical = scroll;
                this.invalidateMeasure();
            }
        }
        setScrollbarVertical(scrollbarVertical) {
            if (this.scrollbarVerticalBox) {
                this.scrollbarVerticalBox.downed.disconnect(this.autoShowScrollbars);
                this.scrollbarVerticalBox.upped.disconnect(this.autoHideScrollbars);
                this.scrollbarVerticalBox.moved.disconnect(this.onScrollbarVerticalMove);
                this.removeChild(this.scrollbarVerticalBox);
            }
            if (scrollbarVertical) {
                this.scrollbarVerticalBox = scrollbarVertical;
                this.scrollbarVerticalBox.opacity = 0;
                this.scrollbarVerticalBox.moveHorizontal = false;
                this.scrollbarVerticalBox.downed.connect(this.autoShowScrollbars);
                this.scrollbarVerticalBox.upped.connect(this.autoHideScrollbars);
                this.scrollbarVerticalBox.moved.connect(this.onScrollbarVerticalMove);
                this.appendChild(this.scrollbarVerticalBox);
                if (Core.Navigator.iOs || Core.Navigator.Android)
                    this.scrollbarVerticalBox.hide(true);
            }
        }
        setScrollbarHorizontal(scrollbarHorizontal) {
            if (this.scrollbarHorizontalBox) {
                this.scrollbarHorizontalBox.downed.disconnect(this.autoShowScrollbars);
                this.scrollbarHorizontalBox.upped.disconnect(this.autoHideScrollbars);
                this.scrollbarHorizontalBox.moved.disconnect(this.onScrollbarHorizontalMove);
                this.removeChild(this.scrollbarHorizontalBox);
            }
            if (scrollbarHorizontal) {
                this.scrollbarHorizontalBox = scrollbarHorizontal;
                this.scrollbarHorizontalBox.opacity = 0;
                this.scrollbarHorizontalBox.moveVertical = false;
                this.scrollbarHorizontalBox.downed.connect(this.autoShowScrollbars);
                this.scrollbarHorizontalBox.upped.connect(this.autoHideScrollbars);
                this.scrollbarHorizontalBox.moved.connect(this.onScrollbarHorizontalMove);
                this.appendChild(this.scrollbarHorizontalBox);
                if (Core.Navigator.iOs || Core.Navigator.Android)
                    this.scrollbarHorizontalBox.hide(true);
            }
        }
        setOffset(offsetX, offsetY, absolute = false, align = false) {
            if (absolute === undefined)
                absolute = false;
            if (offsetX === undefined)
                offsetX = this.offsetX;
            else if (!absolute)
                offsetX *= this.contentWidth - this.viewWidth;
            if (offsetY === undefined)
                offsetY = this.offsetY;
            else if (!absolute)
                offsetY *= this.contentHeight - this.viewHeight;
            if (offsetX < 0)
                offsetX = 0;
            else if (this.viewWidth + offsetX > this.contentWidth)
                offsetX = this.contentWidth - this.viewWidth;
            if (offsetY < 0)
                offsetY = 0;
            else if (this.viewHeight + offsetY > this.contentHeight)
                offsetY = this.contentHeight - this.viewHeight;
            if (this.contentWidth <= this.viewWidth)
                this.relativeOffsetX = 0;
            else
                this.relativeOffsetX = offsetX / (this.contentWidth - this.viewWidth);
            if (this.contentHeight <= this.viewHeight)
                this.relativeOffsetY = 0;
            else
                this.relativeOffsetY = offsetY / (this.contentHeight - this.viewHeight);
            if (align) {
                offsetX = Math.round(offsetX);
                offsetY = Math.round(offsetY);
            }
            if ((this.offsetX !== offsetX) || (this.offsetY !== offsetY)) {
                this.offsetX = offsetX;
                this.offsetY = offsetY;
                this.contentBox.setOffset(offsetX, offsetY);
                return true;
            }
            else
                return false;
        }
        getOffsetX() {
            return this.contentBox.offsetX;
        }
        getRelativeOffsetX() {
            return this.relativeOffsetX;
        }
        getOffsetY() {
            return this.contentBox.offsetY;
        }
        getRelativeOffsetY() {
            return this.relativeOffsetY;
        }
        onShowBarsTick(clock, progress, delta) {
            let show = this.isOver;
            if (this.scrollbarVerticalBox)
                show = show || this.scrollbarVerticalBox.isDown;
            if (this.scrollbarHorizontalBox)
                show = show || this.scrollbarHorizontalBox.isDown;
            let stop = false;
            let speed = 2;
            let opacity = this.scrollbarHorizontalBox.opacity;
            if (show) {
                opacity += (delta * speed);
                if (opacity >= 1) {
                    opacity = 1;
                    stop = true;
                }
            }
            else {
                opacity -= (delta * speed);
                if (opacity <= 0) {
                    opacity = 0;
                    stop = true;
                }
            }
            if (this.scrollbarHorizontalBox)
                this.scrollbarHorizontalBox.opacity = opacity;
            if (this.scrollbarVerticalBox)
                this.scrollbarVerticalBox.opacity = opacity;
            if (stop) {
                if (this.showClock)
                    this.showClock.stop();
                this.showClock = undefined;
            }
        }
        onScroll() {
            this.updateOffset();
            this.scrolled.fire({ target: this, offsetX: this.offsetX, offsetY: this.offsetY });
        }
        updateOffset() {
            if (this.contentBox === undefined)
                return;
            this.offsetX = this.contentBox.offsetX;
            this.offsetY = this.contentBox.offsetY;
            this.viewWidth = this.layoutWidth;
            this.viewHeight = this.layoutHeight;
            this.contentWidth = this.contentBox.contentWidth;
            this.contentHeight = this.contentBox.contentHeight;
            if (this.contentWidth <= this.viewWidth)
                this.relativeOffsetX = 0;
            else
                this.relativeOffsetX = this.offsetX / (this.contentWidth - this.viewWidth);
            if (this.contentHeight <= this.viewHeight)
                this.relativeOffsetY = 0;
            else
                this.relativeOffsetY = this.offsetY / (this.contentHeight - this.viewHeight);
            if (this.contentHeight > this.viewHeight)
                this.scrollbarVerticalNeeded = true;
            else
                this.scrollbarVerticalNeeded = false;
            if (this.contentWidth > this.viewWidth)
                this.scrollbarHorizontalNeeded = true;
            else
                this.scrollbarHorizontalNeeded = false;
            if (this.scrollbarVerticalNeeded) {
                if (this.scrollbarVerticalBox) {
                    this.scrollbarVerticalHeight = Math.max((this.viewHeight / this.contentHeight) * this.viewHeight, this.scrollbarVerticalBox.measureHeight);
                    this.scrollbarVerticalBox.arrange(this.layoutWidth - this.scrollbarVerticalBox.measureWidth, 0, this.scrollbarVerticalBox.measureWidth, this.scrollbarVerticalHeight);
                    if (!Core.Navigator.iOs && !Core.Navigator.Android)
                        this.scrollbarVerticalBox.show();
                }
            }
            else {
                if (this.scrollbarVerticalBox)
                    this.scrollbarVerticalBox.hide();
                this.offsetY = 0;
            }
            if (this.scrollbarHorizontalNeeded) {
                if (this.scrollbarHorizontalBox) {
                    this.scrollbarHorizontalWidth = Math.max((this.viewWidth / this.contentWidth) * this.viewWidth, this.scrollbarHorizontalBox.measureWidth);
                    this.scrollbarHorizontalBox.arrange(0, this.layoutHeight - this.scrollbarHorizontalBox.measureHeight, this.scrollbarHorizontalWidth, this.scrollbarHorizontalBox.measureHeight);
                    if (!Core.Navigator.iOs && !Core.Navigator.Android)
                        this.scrollbarHorizontalBox.show();
                }
            }
            else {
                if (this.scrollbarHorizontalBox)
                    this.scrollbarHorizontalBox.hide();
                this.offsetX = 0;
            }
            this.scrollLock = true;
            if (this.scrollbarHorizontalNeeded) {
                let relOffsetX = this.offsetX / (this.contentWidth - this.viewWidth);
                if (relOffsetX > 1) {
                    relOffsetX = 1;
                    this.setOffset(relOffsetX, undefined);
                }
                if (this.scrollbarHorizontalBox)
                    this.scrollbarHorizontalBox.setPosition((this.viewWidth - this.scrollbarHorizontalWidth) * relOffsetX, undefined);
            }
            if (this.scrollbarVerticalNeeded) {
                let relOffsetY = this.offsetY / (this.contentHeight - this.viewHeight);
                if (relOffsetY > 1) {
                    relOffsetY = 1;
                    this.setOffset(undefined, relOffsetY);
                }
                if (this.scrollbarVerticalBox)
                    this.scrollbarVerticalBox.setPosition(undefined, (this.viewHeight - this.scrollbarVerticalHeight) * relOffsetY);
            }
            this.scrollLock = false;
        }
        measureCore(width, height) {
            let size = { width: 0, height: 0 };
            if (this.scrollbarHorizontalBox)
                this.scrollbarHorizontalBox.measure(width, height);
            if (this.scrollbarVerticalBox)
                this.scrollbarVerticalBox.measure(width, height);
            let contentSize = this.contentBox.measure(width, height);
            if (contentSize.width < width)
                size.width = contentSize.width;
            else
                size.width = width;
            if (contentSize.height < height)
                size.height = contentSize.height;
            else
                size.height = height;
            if (!this.scrollVertical || Ui.App.isPrint)
                size.height = contentSize.height;
            if (!this.scrollHorizontal)
                size.width = contentSize.width;
            return size;
        }
        arrangeCore(width, height) {
            this.viewWidth = width;
            this.viewHeight = height;
            this.contentBox.arrange(0, 0, this.viewWidth, this.viewHeight);
            this.contentWidth = this.contentBox.contentWidth;
            this.contentHeight = this.contentBox.contentHeight;
            this.updateOffset();
        }
        onScrollIntoView(el) {
            let matrix = Ui.Matrix.createTranslate(this.offsetX, this.offsetY).multiply(el.transformToElement(this));
            let p0 = (new Ui.Point(0, 0)).multiply(matrix);
            let p1 = (new Ui.Point(el.layoutWidth, el.layoutHeight)).multiply(matrix);
            if ((p0.y < this.offsetY) || (p0.y > this.offsetY + this.viewHeight) ||
                (p1.y > this.offsetY + this.viewHeight)) {
                if (Math.abs(this.offsetY + this.viewHeight - p1.y) < Math.abs(this.offsetY - p0.y))
                    this.setOffset(this.offsetX, p1.y - this.viewHeight, true);
                else
                    this.setOffset(this.offsetX, p0.y, true);
                this.contentBox.stopInertia();
            }
            if ((p0.x < this.offsetX) || (p0.x > this.offsetX + this.viewWidth) ||
                (p1.x > this.offsetX + this.viewWidth)) {
                if (Math.abs(this.offsetX + this.viewWidth - p1.x) < Math.abs(this.offsetX - p0.x))
                    this.setOffset(p1.x - this.viewWidth, this.offsetY, true);
                else
                    this.setOffset(p0.x, this.offsetY, true);
                this.contentBox.stopInertia();
            }
            super.onScrollIntoView(el);
        }
    }
    Ui.NativeScrollable = NativeScrollable;
    class NativeScrollingArea extends NativeScrollable {
        constructor(init) {
            super(init);
            this.horizontalScrollbar = new Ui.Scrollbar('horizontal');
            this.setScrollbarHorizontal(this.horizontalScrollbar);
            this.verticalScrollbar = new Ui.Scrollbar('vertical');
            this.setScrollbarVertical(this.verticalScrollbar);
        }
        onStyleChange() {
            let radius = this.getStyleProperty('radius');
            this.horizontalScrollbar.radius = radius;
            this.verticalScrollbar.radius = radius;
            let color = this.getStyleProperty('color');
            this.horizontalScrollbar.fill = color;
            this.verticalScrollbar.fill = color;
        }
    }
    NativeScrollingArea.style = {
        color: 'rgba(50,50,50,0.7)',
        radius: 0
    };
    Ui.NativeScrollingArea = NativeScrollingArea;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Scrollbar extends Ui.Movable {
        constructor(orientation) {
            super();
            this.orientation = orientation;
            this.scale = 0;
            this.cursor = 'inherit';
            this.focusable = false;
            this.over = new Ui.Overable();
            this.content = this.over;
            this.rect = new Ui.Rectangle();
            this.rect.transformOriginX = 1;
            this.rect.transformOriginY = 1;
            if (orientation == 'horizontal') {
                this.rect.width = 30;
                this.rect.height = 15;
                this.over.height = 15;
                this.rect.verticalAlign = 'bottom';
            }
            else {
                this.rect.width = 15;
                this.rect.height = 30;
                this.over.width = 15;
                this.rect.horizontalAlign = 'right';
            }
            this.over.content = this.rect;
            this.over.entered.connect(() => this.startAnim());
            this.over.leaved.connect(() => this.startAnim());
            this.downed.connect(() => this.startAnim());
            this.upped.connect(() => this.startAnim());
            this.updateScale();
        }
        set radius(radius) {
            this.rect.radius = radius;
        }
        set fill(color) {
            this.rect.fill = color;
        }
        startAnim() {
            if (this.clock == undefined) {
                this.clock = new Anim.Clock();
                this.clock.duration = 'forever';
                this.clock.timeupdate.connect((e) => this.onTick(e.target, e.progress, e.deltaTick));
                this.clock.begin();
            }
        }
        onTick(clock, progress, deltaTick) {
            let d = deltaTick * 30;
            let view = this.over.isOver || this.isDown;
            if (!view)
                d = -d;
            this.scale = Math.max(0, Math.min(1, this.scale + (d / 10)));
            this.updateScale();
            if ((!view && this.scale == 0) || (view && this.scale == 1)) {
                if (this.clock)
                    this.clock.stop();
                this.clock = undefined;
            }
        }
        updateScale() {
            let rs = (5 + this.scale * 10) / 15;
            if (this.orientation == 'vertical')
                this.rect.transform = Ui.Matrix.createScale(rs, 1);
            else
                this.rect.transform = Ui.Matrix.createScale(1, rs);
        }
    }
    Ui.Scrollbar = Scrollbar;
    class ScrollingArea extends Ui.NativeScrollingArea {
        constructor(init) {
            super(init);
            if (init) {
                if (init.content != undefined)
                    this.content = init.content;
                if (init.scrollHorizontal != undefined)
                    this.scrollHorizontal = init.scrollHorizontal;
                if (init.scrollVertical != undefined)
                    this.scrollVertical = init.scrollVertical;
                if (init.onscrolled != undefined)
                    this.scrolled.connect(init.onscrolled);
            }
        }
    }
    Ui.ScrollingArea = ScrollingArea;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class CompactLabelContext extends Core.Object {
        constructor() {
            super();
            this.text = '';
            this.fontSize = 16;
            this.fontFamily = 'Sans-Serif';
            this.fontWeight = 'normal';
            this.maxLine = Number.MAX_VALUE;
            this.interLine = 1;
            this.textAlign = 'left';
            this.width = Number.MAX_VALUE;
            this.drawLine = undefined;
            this.whiteSpace = 'pre-line';
            this.wordWrap = 'normal';
            this.textTransform = 'none';
        }
        setDrawLine(func) {
            this.drawLine = func;
        }
        getWhiteSpace() {
            return this.whiteSpace;
        }
        setWhiteSpace(whiteSpace) {
            this.whiteSpace = whiteSpace;
        }
        getWordWrap() {
            return this.wordWrap;
        }
        setWordWrap(wordWrap) {
            this.wordWrap = wordWrap;
        }
        getMaxLine() {
            return this.maxLine;
        }
        setMaxLine(maxLine) {
            if (this.maxLine !== maxLine)
                this.maxLine = maxLine;
        }
        getTextAlign() {
            return this.textAlign;
        }
        setTextAlign(textAlign) {
            if (this.textAlign !== textAlign)
                this.textAlign = textAlign;
        }
        setInterLine(interLine) {
            if (this.interLine !== interLine)
                this.interLine = interLine;
        }
        getInterLine() {
            return this.interLine;
        }
        getText() {
            return this.text;
        }
        setText(text) {
            if (this.text !== text) {
                this.text = text;
            }
        }
        setFontSize(fontSize) {
            if (this.fontSize !== fontSize) {
                this.fontSize = fontSize;
            }
        }
        getFontSize() {
            return this.fontSize;
        }
        setFontFamily(fontFamily) {
            if (this.fontFamily !== fontFamily) {
                this.fontFamily = fontFamily;
            }
        }
        getFontFamily() {
            return this.fontFamily;
        }
        setFontWeight(fontWeight) {
            if (this.fontWeight !== fontWeight) {
                this.fontWeight = fontWeight;
            }
        }
        getFontWeight() {
            return this.fontWeight;
        }
        getTextTransform() {
            return this.textTransform;
        }
        setTextTransform(textTransform) {
            this.textTransform = textTransform;
        }
        getTransformedText() {
            if (this.textTransform === 'lowercase')
                return this.text.toLowerCase();
            else if (this.textTransform === 'uppercase')
                return this.text.toUpperCase();
            else
                return this.text;
        }
        flushLine(y, line, width, render, lastLine = false) {
            let size = Ui.Label.measureText(line, this.getFontSize(), this.getFontFamily(), this.getFontWeight());
            if (render) {
                let x;
                if (this.textAlign == 'left')
                    x = 0;
                else if (this.textAlign == 'right')
                    x = width - size.width;
                else
                    x = (width - size.width) / 2;
                if (render)
                    this.drawLine(x, y, line);
            }
            return size.height * ((lastLine === true) ? 1 : this.getInterLine());
        }
        updateFlow(width, render) {
            if (this.text === undefined)
                return { width: 0, height: 0 };
            let text = this.getTransformedText();
            let fontSize = this.getFontSize();
            let fontFamily = this.getFontFamily();
            let fontWeight = this.getFontWeight();
            let dotWidth = (Ui.Label.measureText('...', fontSize, fontFamily, fontWeight)).width;
            let y = 0;
            let x = 0;
            let line = '';
            let lineCount = 0;
            let maxWidth = 0;
            for (let i = 0; i < text.length; i++) {
                if (text.charAt(i) == '\n') {
                    if ((this.maxLine !== undefined) && (lineCount + 1 >= this.maxLine)) {
                        y += this.flushLine(y, line + '...', width, render);
                        if (x + dotWidth > maxWidth)
                            maxWidth = x + dotWidth;
                        return { width: maxWidth, height: y };
                    }
                    y += this.flushLine(y, line, width, render);
                    lineCount++;
                    line = '';
                    continue;
                }
                let size = Ui.Label.measureText(line + text.charAt(i), fontSize, fontFamily, fontWeight);
                if ((this.maxLine !== undefined) && (lineCount + 1 >= this.maxLine) && (size.width + dotWidth > width)) {
                    y += this.flushLine(y, line + '...', width, render);
                    if (x + dotWidth > maxWidth)
                        maxWidth = x + dotWidth;
                    return { width: maxWidth, height: y };
                }
                else if (size.width > width) {
                    y += this.flushLine(y, line, width, render);
                    lineCount++;
                    if (x > maxWidth)
                        maxWidth = x;
                    line = text.charAt(i);
                }
                else
                    line += text.charAt(i);
                x = size.width;
            }
            if (line !== '') {
                y += this.flushLine(y, line, width, render, true);
                if (x > maxWidth)
                    maxWidth = x;
            }
            return { width: maxWidth, height: y };
        }
        updateFlowWords(width, render) {
            if (this.text == undefined)
                return { width: 0, height: 0 };
            let text = this.getTransformedText();
            let fontSize = this.getFontSize();
            let fontFamily = this.getFontFamily();
            let fontWeight = this.getFontWeight();
            let dotWidth = (Ui.Label.measureText('...', fontSize, fontFamily, fontWeight)).width;
            let words = [];
            let wordsSize = [];
            let lines = text.split('\n');
            for (let line of lines) {
                let tmpWords = line.split(' ');
                for (let i = 0; i < tmpWords.length; i++) {
                    let word = tmpWords[i];
                    while (true) {
                        let wordSize = (Ui.Label.measureText(word, fontSize, fontFamily, fontWeight)).width;
                        if (wordSize <= width) {
                            words.push(word);
                            wordsSize.push(wordSize);
                            break;
                        }
                        else {
                            let tmpWord = '';
                            for (let i2 = 0; i2 < word.length; i2++) {
                                if ((Ui.Label.measureText(tmpWord + word.charAt(i2), fontSize, fontFamily, fontWeight)).width < width)
                                    tmpWord += word.charAt(i2);
                                else {
                                    if (tmpWord === '')
                                        tmpWord = word.charAt(0);
                                    words.push(tmpWord);
                                    wordsSize.push((Ui.Label.measureText(tmpWord, fontSize, fontFamily, fontWeight)).width);
                                    word = word.substr(tmpWord.length, word.length - tmpWord.length);
                                    break;
                                }
                            }
                        }
                        if (word.length === 0)
                            break;
                    }
                }
                words.push('\n');
                wordsSize.push(0);
            }
            let spaceWidth = (Ui.Label.measureText('. .', fontSize, fontFamily, fontWeight)).width - (Ui.Label.measureText('..', fontSize, fontFamily, fontWeight)).width;
            let y = 0;
            let x = 0;
            let maxWidth = 0;
            let line = '';
            let lineCount = 0;
            for (let i = 0; i < words.length; i++) {
                if (words[i] == '\n') {
                    if (lineCount + 1 >= this.maxLine && i != words.length - 1) {
                        while (true) {
                            let lineWidth = (Ui.Label.measureText(line, fontSize, fontFamily, fontWeight)).width;
                            if (lineWidth + dotWidth > width) {
                                if (line.length <= 1) {
                                    line = '...';
                                    break;
                                }
                                line = line.substr(0, line.length - 1);
                            }
                            else {
                                line += '...';
                                break;
                            }
                        }
                        y += this.flushLine(y, line, width, render);
                        if (x > maxWidth)
                            maxWidth = x;
                        return { width: maxWidth, height: y };
                    }
                    y += this.flushLine(y, line, width, render);
                    if (x > maxWidth)
                        maxWidth = x;
                    x = 0;
                    lineCount++;
                    line = '';
                    continue;
                }
                if (line !== '') {
                    if (x + spaceWidth > width) {
                        if (lineCount + 1 >= this.maxLine) {
                            while (true) {
                                let lineWidth = (Ui.Label.measureText(line, fontSize, fontFamily, fontWeight)).width;
                                if (lineWidth + dotWidth > width) {
                                    if (line.length <= 1) {
                                        line = '...';
                                        break;
                                    }
                                    line = line.substr(0, line.length - 1);
                                }
                                else {
                                    line += '...';
                                    break;
                                }
                            }
                            y += this.flushLine(y, line, width, render);
                            if (x > maxWidth)
                                maxWidth = x;
                            return { width: maxWidth, height: y };
                        }
                        y += this.flushLine(y, line, width, render);
                        if (x > maxWidth)
                            maxWidth = x;
                        x = 0;
                        lineCount++;
                        line = '';
                    }
                    else {
                        line += ' ';
                        x += spaceWidth;
                    }
                }
                if (x + wordsSize[i] > width) {
                    if (lineCount + 1 >= this.maxLine) {
                        while (true) {
                            let lineWidth = (Ui.Label.measureText(line, fontSize, fontFamily, fontWeight)).width;
                            if (lineWidth + dotWidth > width) {
                                if (line.length <= 1) {
                                    line = '...';
                                    break;
                                }
                                line = line.substr(0, line.length - 1);
                            }
                            else {
                                line += '...';
                                break;
                            }
                        }
                        y += this.flushLine(y, line, width, render);
                        if (x > maxWidth)
                            maxWidth = x;
                        return { width: maxWidth, height: y };
                    }
                    y += this.flushLine(y, line, width, render);
                    lineCount++;
                    if (x > maxWidth)
                        maxWidth = x;
                    x = wordsSize[i];
                    line = words[i];
                }
                else {
                    line += words[i];
                    x += wordsSize[i];
                }
            }
            if (line !== '') {
                y += this.flushLine(y, line, width, render, true);
                if (x > maxWidth)
                    maxWidth = x;
            }
            return { width: maxWidth, height: y };
        }
        drawText(width, render) {
            if (this.whiteSpace === 'nowrap') {
                let text = this.getTransformedText();
                let size = Ui.Label.measureText(text, this.fontSize, this.fontFamily, this.fontWeight);
                if (render)
                    this.flushLine(0, text, width, true, true);
                return size;
            }
            else if (this.wordWrap === 'normal')
                return this.updateFlowWords(width, render);
            else
                return this.updateFlow(width, render);
        }
    }
    Ui.CompactLabelContext = CompactLabelContext;
    class CompactLabel extends Ui.Element {
        constructor(init) {
            super(init);
            this.isMeasureValid = false;
            this.isArrangeValid = false;
            this.lastMeasureWidth = 0;
            this.lastMeasureHeight = 0;
            this.lastAvailableWidth = 0;
            if (!init || init.selectable == undefined)
                this.selectable = false;
            this.textContext = new Ui.CompactLabelContext();
            if (init) {
                if (init.maxLine !== undefined)
                    this.maxLine = init.maxLine;
                if (init.text !== undefined)
                    this.text = init.text;
                if (init.textAlign !== undefined)
                    this.textAlign = init.textAlign;
                if (init.interLine !== undefined)
                    this.interLine = init.interLine;
                if (init.fontSize !== undefined)
                    this.fontSize = init.fontSize;
                if (init.fontFamily !== undefined)
                    this.fontFamily = init.fontFamily;
                if (init.fontWeight !== undefined)
                    this.fontWeight = init.fontWeight;
                if (init.whiteSpace !== undefined)
                    this.whiteSpace = init.whiteSpace;
                if (init.wordWrap !== undefined)
                    this.wordWrap = init.wordWrap;
                if (init.textTransform !== undefined)
                    this.textTransform = init.textTransform;
                if (init.color !== undefined)
                    this.color = init.color;
            }
        }
        get maxLine() {
            if (this._maxLine !== undefined)
                return this._maxLine;
            else
                return this.getStyleProperty('maxLine');
        }
        set maxLine(maxLine) {
            this._maxLine = maxLine;
            this.isMeasureValid = false;
            this.textContext.setMaxLine(this.maxLine);
            this.invalidateMeasure();
        }
        get text() {
            return this.textContext.getText();
        }
        set text(text) {
            this.textContext.setText(text);
            this.isMeasureValid = false;
            this.invalidateMeasure();
        }
        get textAlign() {
            if (this._textAlign !== undefined)
                return this._textAlign;
            else
                return this.getStyleProperty('textAlign');
        }
        set textAlign(textAlign) {
            this._textAlign = textAlign;
            this.textContext.setTextAlign(this.textAlign);
            this.invalidateArrange();
        }
        get interLine() {
            if (this._interLine !== undefined)
                return this._interLine;
            else
                return this.getStyleProperty('interLine');
        }
        set interLine(interLine) {
            this._interLine = interLine;
            this.textContext.setInterLine(this.interLine);
            this.isMeasureValid = false;
            this.invalidateMeasure();
        }
        get fontSize() {
            if (this._fontSize !== undefined)
                return this._fontSize;
            else
                return this.getStyleProperty('fontSize');
        }
        set fontSize(fontSize) {
            this._fontSize = fontSize;
            this.isMeasureValid = false;
            this.textContext.setFontSize(this.fontSize);
            this.textDrawing.style.fontSize = this.fontSize + 'px';
            this.textDrawing.style.lineHeight = this.fontSize + 'px';
            this.invalidateMeasure();
        }
        get fontFamily() {
            if (this._fontFamily !== undefined)
                return this._fontFamily;
            else
                return this.getStyleProperty('fontFamily');
        }
        set fontFamily(fontFamily) {
            this._fontFamily = fontFamily;
            this.isMeasureValid = false;
            this.textContext.setFontFamily(this.fontFamily);
            this.textDrawing.style.fontFamily = this.fontFamily;
            this.invalidateMeasure();
        }
        get fontWeight() {
            if (this._fontWeight !== undefined)
                return this._fontWeight;
            else
                return this.getStyleProperty('fontWeight');
        }
        set fontWeight(fontWeight) {
            this._fontWeight = fontWeight;
            this.isMeasureValid = false;
            this.textContext.setFontWeight(fontWeight);
            this.textDrawing.style.fontWeight = this.fontWeight;
            this.invalidateMeasure();
        }
        get whiteSpace() {
            if (this._whiteSpace !== undefined)
                return this._whiteSpace;
            else
                return this.getStyleProperty('whiteSpace');
        }
        set whiteSpace(whiteSpace) {
            if (this._whiteSpace !== whiteSpace) {
                this.isMeasureValid = false;
                this._whiteSpace = whiteSpace;
                this.textContext.setWhiteSpace(this.whiteSpace);
                this.invalidateMeasure();
            }
        }
        get wordWrap() {
            if (this._wordWrap !== undefined)
                return this._wordWrap;
            else
                return this.getStyleProperty('wordWrap');
        }
        set wordWrap(wordWrap) {
            if (this._wordWrap !== wordWrap) {
                this.isMeasureValid = false;
                this._wordWrap = wordWrap;
                this.textContext.setWordWrap(this.wordWrap);
                this.invalidateMeasure();
            }
        }
        get textTransform() {
            if (this._textTransform !== undefined)
                return this._textTransform;
            else
                return this.getStyleProperty('textTransform');
        }
        set textTransform(textTransform) {
            if (this._textTransform !== textTransform) {
                this.isMeasureValid = false;
                this._textTransform = textTransform;
                this.textContext.setTextTransform(this.textTransform);
                this.invalidateMeasure();
            }
        }
        set color(color) {
            if (this._color !== color) {
                if (color == undefined) {
                    this._color = undefined;
                    this.textDrawing.style.color = this.color.getCssRgba();
                }
                else {
                    this._color = Ui.Color.create(color);
                    this.textDrawing.style.color = this._color.getCssRgba();
                }
            }
        }
        get color() {
            if (this._color !== undefined)
                return this._color;
            else
                return Ui.Color.create(this.getStyleProperty('color'));
        }
        renderDrawing() {
            let drawing = super.renderDrawing();
            this.textDrawing = document.createElement('div');
            this.textDrawing.style.fontFamily = this.fontFamily;
            this.textDrawing.style.fontWeight = this.fontWeight;
            this.textDrawing.style.fontSize = this.fontSize + 'px';
            this.textDrawing.style.lineHeight = this.fontSize + 'px';
            this.textDrawing.style.color = this.color.getCssRgba();
            this.textDrawing.style.position = 'absolute';
            this.textDrawing.style.left = '0px';
            this.textDrawing.style.top = '0px';
            drawing.appendChild(this.textDrawing);
            return drawing;
        }
        onStyleChange() {
            this.textDrawing.style.fontSize = this.fontSize + 'px';
            this.textDrawing.style.lineHeight = this.fontSize + 'px';
            this.textDrawing.style.fontFamily = this.fontFamily;
            this.textDrawing.style.fontWeight = this.fontWeight;
            this.textDrawing.style.color = this.color.getCssRgba();
            this.textContext.setMaxLine(this.maxLine);
            this.textContext.setTextAlign(this.textAlign);
            this.textContext.setFontSize(this.fontSize);
            this.textContext.setFontFamily(this.fontFamily);
            this.textContext.setFontWeight(this.fontWeight);
            this.textContext.setInterLine(this.interLine);
            this.textContext.setWhiteSpace(this.whiteSpace);
            this.textContext.setWordWrap(this.wordWrap);
            this.textContext.setTextTransform(this.textTransform);
            this.invalidateMeasure();
        }
        invalidateTextMeasure() {
            if (this.isMeasureValid) {
                this.isMeasureValid = false;
                this.invalidateMeasure();
            }
        }
        measureCore(width, height) {
            if (!this.isMeasureValid || (this.lastAvailableWidth !== width)) {
                this.lastAvailableWidth = width;
                let size = this.textContext.drawText(width, false);
                this.lastMeasureHeight = size.height;
                this.lastMeasureWidth = size.width;
                this.isMeasureValid = true;
                this.isArrangeValid = false;
            }
            return { width: this.lastMeasureWidth, height: this.lastMeasureHeight };
        }
        arrangeCore(width, height) {
            while (this.textDrawing.hasChildNodes())
                this.textDrawing.removeChild(this.textDrawing.firstChild);
            let textDrawing = this.textDrawing;
            this.textContext.setDrawLine(function (x, y, line) {
                let tspan = document.createElement('div');
                tspan.style.whiteSpace = 'nowrap';
                tspan.style.wordWrap = 'none';
                tspan.style.display = 'inline';
                tspan.style.position = 'absolute';
                tspan.style.left = x + 'px';
                tspan.style.top = y + 'px';
                if ('textContent' in tspan)
                    tspan.textContent = line;
                else
                    tspan.innerText = line;
                textDrawing.appendChild(tspan);
            });
            this.textContext.drawText(width, true);
        }
    }
    CompactLabel.style = {
        maxLine: Number.MAX_VALUE,
        color: '#444444',
        fontSize: 16,
        fontFamily: 'sans-serif',
        fontWeight: 'normal',
        interLine: 1,
        textAlign: 'left',
        whiteSpace: 'pre-line',
        wordWrap: 'normal',
        textTransform: 'none'
    };
    Ui.CompactLabel = CompactLabel;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class DropableWatcher extends Core.Object {
        constructor(init) {
            super();
            this.element = init.element;
            if (init.onentered)
                this.enter = init.onentered;
            if (init.onleaved)
                this.leave = init.onleaved;
            if (init.ondropped)
                this.drop = init.ondropped;
            if (init.ondroppedfile)
                this.dropfile = init.ondroppedfile;
            if (init.types)
                this.types = init.types;
            this.watchers = [];
            this.element.dragover.connect((e) => this.onDragOver(e));
        }
        addType(type, effects) {
            if (typeof (type) === 'string')
                type = type.toLowerCase();
            if (this.allowedTypes == undefined)
                this.allowedTypes = [];
            if (typeof (effects) === 'string')
                effects = [effects];
            if (typeof (effects) !== 'function') {
                for (let i = 0; i < effects.length; i++) {
                    let effect = effects[i];
                    if (typeof (effect) === 'string')
                        effect = { action: effect };
                    if (!('text' in effect)) {
                        if (effect.action === 'copy')
                            effect.text = 'Copier';
                        else if (effect.action === 'move')
                            effect.text = 'Déplacer';
                        else if (effect.action === 'link')
                            effect.text = 'Lier';
                        else
                            effect.text = effect.action;
                    }
                    if (!('dragicon' in effect))
                        effect.dragicon = 'drag' + effect.action;
                    effects[i] = effect;
                }
                this.allowedTypes.push({ type: type, effect: effects });
            }
            else
                this.allowedTypes.push({ type: type, effect: effects });
        }
        set types(types) {
            this.allowedTypes = [];
            types.forEach(type => this.addType(type.type, type.effects));
        }
        onDragOver(event) {
            if (!event.dataTransfer)
                return;
            let found = false;
            for (let i = 0; !found && (i < this.watchers.length); i++)
                found = (this.watchers[i].getDataTransfer() === event.dataTransfer);
            if (!found) {
                let effect = this.onDragEffect(event.dataTransfer);
                if ((effect !== undefined) && (effect.length > 0)) {
                    let watcher = event.dataTransfer.capture(this.element, effect);
                    this.watchers.push(watcher);
                    watcher.dropped.connect((e) => this.onWatcherDrop(e.target, e.effect, e.x, e.y));
                    watcher.leaved.connect((e) => this.onWatcherLeave(e.target));
                    event.stopImmediatePropagation();
                    this.onWatcherEnter(watcher);
                }
            }
            else
                event.stopImmediatePropagation();
        }
        onWatcherEnter(watcher) {
            this.onDragEnter(watcher.getDataTransfer());
        }
        onWatcherDrop(watcher, effect, x, y) {
            let point = this.element.pointFromWindow(new Ui.Point(x, y));
            this.onDrop(watcher.getDataTransfer(), effect, point.getX(), point.getY());
        }
        onWatcherLeave(watcher) {
            let found = false;
            let i = 0;
            for (; !found && (i < this.watchers.length); i++) {
                found = (this.watchers[i] === watcher);
            }
            i--;
            if (found)
                this.watchers.splice(i, 1);
            if (this.watchers.length === 0)
                this.onDragLeave();
        }
        getAllowedTypesEffect(dataTransfer) {
            if (this.allowedTypes !== undefined) {
                let data = dataTransfer.getData();
                let effect = undefined;
                for (let i = 0; (effect === undefined) && (i < this.allowedTypes.length); i++) {
                    let type = this.allowedTypes[i];
                    if (typeof (type.type) === 'string') {
                        if (type.type === 'all')
                            effect = type.effect;
                        else if (data instanceof Ui.DragNativeData) {
                            if ((type.type === 'files') && data.hasFiles())
                                effect = type.effect;
                            else if (((type.type === 'text') || (type.type === 'text/plain')) && data.hasTypes('text/plain', 'text'))
                                effect = type.effect;
                            else if (data.hasType(type.type))
                                effect = type.effect;
                        }
                    }
                    else if (data instanceof type.type)
                        effect = type.effect;
                }
                if (typeof (effect) === 'function') {
                    let effects = this.onDragEffectFunction(dataTransfer, effect);
                    for (let i = 0; i < effects.length; i++) {
                        let effect = effects[i];
                        if (typeof (effect) === 'string')
                            effect = { action: effect };
                        if (!('text' in effect)) {
                            if (effect.action === 'copy')
                                effect.text = 'Copier';
                            else if (effect.action === 'move')
                                effect.text = 'Déplacer';
                            else if (effect.action === 'link')
                                effect.text = 'Lier';
                            else if (effect.action === 'run')
                                effect.text = 'Exécuter';
                            else if (effect.action === 'play')
                                effect.text = 'Jouer';
                            else
                                effect.text = effect.action;
                        }
                        if (!('dragicon' in effect))
                            effect.dragicon = 'drag' + effect.action;
                        effects[i] = effect;
                    }
                    effect = effects;
                }
                if (effect === undefined)
                    effect = [];
                return effect;
            }
            else
                return [];
        }
        onDragEffect(dataTransfer) {
            if (this.element.isDisabled)
                return [];
            let dragEvent = new Ui.DragEvent();
            dragEvent.setType('drageffect');
            dragEvent.setBubbles(false);
            dragEvent.dataTransfer = dataTransfer;
            dragEvent.dispatchEvent(this.element);
            let effectAllowed = dragEvent.effectAllowed;
            if (effectAllowed !== undefined)
                return dragEvent.effectAllowed;
            else
                return this.getAllowedTypesEffect(dataTransfer);
        }
        onDragEffectFunction(dataTransfer, func) {
            if (this.element.isDisabled)
                return [];
            return func(dataTransfer.getData(), dataTransfer);
        }
        onDrop(dataTransfer, dropEffect, x, y) {
            let done = false;
            if (this.drop)
                this.drop(this, dataTransfer.getData(), dropEffect, x, y, dataTransfer);
            let data = dataTransfer.getData();
            if (data instanceof Ui.DragNativeData && data.hasFiles()) {
                let files = data.getFiles();
                done = true;
                if (this.dropfile) {
                    for (let i = 0; i < files.length; i++)
                        done = done && this.dropfile(this, files[i], dropEffect, x, y);
                }
            }
        }
        onDragEnter(dataTransfer) {
            if (this.enter)
                this.enter(this, dataTransfer.getData());
        }
        onDragLeave() {
            if (this.leave)
                this.leave(this);
        }
    }
    Ui.DropableWatcher = DropableWatcher;
    class DropBox extends Ui.LBox {
        constructor(init) {
            super(init);
            this.drageffect = new Core.Events();
            this.dragentered = new Core.Events();
            this.dragleaved = new Core.Events();
            this.dropped = new Core.Events();
            this.droppedfile = new Core.Events();
            this.watchers = [];
            this.dragover.connect(e => this.onDragOver(e));
            if (init) {
                if (init.ondrageffect)
                    this.drageffect.connect(init.ondrageffect);
                if (init.ondragentered)
                    this.dragentered.connect(init.ondragentered);
                if (init.ondragleaved)
                    this.dragleaved.connect(init.ondragleaved);
                if (init.ondropped)
                    this.dropped.connect(init.ondropped);
                if (init.ondroppedfile)
                    this.droppedfile.connect(init.ondroppedfile);
            }
        }
        set ondrageffect(value) { this.drageffect.connect(value); }
        set ondragentered(value) { this.dragentered.connect(value); }
        set ondragleaved(value) { this.dragleaved.connect(value); }
        set ondropped(value) { this.dropped.connect(value); }
        set ondroppedfile(value) { this.droppedfile.connect(value); }
        addType(type, effects) {
            if (typeof (type) === 'string')
                type = type.toLowerCase();
            if (this.allowedTypes == undefined)
                this.allowedTypes = [];
            if (typeof (effects) === 'string')
                effects = [effects];
            if (typeof (effects) !== 'function') {
                for (let i = 0; i < effects.length; i++) {
                    let effect = effects[i];
                    if (typeof (effect) === 'string')
                        effect = { action: effect };
                    if (!('text' in effect)) {
                        if (effect.action === 'copy')
                            effect.text = 'Copier';
                        else if (effect.action === 'move')
                            effect.text = 'Déplacer';
                        else if (effect.action === 'link')
                            effect.text = 'Lier';
                        else
                            effect.text = effect.action;
                    }
                    if (!('dragicon' in effect))
                        effect.dragicon = 'drag' + effect.action;
                    effects[i] = effect;
                }
                this.allowedTypes.push({ type: type, effect: effects });
            }
            else
                this.allowedTypes.push({ type: type, effect: effects });
        }
        onDragOver(event) {
            if (!event.dataTransfer)
                return;
            let found = false;
            for (let i = 0; !found && (i < this.watchers.length); i++)
                found = (this.watchers[i].getDataTransfer() === event.dataTransfer);
            if (!found) {
                let effect = this.onDragEffect(event.dataTransfer);
                if ((effect !== undefined) && (effect.length > 0)) {
                    let watcher = event.dataTransfer.capture(this, effect);
                    this.watchers.push(watcher);
                    watcher.moved.connect((e) => this.onWatcherMove(e.target));
                    watcher.dropped.connect((e) => this.onWatcherDrop(e.target, e.effect, e.x, e.y));
                    watcher.leaved.connect((e) => this.onWatcherLeave(e.target));
                    event.stopImmediatePropagation();
                    this.onWatcherEnter(watcher);
                }
            }
            else
                event.stopImmediatePropagation();
        }
        onWatcherEnter(watcher) {
            this.onDragEnter(watcher.getDataTransfer());
        }
        onWatcherMove(watcher) {
        }
        onWatcherDrop(watcher, effect, x, y) {
            let point = this.pointFromWindow(new Ui.Point(x, y));
            this.onDrop(watcher.getDataTransfer(), effect, point.getX(), point.getY());
        }
        onWatcherLeave(watcher) {
            let found = false;
            let i = 0;
            for (; !found && (i < this.watchers.length); i++) {
                found = (this.watchers[i] === watcher);
            }
            i--;
            if (found)
                this.watchers.splice(i, 1);
            if (this.watchers.length === 0)
                this.onDragLeave();
        }
        getAllowedTypesEffect(dataTransfer) {
            if (this.allowedTypes !== undefined) {
                let data = dataTransfer.getData();
                let effect = undefined;
                for (let i = 0; (effect === undefined) && (i < this.allowedTypes.length); i++) {
                    let type = this.allowedTypes[i];
                    if (typeof (type.type) === 'string') {
                        if (type.type === 'all')
                            effect = type.effect;
                        else if (data instanceof Ui.DragNativeData) {
                            if ((type.type === 'files') && data.hasFiles())
                                effect = type.effect;
                            else if (((type.type === 'text') || (type.type === 'text/plain')) && data.hasTypes('text/plain', 'text'))
                                effect = type.effect;
                            else if (data.hasType(type.type))
                                effect = type.effect;
                        }
                    }
                    else if (data instanceof type.type)
                        effect = type.effect;
                }
                if (typeof (effect) === 'function') {
                    let effects = this.onDragEffectFunction(dataTransfer, effect);
                    for (let i = 0; i < effects.length; i++) {
                        let effect = effects[i];
                        if (typeof (effect) === 'string')
                            effect = { action: effect };
                        if (!('text' in effect)) {
                            if (effect.action === 'copy')
                                effect.text = 'Copier';
                            else if (effect.action === 'move')
                                effect.text = 'Déplacer';
                            else if (effect.action === 'link')
                                effect.text = 'Lier';
                            else if (effect.action === 'run')
                                effect.text = 'Exécuter';
                            else if (effect.action === 'play')
                                effect.text = 'Jouer';
                            else
                                effect.text = effect.action;
                        }
                        if (!('dragicon' in effect))
                            effect.dragicon = 'drag' + effect.action;
                        effects[i] = effect;
                    }
                    effect = effects;
                }
                if (effect === undefined)
                    effect = [];
                return effect;
            }
            else
                return [];
        }
        onDragEffect(dataTransfer) {
            let dragEvent = new Ui.DragEvent();
            dragEvent.setType('drageffect');
            dragEvent.setBubbles(false);
            dragEvent.dataTransfer = dataTransfer;
            dragEvent.dispatchEvent(this);
            let effectAllowed = dragEvent.effectAllowed;
            if (effectAllowed !== undefined)
                return dragEvent.effectAllowed;
            else
                return this.getAllowedTypesEffect(dataTransfer);
        }
        onDragEffectFunction(dataTransfer, func) {
            return func(dataTransfer.getData(), dataTransfer);
        }
        onDrop(dataTransfer, dropEffect, x, y) {
            this.dropped.fire({
                target: this,
                data: dataTransfer.getData(),
                effect: dropEffect,
                x: x, y: y,
                dataTransfer: dataTransfer
            });
            let data = dataTransfer.getData();
            if (data instanceof Ui.DragNativeData && data.hasFiles()) {
                let files = data.getFiles();
                for (let i = 0; i < files.length; i++)
                    this.droppedfile.fire({ target: this, file: files[i], effect: dropEffect, x: x, y: y });
            }
        }
        onDragEnter(dataTransfer) {
            this.dragentered.fire({ target: this, data: dataTransfer.getData() });
        }
        onDragLeave() {
            this.dragleaved.fire({ target: this });
        }
    }
    Ui.DropBox = DropBox;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class ButtonText extends Ui.CompactLabel {
    }
    Ui.ButtonText = ButtonText;
    class SimpleButtonBackground extends Ui.Element {
        constructor() {
            super();
            this.drawing.style.boxSizing = 'border-box';
            this.drawing.style.borderStyle = 'solid';
            this.border = 'black';
            this.background = 'white';
        }
        set borderWidth(borderWidth) {
            this.drawing.style.borderWidth = `${borderWidth}px`;
        }
        set border(border) {
            this.drawing.style.borderColor = Ui.Color.create(border).getCssRgba();
        }
        set radius(radius) {
            this.drawing.style.borderRadius = `${radius}px`;
        }
        set background(background) {
            this.drawing.style.backgroundColor = Ui.Color.create(background).getCssRgba();
        }
    }
    Ui.SimpleButtonBackground = SimpleButtonBackground;
    class ButtonBackground extends Ui.Element {
        constructor() {
            super();
            this.ripple = new Ui.RippleEffect(this);
            this.drawing.style.boxSizing = 'border-box';
            this.drawing.style.borderStyle = 'solid';
            this.drawing.style.overflow = 'hidden';
        }
        down(x, y) {
            this.ripple.down(x, y);
        }
        up() {
            this.ripple.up();
        }
        press(x, y) {
            this.ripple.press(x, y);
        }
        set borderWidth(borderWidth) {
            this.drawing.style.borderWidth = `${borderWidth}px`;
        }
        set border(border) {
            this.drawing.style.borderColor = Ui.Color.create(border).getCssRgba();
        }
        set radius(radius) {
            this.drawing.style.borderRadius = `${radius}px`;
        }
        set background(background) {
            let color = Ui.Color.create(background);
            this.drawing.style.backgroundColor = color.getCssRgba();
            if (color.getHsl().l > 0.7)
                this.ripple.fill = 'rgba(0,0,0,0.1)';
            else
                this.ripple.fill = 'rgba(255,255,255,0.3)';
        }
    }
    Ui.ButtonBackground = ButtonBackground;
    class ButtonBadge extends Ui.LBox {
        constructor() {
            super();
            this._bg = new Ui.Rectangle();
            this._label = new Ui.Label();
            this._label.fontWeight = 'bold';
            this.content = [
                this._bg, this._label.assign({ textAlign: 'center' })
            ];
            this.badgeColor = 'red';
            this.badgeTextColor = 'white';
        }
        set fontSize(value) {
            value = Math.round(value);
            this._label.fontSize = value;
            this._label.width = value;
            let margin = Math.round(value / 4);
            this._label.margin = margin;
            this._bg.radius = (value + margin * 2) / 2;
        }
        get badge() {
            return this._label.text;
        }
        set badge(badge) {
            this._label.text = badge;
        }
        set badgeColor(badgeColor) {
            this._badgeColor = Ui.Color.create(badgeColor);
            this._bg.fill = this._badgeColor;
        }
        set badgeTextColor(badgeTextColor) {
            this._badgeTextColor = Ui.Color.create(badgeTextColor);
            this._label.color = this._badgeTextColor;
        }
    }
    Ui.ButtonBadge = ButtonBadge;
    class ButtonIcon extends Ui.Icon {
    }
    Ui.ButtonIcon = ButtonIcon;
    class Button extends Ui.Pressable {
        constructor(init) {
            super(init);
            this._isActive = false;
            this.bg = new ButtonBackground();
            this.content = this.bg;
            this.mainBox = new Ui.HBox();
            this.mainBox.verticalAlign = 'center';
            this.mainBox.horizontalAlign = 'stretch';
            this.append(this.mainBox);
            this.buttonPartsBox = new Ui.Box();
            this.mainBox.append(this.buttonPartsBox, true);
            this._textBox = new Ui.LBox();
            this._iconBox = new Ui.LBox();
            this.downed.connect((e) => {
                if (this.background instanceof ButtonBackground) {
                    if (e.x != undefined && e.y != undefined) {
                        let p = this.pointFromWindow(new Ui.Point(e.x, e.y));
                        this.background.down(p.x, p.y);
                    }
                    else
                        this.background.down();
                }
            });
            this.upped.connect((e) => {
                if (this.background instanceof ButtonBackground)
                    this.background.up();
            });
            this.pressed.connect((e) => {
                if (this.background instanceof ButtonBackground) {
                    if (e.x != undefined && e.y != undefined) {
                        let p = this.pointFromWindow(new Ui.Point(e.x, e.y));
                        this.background.press(p.x, p.y);
                    }
                    else
                        this.background.press();
                }
            });
            this.focused.connect(() => this.updateColors());
            this.blurred.connect(() => this.updateColors());
            this.entered.connect(() => this.updateColors());
            this.leaved.connect(() => this.updateColors());
            if (init) {
                if (init.text !== undefined)
                    this.text = init.text;
                if (init.icon !== undefined)
                    this.icon = init.icon;
                if (init.background !== undefined)
                    this.background = init.background;
                if (init.marker !== undefined)
                    this.marker = init.marker;
                if (init.isActive !== undefined)
                    this.isActive = init.isActive;
                if (init.badge !== undefined)
                    this.badge = init.badge;
                if (init.orientation !== undefined)
                    this.orientation = init.orientation;
            }
        }
        get background() {
            return this.bg;
        }
        set background(bg) {
            this.remove(this.bg);
            if (bg === undefined)
                this.bg = new ButtonBackground();
            else
                this.bg = bg;
            this.prepend(this.bg);
            this.onStyleChange();
        }
        get textBox() {
            return this._textBox;
        }
        get text() {
            return (this._text instanceof ButtonText) ? this._text.text : undefined;
        }
        set text(text) {
            this.setTextOrElement(text);
        }
        setTextOrElement(text) {
            if (typeof (text) === 'string') {
                if (this._text !== undefined) {
                    if (this._text instanceof ButtonText)
                        this._text.text = text;
                    else {
                        this._text = new ButtonText();
                        this._text.text = text;
                        this._text.color = this.getForegroundColor();
                        this._textBox.content = this._text;
                    }
                }
                else {
                    this._text = new ButtonText();
                    this._text.text = text;
                    this._text.color = this.getForegroundColor();
                    this._textBox.content = this._text;
                }
            }
            else {
                this._text = text;
                if (this._text instanceof Ui.Element)
                    this._textBox.content = this._text;
                else if (this._text !== undefined) {
                    this._text = new ButtonText();
                    this._text.text = this._text.toString();
                    this._text.color = this.getForegroundColor();
                    this._textBox.content = this._text;
                }
            }
            this.updateVisibles();
        }
        get iconBox() {
            return this._iconBox;
        }
        get icon() {
            return (this._icon instanceof ButtonIcon) ? this._icon.icon : undefined;
        }
        set icon(icon) {
            this.setIconOrElement(icon);
        }
        setIconOrElement(icon) {
            if (typeof (icon) === 'string') {
                if (this._icon != undefined) {
                    if (this._icon instanceof ButtonIcon)
                        this._icon.icon = icon;
                    else {
                        let ic = new ButtonIcon();
                        this._icon = ic;
                        ic.icon = icon;
                        ic.fill = this.getForegroundColor();
                        this.iconBox.content = this._icon;
                        if (this._badgeContent)
                            this.iconBox.append(this._badgeContent);
                    }
                }
                else {
                    let ic = new ButtonIcon();
                    this._icon = ic;
                    ic.icon = icon;
                    ic.fill = this.getForegroundColor();
                    this._iconBox.content = this._icon;
                    if (this._badgeContent)
                        this.iconBox.append(this._badgeContent);
                }
            }
            else {
                this._icon = icon;
                this._iconBox.content = this._icon;
                if (this._badgeContent)
                    this.iconBox.append(this._badgeContent);
            }
            this.updateVisibles();
        }
        get marker() {
            return this._marker;
        }
        set marker(marker) {
            if (this._marker !== undefined)
                this.mainBox.remove(this._marker);
            this._marker = marker;
            if (marker instanceof Ui.Icon)
                marker.fill = this.getForegroundColor();
            if (this._marker)
                this.mainBox.append(this._marker);
        }
        get isActive() {
            return this._isActive;
        }
        set isActive(isActive) {
            if (this._isActive !== isActive) {
                this._isActive = isActive;
                this.updateColors();
            }
        }
        get badge() {
            return this._badge;
        }
        set badge(text) {
            this._badge = text;
            if (this._badge == undefined) {
                if (this._badgeContent) {
                    this.iconBox.remove(this._badgeContent);
                    this._badgeContent = undefined;
                }
            }
            else {
                if (!this._badgeContent) {
                    this._badgeContent = new ButtonBadge().assign({
                        verticalAlign: 'top', horizontalAlign: 'right',
                        fontSize: parseInt(this.getStyleProperty('iconSize')) * parseFloat(this.getStyleProperty('badgeRatio')),
                        badgeColor: this.getStyleProperty('badgeColor'),
                        badgeTextColor: this.getStyleProperty('badgeTextColor')
                    });
                    this.iconBox.append(this._badgeContent);
                }
                this._badgeContent.badge = text !== null && text !== void 0 ? text : '';
            }
        }
        get orientation() {
            if (this._orientation !== undefined)
                return this._orientation;
            else
                return this.getStyleProperty('orientation');
        }
        set orientation(orientation) {
            this._orientation = orientation;
            this.buttonPartsBox.orientation = this.orientation;
            this.updateVisibles();
        }
        getBackgroundColor() {
            let color;
            if (this._isActive) {
                if (this.hasFocus && !this.getIsMouseFocus())
                    color = Ui.Color.create(this.getStyleProperty('focusActiveBackground'));
                else
                    color = Ui.Color.create(this.getStyleProperty('activeBackground'));
            }
            else {
                if (this.hasFocus && !this.getIsMouseFocus())
                    color = Ui.Color.create(this.getStyleProperty('focusBackground'));
                else
                    color = Ui.Color.create(this.getStyleProperty('background'));
            }
            let yuv = color.getYuva();
            let deltaY = 0;
            if (this.isOver) {
                deltaY = 0.10;
                yuv.a = Math.max(0.2, yuv.a);
            }
            return Ui.Color.createFromYuv(yuv.y + deltaY, yuv.u, yuv.v, yuv.a);
        }
        getBackgroundBorderColor() {
            let color;
            if (this._isActive) {
                if (this.hasFocus && !this.getIsMouseFocus())
                    color = Ui.Color.create(this.getStyleProperty('focusActiveBackgroundBorder'));
                else
                    color = Ui.Color.create(this.getStyleProperty('activeBackgroundBorder'));
            }
            else {
                if (this.hasFocus && !this.getIsMouseFocus())
                    color = Ui.Color.create(this.getStyleProperty('focusBackgroundBorder'));
                else
                    color = Ui.Color.create(this.getStyleProperty('backgroundBorder'));
            }
            let yuv = color.getYuva();
            let deltaY = 0;
            if (this.isOver)
                deltaY = 0.20;
            return Ui.Color.createFromYuv(yuv.y + deltaY, yuv.u, yuv.v, yuv.a);
        }
        getForegroundColor() {
            let color;
            if (this._isActive) {
                if (this.hasFocus && !this.getIsMouseFocus())
                    color = Ui.Color.create(this.getStyleProperty('focusActiveForeground'));
                else
                    color = Ui.Color.create(this.getStyleProperty('activeForeground'));
            }
            else {
                if (this.hasFocus && !this.getIsMouseFocus())
                    color = Ui.Color.create(this.getStyleProperty('focusForeground'));
                else
                    color = Ui.Color.create(this.getStyleProperty('foreground'));
            }
            let deltaY = 0;
            if (this.isOver)
                deltaY = 0.20;
            let yuv = color.getYuva();
            return Ui.Color.createFromYuv(yuv.y + deltaY, yuv.u, yuv.v, yuv.a);
        }
        get isTextVisible() {
            return ((this._text !== undefined) && (this.getStyleProperty('showText') || (this._icon === undefined)));
        }
        get isIconVisible() {
            return ((this._icon !== undefined) && (this.getStyleProperty('showIcon') || (this._text === undefined)));
        }
        updateVisibles() {
            if (this.isTextVisible) {
                if (this._textBox.parent == undefined)
                    this.buttonPartsBox.append(this._textBox, true);
                if (this._text instanceof ButtonText) {
                    let textAlign = this.getStyleProperty('textAlign');
                    if (textAlign == 'auto') {
                        if (this.isIconVisible && (this.orientation === 'horizontal'))
                            this._text.textAlign = 'left';
                        else
                            this._text.textAlign = 'center';
                    }
                    else
                        this._text.textAlign = textAlign;
                    this._text.fontFamily = this.getStyleProperty('fontFamily');
                    this._text.fontSize = this.getStyleProperty('fontSize');
                    this._text.fontWeight = this.getStyleProperty('fontWeight');
                    this._text.maxLine = this.getStyleProperty('maxLine');
                    this._text.whiteSpace = this.getStyleProperty('whiteSpace');
                    this._text.interLine = this.getStyleProperty('interLine');
                    this._text.textTransform = this.getStyleProperty('textTransform');
                }
            }
            else if (this._textBox.parent != undefined)
                this.buttonPartsBox.remove(this._textBox);
            if (this.isIconVisible) {
                this._iconBox.resizable = !this.isTextVisible;
                if (this._iconBox.parent == undefined)
                    this.buttonPartsBox.prepend(this._iconBox);
            }
            else if (this._iconBox.parent != undefined)
                this.buttonPartsBox.remove(this._iconBox);
            if (this.orientation === 'horizontal') {
                if (this.isTextVisible)
                    this._text.verticalAlign = 'center';
            }
            else {
                if (this.isIconVisible && this.isTextVisible)
                    this._text.verticalAlign = 'top';
                else if (this.isTextVisible)
                    this._text.verticalAlign = 'center';
            }
        }
        updateColors() {
            let fg = this.getForegroundColor();
            if (this.bg instanceof ButtonBackground) {
                this.bg.background = this.getBackgroundColor();
                this.bg.border = this.getBackgroundBorderColor();
            }
            if (this._text instanceof ButtonText)
                this._text.color = fg;
            if (this._icon instanceof ButtonIcon)
                this._icon.fill = fg;
            if (this._badgeContent) {
                this._badgeContent.badgeColor = this.getStyleProperty('badgeColor');
                this._badgeContent.badgeTextColor = this.getStyleProperty('badgeTextColor');
            }
            if (this._marker && this._marker instanceof Ui.Icon)
                this._marker.fill = fg;
        }
        onDisable() {
            super.onDisable();
            this.bg.opacity = 0.2;
        }
        onEnable() {
            super.onEnable();
            this.bg.opacity = 1;
        }
        onStyleChange() {
            this.buttonPartsBox.spacing = Math.max(0, this.getStyleProperty('spacing'));
            this.buttonPartsBox.margin = Math.max(0, this.getStyleProperty('padding'));
            if (this.bg instanceof ButtonBackground) {
                this.bg.radius = this.getStyleProperty('radius');
                this.bg.borderWidth = this.getStyleProperty('borderWidth');
            }
            let iconSize = Math.max(0, this.getStyleProperty('iconSize'));
            this._iconBox.width = iconSize;
            this._iconBox.height = iconSize;
            this._textBox.width = this.getStyleProperty('textWidth');
            this._textBox.maxWidth = this.getStyleProperty('maxTextWidth');
            this._textBox.height = this.getStyleProperty('textHeight');
            this.buttonPartsBox.orientation = this.orientation;
            this.updateVisibles();
            this.updateColors();
        }
    }
    Button.style = {
        orientation: 'horizontal',
        borderWidth: 1,
        badgeColor: 'red',
        badgeTextColor: 'white',
        background: 'rgba(250,250,250,1)',
        backgroundBorder: 'rgba(140,140,140,1)',
        foreground: '#444444',
        activeBackground: 'rgba(250,250,250,1)',
        activeBackgroundBorder: 'rgba(140,140,140,1)',
        activeForeground: '#dc6c36',
        focusBackground: '#07a0e5',
        focusBackgroundBorder: new Ui.Color(0.04, 0.43, 0.5),
        focusForeground: 'rgba(250,250,250,1)',
        focusActiveBackground: 'rgb(33,211,255)',
        focusActiveBackgroundBorder: new Ui.Color(0.04, 0.43, 0.5),
        focusActiveForeground: 'white',
        radius: 3,
        spacing: 10,
        padding: 8,
        iconSize: 18,
        badgeRatio: 0.25,
        fontSize: 14,
        fontFamily: 'Sans-serif',
        fontWeight: 'normal',
        textWidth: 70,
        textTransform: 'none',
        maxTextWidth: Number.MAX_VALUE,
        textHeight: 18,
        textAlign: 'auto',
        interLine: 1,
        maxLine: 3,
        whiteSpace: 'nowrap',
        showText: true,
        showIcon: true
    };
    Ui.Button = Button;
    class DefaultButton extends Button {
    }
    DefaultButton.style = {
        borderWidth: 1,
        background: '#444444',
        backgroundBorder: '#444444',
        foreground: 'rgba(250,250,250,1)'
    };
    Ui.DefaultButton = DefaultButton;
    class FlatButton extends Button {
        onDisable() {
            super.onDisable();
            this.buttonPartsBox.opacity = 0.5;
        }
        onEnable() {
            super.onEnable();
            this.buttonPartsBox.opacity = 1;
        }
    }
    FlatButton.style = {
        borderWidth: 1,
        background: 'rgba(250,250,250,0)',
        backgroundBorder: 'rgba(140,140,140,0)',
        activeBackground: 'rgba(250,250,250,0)',
        activeBackgroundBorder: 'rgba(140,140,140,0)'
    };
    Ui.FlatButton = FlatButton;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class ToggleButton extends Ui.Button {
        constructor() {
            super();
            this._isToggled = false;
            this.toggled = new Core.Events();
            this.untoggled = new Core.Events();
            this.role = 'checkbox';
            this.drawing.setAttribute('aria-checked', 'false');
            this.pressed.connect(() => this.onToggleButtonPress());
        }
        set ontoggled(value) { this.toggled.connect(value); }
        set onuntoggled(value) { this.untoggled.connect(value); }
        get isToggled() {
            return this._isToggled;
        }
        set isToggled(value) {
            if (value)
                this.onToggle();
            else
                this.onUntoggle();
        }
        onToggleButtonPress() {
            if (!this.isToggled)
                this.onToggle();
            else
                this.onUntoggle();
        }
        onToggle() {
            if (!this.isToggled) {
                this._isToggled = true;
                this.isActive = true;
                this.drawing.setAttribute('aria-checked', 'true');
                this.toggled.fire({ target: this });
            }
        }
        onUntoggle() {
            if (this.isToggled) {
                this._isToggled = false;
                this.isActive = false;
                this.drawing.setAttribute('aria-checked', 'false');
                this.untoggled.fire({ target: this });
            }
        }
        toggle() {
            this.onToggle();
        }
        untoggle() {
            this.onUntoggle();
        }
    }
    Ui.ToggleButton = ToggleButton;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class ActionButton extends Ui.Button {
        constructor(init) {
            super(init);
            this.pressed.connect(() => this.onActionButtonDrop());
            new Ui.DropableWatcher({
                element: this,
                ondropped: () => this.onActionButtonDrop(),
                types: [
                    {
                        type: 'all',
                        effects: (data, dataTransfer) => this.onActionButtonEffect(data, dataTransfer)
                    }
                ]
            });
            if (init) {
                if (init.action !== undefined)
                    this.action = init.action;
                if (init.selection !== undefined)
                    this.selection = init.selection;
            }
        }
        set action(action) {
            this._action = action;
        }
        set selection(selection) {
            this._selection = selection;
        }
        onActionButtonEffect(data, dataTransfer) {
            if ('draggable' in dataTransfer) {
                let elements = this._selection.elements;
                let found;
                for (let i = 0; (found === undefined) && (i < elements.length); i++) {
                    if (elements[i] === dataTransfer.draggable)
                        found = elements[i];
                }
                if (found !== undefined)
                    return [{ action: 'run' }];
            }
            return [];
        }
        onActionButtonDrop() {
            let scope = this;
            if ('scope' in this._action)
                scope = this._action.scope;
            this._action.callback.call(scope, this._selection);
            this._selection.clear();
            return false;
        }
    }
    ActionButton.style = {
        textTransform: 'uppercase',
        radius: 0,
        borderWidth: 0,
        foreground: 'rgba(250,250,250,1)',
        background: 'rgba(60,60,60,0)',
        backgroundBorder: 'rgba(60,60,60,0)',
        focusColor: '#f6caa2'
    };
    Ui.ActionButton = ActionButton;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class ContextBarCloseButton extends Ui.Button {
        constructor() {
            super();
        }
    }
    ContextBarCloseButton.style = {
        textWidth: 5,
        radius: 0,
        borderWidth: 0,
        foreground: 'rgba(250,250,250,1)',
        background: 'rgba(60,60,60,0)'
    };
    Ui.ContextBarCloseButton = ContextBarCloseButton;
    class ContextBar extends Ui.LBox {
        constructor(init) {
            super(init);
            this.onSelectionChange = () => {
                this.closeButton.text = this._selection.elements.length.toString();
                let actions = this._selection.getActions();
                this.actionsBox.clear();
                this.actionsBox.append(new Ui.Element(), true);
                for (let actionName in actions) {
                    let action = actions[actionName];
                    if (action.hidden === true)
                        continue;
                    let button = new Ui.ActionButton();
                    button.icon = action.icon;
                    button.text = action.text;
                    button.action = action;
                    button.selection = this._selection;
                    this.actionsBox.append(button);
                }
            };
            this.bg = new Ui.Rectangle();
            this.append(this.bg);
            let hbox = new Ui.HBox();
            hbox.spacing = 5;
            this.append(hbox);
            this.closeButton = new Ui.ContextBarCloseButton();
            this.closeButton.icon = 'backarrow';
            hbox.append(this.closeButton);
            this.closeButton.pressed.connect(() => this.onClosePress());
            let scroll = new Ui.ScrollingArea();
            hbox.append(scroll, true);
            this.actionsBox = new Ui.HBox();
            this.actionsBox.spacing = 5;
            scroll.content = this.actionsBox;
            if (init) {
                if (init.selection !== undefined)
                    this.selection = init.selection;
            }
        }
        get selection() {
            return this._selection;
        }
        set selection(selection) {
            if (this._selection != undefined)
                this._selection.changed.disconnect(this.onSelectionChange);
            this._selection = selection;
            if (this._selection != undefined)
                this._selection.changed.connect(this.onSelectionChange);
        }
        onClosePress() {
            this._selection.clear();
        }
        onStyleChange() {
            this.bg.fill = this.getStyleProperty('background');
        }
    }
    ContextBar.style = {
        background: '#07a0e5'
    };
    Ui.ContextBar = ContextBar;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Popup extends Ui.Container {
        constructor(init) {
            super(init);
            this.posX = undefined;
            this.posY = undefined;
            this.attachedElement = undefined;
            this.attachedBorder = undefined;
            this._modal = true;
            this._autoClose = true;
            this._preferredWidth = undefined;
            this._preferredHeight = undefined;
            this.openClock = undefined;
            this.isClosed = true;
            this.closed = new Core.Events();
            this.horizontalAlign = 'stretch';
            this.verticalAlign = 'stretch';
            this.popupSelection = new Ui.Selection();
            this.shadow = new Ui.Pressable();
            this.shadow.focusable = false;
            this.shadow.drawing.style.cursor = 'inherit';
            this.appendChild(this.shadow);
            this.background = new PopupBackground();
            this.background.radius = 0;
            this.background.fill = '#f8f8f8';
            this.background.setTransformOrigin(0, 0);
            this.appendChild(this.background);
            this.contentBox = new Ui.LBox();
            this.contentBox.margin = 2;
            this.contentBox.width = 30;
            this.contentBox.height = 30;
            this.contentBox.setTransformOrigin(0, 0);
            this.appendChild(this.contentBox);
            this.scroll = new Ui.ScrollingArea();
            this.scroll.drawing.style.overflow = 'hidden';
            this.contentBox.append(this.scroll);
            this.contextBox = new Ui.ContextBar();
            this.contextBox.selection = this.popupSelection;
            this.contextBox.verticalAlign = 'top';
            this.contextBox.hide(true);
            this.contentBox.append(this.contextBox);
            this.popupSelection.changed.connect((e) => this.onPopupSelectionChange(e.target));
            this.shadow.pressed.connect((e) => this.onShadowPress());
            if (init) {
                if (init.preferredWidth !== undefined)
                    this.preferredWidth = init.preferredWidth;
                if (init.preferredHeight !== undefined)
                    this.preferredHeight = init.preferredHeight;
                if (init.autoClose !== undefined)
                    this.autoClose = init.autoClose;
                if (init.content !== undefined)
                    this.content = init.content;
            }
        }
        set onclosed(value) { this.closed.connect(value); }
        get modal() {
            return this._modal;
        }
        set modal(value) {
            if (this._modal != value) {
                this._modal = value;
                this.shadow.opacity = value ? 1 : 0.01;
            }
        }
        set preferredWidth(width) {
            this._preferredWidth = width;
            this.invalidateMeasure();
        }
        set preferredHeight(height) {
            this._preferredHeight = height;
            this.invalidateMeasure();
        }
        getSelectionHandler() {
            return this.popupSelection;
        }
        set autoClose(autoClose) {
            this._autoClose = autoClose;
        }
        get content() {
            return this.scroll.content;
        }
        set content(content) {
            this.scroll.content = content;
        }
        onShadowPress() {
            if (this._autoClose)
                this.close();
        }
        onOpenTick(clock, progress, delta) {
            let end = (progress >= 1);
            if (this.isClosed)
                progress = 1 - progress;
            this.opacity = progress;
            let arrowBorder = this.background.arrowBorder;
            if (arrowBorder === 'right') {
                this.background.transform = Ui.Matrix.createTranslate(20 * (1 - progress), 0);
                this.contentBox.transform = Ui.Matrix.createTranslate(20 * (1 - progress), 0);
            }
            else if (arrowBorder === 'left') {
                this.background.transform = Ui.Matrix.createTranslate(-20 * (1 - progress), 0);
                this.contentBox.transform = Ui.Matrix.createTranslate(-20 * (1 - progress), 0);
            }
            else if ((arrowBorder === 'top') || (arrowBorder === 'none')) {
                this.background.transform = Ui.Matrix.createTranslate(0, -20 * (1 - progress));
                this.contentBox.transform = Ui.Matrix.createTranslate(0, -20 * (1 - progress));
            }
            else if (arrowBorder === 'bottom') {
                this.background.transform = Ui.Matrix.createTranslate(0, 20 * (1 - progress));
                this.contentBox.transform = Ui.Matrix.createTranslate(0, 20 * (1 - progress));
            }
            if (end) {
                if (this.openClock) {
                    this.openClock.stop();
                    this.openClock = undefined;
                }
                if (this.isClosed) {
                    Ui.App.removeDialog(this);
                    this.enable();
                }
            }
        }
        onPopupSelectionChange(selection) {
            if (selection.elements.length === 0)
                this.contextBox.hide(true);
            else
                this.contextBox.show();
        }
        onStyleChange() {
            this.background.fill = this.getStyleProperty('background');
            this.shadow.drawing.style.backgroundColor = Ui.Color.create(this.getStyleProperty('shadow')).getCssRgba();
            let radius = this.getStyleProperty('radius');
            this.background.radius = radius;
            this.scroll.drawing.style.borderRadius = `${radius}px`;
        }
        open() {
            this.openPosOrElement();
        }
        openAt(posX, posY) {
            this.openPosOrElement(posX, posY);
        }
        openElement(element, position) {
            this.openPosOrElement(element, position);
        }
        openPosOrElement(posX, posY) {
            if (this.isClosed) {
                Ui.App.appendDialog(this, this.modal);
                this.isClosed = false;
                this.attachedElement = undefined;
                this.posX = undefined;
                this.posY = undefined;
                if ((typeof (posX) == 'object') && (posX instanceof Ui.Element)) {
                    this.attachedElement = posX;
                    if ((posY !== undefined) && (typeof (posY) === 'string'))
                        this.attachedBorder = posY;
                    let point = this.attachedElement.pointToWindow(new Ui.Point(this.attachedElement.layoutWidth, this.attachedElement.layoutHeight / 2));
                    this.posX = point.x;
                    this.posY = point.y;
                }
                else if ((posX !== undefined) && (posY !== undefined)) {
                    this.posX = posX;
                    this.posY = posY;
                }
                else {
                    this.posX = undefined;
                    this.posY = undefined;
                }
                if (this.openClock === undefined) {
                    this.openClock = new Anim.Clock({
                        duration: 1, target: this, speed: 5,
                        ease: new Anim.PowerEase({ mode: 'out' })
                    });
                    this.openClock.timeupdate.connect((e) => this.onOpenTick(e.target, e.progress, e.deltaTick));
                    this.opacity = 0;
                }
                this.invalidateArrange();
            }
        }
        close() {
            if (!this.isClosed) {
                this.isClosed = true;
                this.closed.fire({ target: this });
                this.disable();
                if (this.openClock === undefined) {
                    this.openClock = new Anim.Clock({
                        duration: 1, target: this, speed: 5,
                        ease: new Anim.PowerEase({ mode: 'out' })
                    });
                    this.openClock.timeupdate.connect((e) => this.onOpenTick(e.target, e.progress, e.deltaTick));
                    this.openClock.begin();
                }
            }
        }
        invalidateArrange() {
            super.invalidateArrange();
            this.invalidateLayout();
        }
        invalidateMeasure() {
            super.invalidateMeasure();
            this.invalidateLayout();
        }
        measureCore(width, height) {
            let constraintWidth = Math.max(width - 40, 0);
            let constraintHeight = Math.max(height - 40, 0);
            if ((this._preferredWidth !== undefined) && (this._preferredWidth < constraintWidth))
                constraintWidth = this._preferredWidth;
            if ((this._preferredHeight !== undefined) && (this._preferredHeight < constraintHeight))
                constraintHeight = this._preferredHeight;
            this.background.measure(constraintWidth, constraintHeight);
            let size = this.contentBox.measure(constraintWidth, constraintHeight);
            size.width = Math.min(this._preferredWidth ? Math.max(size.width, this._preferredWidth) : size.width, width);
            size.height = Math.min(this._preferredHeight ? Math.max(size.height, this._preferredHeight) : size.height, height);
            if ((this.posX !== undefined) || (this.attachedElement !== undefined))
                return { width: Math.max(50, size.width), height: Math.max(50, size.height) };
            else
                return { width: Math.max(width, size.width + 40), height: Math.max(height, size.height + 40) };
        }
        arrangeCore(width, height) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            if ((this.openClock !== undefined) && !this.openClock.isActive)
                this.openClock.begin();
            let x = 0;
            let y = 0;
            let point;
            let borders;
            let border;
            let i;
            this.shadow.arrange(0, 0, width, height);
            let usedWidth = Math.min(this._preferredWidth ? Math.max(this.contentBox.measureWidth, this._preferredWidth) : this.contentBox.measureWidth, width);
            let usedHeight = Math.min(this._preferredHeight ? Math.max(this.contentBox.measureHeight, this._preferredHeight) : this.contentBox.measureHeight, height);
            if (((this.posX === undefined) && (this.attachedElement === undefined)) || (width < 150) || (height < 150)) {
                this.setCenter(width, height);
            }
            else if (this.attachedElement !== undefined) {
                borders = ['right', 'left', 'top', 'bottom', 'center'];
                if (this.attachedBorder !== undefined)
                    borders.unshift(this.attachedBorder);
                for (i = 0; i < borders.length; i++) {
                    border = borders[i];
                    if (border === 'left') {
                        point = this.attachedElement.pointToWindow(new Ui.Point(0, this.attachedElement.layoutHeight / 2));
                        if (usedWidth + 10 < point.x) {
                            this.setLeft(point.x, point.y, width, height);
                            break;
                        }
                    }
                    else if (border === 'right') {
                        point = this.attachedElement.pointToWindow(new Ui.Point(this.attachedElement.layoutWidth, this.attachedElement.layoutHeight / 2));
                        if (usedWidth + point.x + 10 < width) {
                            this.setRight(point.x, point.y, width, height);
                            break;
                        }
                    }
                    else if (border === 'top') {
                        point = this.attachedElement.pointToWindow(new Ui.Point(this.attachedElement.layoutWidth / 2, 0));
                        if (usedHeight + 10 < point.y) {
                            this.setTop(point.x, point.y, width, height);
                            break;
                        }
                    }
                    else if (border === 'bottom') {
                        point = this.attachedElement.pointToWindow(new Ui.Point(this.attachedElement.layoutWidth / 2, this.attachedElement.layoutHeight));
                        if (usedHeight + 10 + point.y < height) {
                            this.setBottom(point.x, point.y, width, height);
                            break;
                        }
                    }
                    else {
                        this.setCenter(width, height);
                        break;
                    }
                }
            }
            else {
                borders = ['right', 'left', 'top', 'bottom', 'center'];
                if (this.attachedBorder !== undefined)
                    borders.unshift(this.attachedBorder);
                for (i = 0; i < borders.length; i++) {
                    border = borders[i];
                    if (border === 'left') {
                        if (usedWidth + 10 < ((_a = this.posX) !== null && _a !== void 0 ? _a : 0)) {
                            this.setLeft((_b = this.posX) !== null && _b !== void 0 ? _b : 0, (_c = this.posY) !== null && _c !== void 0 ? _c : 0, width, height);
                            break;
                        }
                    }
                    else if (border === 'right') {
                        if (usedWidth + ((_d = this.posX) !== null && _d !== void 0 ? _d : 0) + 10 < width) {
                            this.setRight((_e = this.posX) !== null && _e !== void 0 ? _e : 0, (_f = this.posY) !== null && _f !== void 0 ? _f : 0, width, height);
                            break;
                        }
                    }
                    else if (border === 'top') {
                        if (usedHeight + 10 < ((_g = this.posY) !== null && _g !== void 0 ? _g : 0)) {
                            this.setTop((_h = this.posX) !== null && _h !== void 0 ? _h : 0, (_j = this.posY) !== null && _j !== void 0 ? _j : 0, width, height);
                            break;
                        }
                    }
                    else if (border === 'bottom') {
                        if (usedHeight + 10 + ((_k = this.posY) !== null && _k !== void 0 ? _k : 0) < height) {
                            this.setBottom((_l = this.posX) !== null && _l !== void 0 ? _l : 0, (_m = this.posY) !== null && _m !== void 0 ? _m : 0, width, height);
                            break;
                        }
                    }
                    else {
                        this.setCenter(width, height);
                        break;
                    }
                }
            }
        }
        setRight(x, y, width, height) {
            let usedWidth = Math.min(this._preferredWidth ? Math.max(this.contentBox.measureWidth, this._preferredWidth) : this.contentBox.measureWidth, width - 40);
            let usedHeight = Math.min(this._preferredHeight ? Math.max(this.contentBox.measureHeight, this._preferredHeight) : this.contentBox.measureHeight, height - 40);
            let ofs = Math.max(10, Math.min(30, usedHeight / 2));
            let px = x + 10;
            let py = y - ofs;
            this.background.arrowBorder = 'left';
            if (py + usedHeight > height) {
                py = height - usedHeight;
                let offset = y - py;
                if (offset > usedHeight - 18)
                    offset = usedHeight - 18;
                this.background.arrowOffset = offset;
            }
            else
                this.background.arrowOffset = ofs;
            this.background.arrange(px - 10, py, usedWidth + 10, usedHeight);
            this.contentBox.arrange(px, py, usedWidth, usedHeight);
        }
        setLeft(x, y, width, height) {
            let usedWidth = Math.min(this._preferredWidth ? Math.max(this.contentBox.measureWidth, this._preferredWidth) : this.contentBox.measureWidth, width - 40);
            let usedHeight = Math.min(this._preferredHeight ? Math.max(this.contentBox.measureHeight, this._preferredHeight) : this.contentBox.measureHeight, height - 40);
            let ofs = Math.max(10, Math.min(30, usedHeight / 2));
            let px = x - (10 + usedWidth);
            let py = y - ofs;
            this.background.arrowBorder = 'right';
            if (py + usedHeight > height) {
                py = height - usedHeight;
                let offset = y - py;
                if (offset > usedHeight - 18)
                    offset = usedHeight - 18;
                this.background.arrowOffset = offset;
            }
            else
                this.background.arrowOffset = ofs;
            this.background.arrange(px, py, usedWidth + 10, usedHeight);
            this.contentBox.arrange(px, py, usedWidth, usedHeight);
        }
        setTop(x, y, width, height) {
            let usedWidth = Math.min(this._preferredWidth ? Math.max(this.contentBox.measureWidth, this._preferredWidth) : this.contentBox.measureWidth, width - 40);
            let usedHeight = Math.min(this._preferredHeight ? Math.max(this.contentBox.measureHeight, this._preferredHeight) : this.contentBox.measureHeight, height - 40);
            let py = y - usedHeight;
            let px = x - 30;
            this.background.arrowBorder = 'bottom';
            if (px + usedWidth > width) {
                px = width - usedWidth;
                let offset = x - px;
                if (offset > usedWidth - 18)
                    offset = usedWidth - 18;
                this.background.arrowOffset = offset;
            }
            else if (px < 2) {
                this.background.arrowOffset = x + 2;
                px = 2;
            }
            else
                this.background.arrowOffset = 30;
            this.background.arrange(px, py - 10, usedWidth, usedHeight + 10);
            this.contentBox.arrange(px, py - 10, usedWidth, usedHeight);
        }
        setBottom(x, y, width, height) {
            let usedWidth = Math.min(this._preferredWidth ? Math.max(this.contentBox.measureWidth, this._preferredWidth) : this.contentBox.measureWidth, width - 40);
            let usedHeight = Math.min(this._preferredHeight ? Math.max(this.contentBox.measureHeight, this._preferredHeight) : this.contentBox.measureHeight, height - 40);
            let py = y + 10;
            let px = x - 30;
            this.background.arrowBorder = 'top';
            if (px + usedWidth > width) {
                px = width - usedWidth;
                let offset = x - px;
                if (offset > usedWidth - 18)
                    offset = usedWidth - 18;
                this.background.arrowOffset = offset;
            }
            else if (px < 2) {
                this.background.arrowOffset = x + 2;
                px = 2;
            }
            else
                this.background.arrowOffset = 30;
            this.background.arrange(px, py - 10, usedWidth, usedHeight + 10);
            this.contentBox.arrange(px, py, usedWidth, usedHeight);
        }
        setCenter(width, height) {
            this.background.arrowBorder = 'none';
            let usedWidth = Math.min(this._preferredWidth ? Math.max(this.contentBox.measureWidth, this._preferredWidth) : this.contentBox.measureWidth, width - 40);
            let usedHeight = Math.min(this._preferredHeight ? Math.max(this.contentBox.measureHeight, this._preferredHeight) : this.contentBox.measureHeight, height - 40);
            let x = (width - usedWidth) / 2;
            let y = (height - usedHeight) / 2;
            this.background.arrange(x, y, usedWidth, usedHeight);
            this.contentBox.arrange(x, y, usedWidth, usedHeight);
        }
    }
    Popup.style = {
        background: '#f8f8f8',
        shadow: 'rgba(0,0,0,0.15)',
        radius: 5
    };
    Ui.Popup = Popup;
    class PopupBackground extends Ui.CanvasElement {
        constructor() {
            super();
            this._radius = 8;
            this._arrowBorder = 'left';
            this._arrowOffset = 30;
            this.arrowSize = 10;
            this.fill = 'black';
        }
        get arrowBorder() {
            return this._arrowBorder;
        }
        set arrowBorder(arrowBorder) {
            if (this._arrowBorder != arrowBorder) {
                this._arrowBorder = arrowBorder;
                this.invalidateArrange();
            }
        }
        get arrowOffset() {
            return this._arrowOffset;
        }
        set arrowOffset(offset) {
            if (this._arrowOffset != offset) {
                this._arrowOffset = offset;
                this.invalidateArrange();
            }
        }
        set radius(radius) {
            if (this._radius != radius) {
                this._radius = radius;
                this.invalidateArrange();
            }
        }
        set fill(fill) {
            if (this._fill != fill) {
                this._fill = Ui.Color.create(fill);
                this.invalidateDraw();
            }
        }
        genPath(width, height, radius, arrowBorder, arrowSize, arrowOffset) {
            let v1;
            let v2;
            if (arrowBorder == 'none') {
                v1 = width - radius;
                v2 = height - radius;
                return 'M' + radius + ',0 L' + v1 + ',0 Q' + width + ',0 ' + width + ',' + radius + ' L' + width + ',' + v2 + ' Q' + width + ',' + height + ' ' + v1 + ',' + height + ' L' + radius + ',' + height + ' Q0,' + height + ' 0,' + v2 + ' L0,' + radius + ' Q0,0 ' + radius + ',0 z';
            }
            else if (arrowBorder == 'left') {
                v1 = width - this._radius;
                v2 = height - this._radius;
                return 'M' + (radius + arrowSize) + ',0 L' + v1 + ',0 Q' + width + ',0 ' + width + ',' + radius + ' L' + width + ',' + v2 + ' Q' + width + ',' + height + ' ' + v1 + ',' + height + ' L' + (radius + arrowSize) + ',' + height + ' Q' + arrowSize + ',' + height + ' ' + arrowSize + ',' + v2 + ' L' + arrowSize + ',' + (arrowOffset + arrowSize) + ' L0,' + arrowOffset + ' L' + arrowSize + ',' + (arrowOffset - arrowSize) + ' L' + arrowSize + ',' + radius + ' Q' + arrowSize + ',0 ' + (radius + arrowSize) + ',0 z';
            }
            else if (arrowBorder == 'right') {
                v1 = width - (this._radius + arrowSize);
                v2 = height - this._radius;
                return 'M' + radius + ',0 L' + v1 + ',0 Q' + (width - arrowSize) + ',0 ' + (width - arrowSize) + ',' + radius + ' L' + (width - arrowSize) + ',' + (arrowOffset - arrowSize) + ' L' + width + ',' + arrowOffset + ' L' + (width - arrowSize) + ',' + (arrowOffset + arrowSize) + ' L ' + (width - arrowSize) + ',' + v2 + ' Q' + (width - arrowSize) + ',' + height + ' ' + v1 + ',' + height + ' L' + radius + ',' + height + ' Q0,' + height + ' 0,' + v2 + ' L0,' + radius + ' Q0,0 ' + radius + ',0 z';
            }
            else if (arrowBorder == 'top') {
                v1 = width - this._radius;
                v2 = height - this._radius;
                return 'M' + radius + ',' + arrowSize + ' L' + (arrowOffset - arrowSize) + ',' + arrowSize + ' L' + arrowOffset + ',0 L' + (arrowOffset + arrowSize) + ',' + arrowSize + ' L' + v1 + ',' + arrowSize + ' Q' + width + ',' + arrowSize + ' ' + width + ',' + (arrowSize + radius) + ' L' + width + ',' + v2 + ' Q' + width + ',' + height + ' ' + v1 + ',' + height + ' L' + radius + ',' + height + ' Q0,' + height + ' 0,' + v2 + ' L0,' + (arrowSize + radius) + ' Q0,' + arrowSize + ' ' + radius + ',' + arrowSize + ' z';
            }
            else if (arrowBorder == 'bottom') {
                v1 = width - this._radius;
                v2 = height - (this._radius + arrowSize);
                return 'M' + radius + ',0 L' + v1 + ',0 Q' + width + ',0 ' + width + ',' + radius + ' L' + width + ',' + v2 + ' Q' + width + ',' + (height - arrowSize) + ' ' + v1 + ',' + (height - arrowSize) + ' L ' + (arrowOffset + arrowSize) + ',' + (height - arrowSize) + ' L' + arrowOffset + ',' + height + ' L' + (arrowOffset - arrowSize) + ',' + (height - arrowSize) + ' L' + radius + ',' + (height - arrowSize) + ' Q0,' + (height - arrowSize) + ' 0,' + v2 + ' L0,' + radius + ' Q0,0 ' + radius + ',0 z';
            }
        }
        updateCanvas(ctx) {
            let width = this.layoutWidth;
            let height = this.layoutHeight;
            if (this.arrowBorder == 'none') {
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.beginPath();
                ctx.roundRect(0, 0, width, height, this._radius, this._radius, this._radius, this._radius, false);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.roundRect(1, 1, width - 2, height - 2, this._radius, this._radius, this._radius, this._radius, false);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = this._fill.getCssRgba();
                ctx.beginPath();
                ctx.roundRect(2, 2, width - 4, height - 4, this._radius, this._radius, this._radius, this._radius, false);
                ctx.closePath();
                ctx.fill();
            }
            else {
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.svgPath(this.genPath(width, height, this._radius + 2, this.arrowBorder, this.arrowSize, this._arrowOffset));
                ctx.fill();
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.translate(1, 1);
                ctx.svgPath(this.genPath(width - 2, height - 2, Math.max(0, this._radius + 1), this.arrowBorder, this.arrowSize, this._arrowOffset - 1));
                ctx.fill();
                ctx.restore();
                ctx.fillStyle = this._fill.getCssRgba();
                ctx.translate(2, 2);
                ctx.svgPath(this.genPath(width - 4, height - 4, Math.max(0, this._radius), this.arrowBorder, this.arrowSize, this._arrowOffset - 2));
                ctx.fill();
            }
        }
    }
    Ui.PopupBackground = PopupBackground;
    class MenuPopup extends Popup {
        constructor(init) {
            super(init);
        }
    }
    Ui.MenuPopup = MenuPopup;
    class MenuPopupSeparator extends Ui.Separator {
        constructor() {
            super();
        }
    }
    Ui.MenuPopupSeparator = MenuPopupSeparator;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class MenuToolBarPopup extends Ui.MenuPopup {
    }
    Ui.MenuToolBarPopup = MenuToolBarPopup;
    class MenuToolBarButton extends Ui.Button {
        constructor() {
            super();
            this.icon = 'burger';
        }
    }
    MenuToolBarButton.style = {
        backgroundBorder: 'rgba(140,140,140,0)'
    };
    Ui.MenuToolBarButton = MenuToolBarButton;
    class MenuToolBar extends Ui.Container {
        constructor(init) {
            super(init);
            this._paddingTop = 0;
            this._paddingBottom = 0;
            this._paddingLeft = 0;
            this._paddingRight = 0;
            this.star = 0;
            this.measureLock = undefined;
            this._itemsAlign = 'left';
            this._menuPosition = 'right';
            this._uniform = false;
            this.uniformSize = 0;
            this._spacing = 0;
            this.itemsWidth = 0;
            this.keepItems = undefined;
            this.menuNeeded = false;
            this.items = [];
            this.bg = new Ui.Rectangle();
            this.appendChild(this.bg);
            this.menuButton = new Ui.MenuToolBarButton();
            this.menuButton.pressed.connect(() => this.onMenuButtonPress());
            this.appendChild(this.menuButton);
            if (init) {
                if (init.paddingTop !== undefined)
                    this.paddingTop = init.paddingTop;
                if (init.paddingBottom !== undefined)
                    this.paddingBottom = init.paddingBottom;
                if (init.paddingLeft !== undefined)
                    this.paddingLeft = init.paddingLeft;
                if (init.paddingRight !== undefined)
                    this.paddingRight = init.paddingRight;
                if (init.itemsAlign !== undefined)
                    this.itemsAlign = init.itemsAlign;
                if (init.menuPosition !== undefined)
                    this.menuPosition = init.menuPosition;
                if (init.uniform !== undefined)
                    this.uniform = init.uniform;
                if (init.spacing !== undefined)
                    this.spacing = init.spacing;
            }
        }
        get uniform() {
            return this._uniform;
        }
        set uniform(uniform) {
            if (this._uniform !== uniform) {
                this._uniform = uniform;
                this.invalidateMeasure();
            }
        }
        get menuPosition() {
            return this._menuPosition;
        }
        set menuPosition(menuPosition) {
            if (this._menuPosition !== menuPosition) {
                this._menuPosition = menuPosition;
                this.invalidateArrange();
            }
        }
        get itemsAlign() {
            return this._itemsAlign;
        }
        set itemsAlign(align) {
            if (this._itemsAlign !== align) {
                this._itemsAlign = align;
                this.invalidateArrange();
            }
        }
        get logicalChildren() {
            return this.items;
        }
        set padding(padding) {
            this.paddingTop = padding;
            this.paddingBottom = padding;
            this.paddingLeft = padding;
            this.paddingRight = padding;
        }
        get paddingTop() {
            return this._paddingTop;
        }
        set paddingTop(paddingTop) {
            if (this._paddingTop !== paddingTop) {
                this._paddingTop = paddingTop;
                this.invalidateMeasure();
            }
        }
        get paddingBottom() {
            return this._paddingBottom;
        }
        set paddingBottom(paddingBottom) {
            if (this._paddingBottom !== paddingBottom) {
                this._paddingBottom = paddingBottom;
                this.invalidateMeasure();
            }
        }
        get paddingLeft() {
            return this._paddingLeft;
        }
        set paddingLeft(paddingLeft) {
            if (this._paddingLeft !== paddingLeft) {
                this._paddingLeft = paddingLeft;
                this.invalidateMeasure();
            }
        }
        get paddingRight() {
            return this._paddingRight;
        }
        set paddingRight(paddingRight) {
            if (this._paddingRight !== paddingRight) {
                this._paddingRight = paddingRight;
                this.invalidateMeasure();
            }
        }
        get spacing() {
            return this._spacing;
        }
        set spacing(spacing) {
            if (this._spacing !== spacing) {
                this._spacing = spacing;
                this.invalidateMeasure();
            }
        }
        append(child, resizable = false) {
            if (resizable !== undefined)
                child.resizable = resizable === true;
            this.items.push(child);
            this.invalidateMeasure();
        }
        prepend(child, resizable = false) {
            if (resizable !== undefined)
                child.resizable = resizable === true;
            this.items.unshift(child);
            this.invalidateMeasure();
        }
        remove(child) {
            let i = 0;
            while ((i < this.items.length) && (this.items[i] !== child)) {
                i++;
            }
            if (i < this.items.length) {
                this.items.splice(i, 1);
                if ((child.parent === this) && (child.parent instanceof Ui.Container))
                    child.parent.removeChild(child);
                this.invalidateMeasure();
            }
        }
        moveAt(child, position) {
            if (position < 0)
                position = this.items.length + position;
            if (position < 0)
                position = 0;
            if (position >= this.items.length)
                position = this.items.length;
            let i = 0;
            while ((i < this.items.length) && (this.items[i] !== child)) {
                i++;
            }
            if (i < this.items.length) {
                this.items.splice(i, 1);
                this.items.splice(position, 0, child);
            }
            this.onChildInvalidateMeasure(child, 'move');
        }
        insertAt(child, position, resizable) {
            if (resizable !== undefined)
                child.resizable = resizable === true;
            position = Math.max(0, Math.min(position, this.items.length));
            this.items.splice(position, 0, child);
            this.invalidateMeasure();
        }
        setContent(content) {
            if (content === undefined)
                this.clear();
            else if (typeof (content) === 'object') {
                if (content.constructor !== Array) {
                    content = [content];
                }
                for (let i = 0; i < this.items.length; i++) {
                    let found = false;
                    for (let i2 = 0; (found === false) && (i2 < content.length); i2++) {
                        found = (this.items[i] === content[i2]);
                    }
                    if ((found === false) && (this.items[i].parent === this))
                        this.removeChild(this.items[i]);
                }
                this.items = content;
                this.invalidateMeasure();
            }
        }
        onMenuButtonPress() {
            let dialog = new Ui.MenuToolBarPopup();
            let vbox = new Ui.VBox();
            dialog.content = vbox;
            for (let i = 0; i < this.items.length; i++) {
                let item = this.items[i];
                if (item.parent !== this) {
                    vbox.append(item);
                    if (i < this.items.length - 1)
                        vbox.append(new Ui.MenuPopupSeparator());
                }
            }
            dialog.openElement(this.menuButton, 'bottom');
        }
        clear() {
            for (let i = 0; i < this.items.length; i++) {
                if (this.items[i].parent === this)
                    this.items[i].parent.removeChild(this.items[i]);
            }
            this.items = [];
            this.invalidateMeasure();
        }
        measureCore(width, height) {
            let left = this.paddingLeft;
            let right = this.paddingRight;
            let top = this.paddingTop;
            let bottom = this.paddingBottom;
            let constraintWidth = Math.max(0, width - (left + right));
            let constraintHeight = Math.max(0, height - (top + bottom));
            let size;
            let i;
            this.bg.measure(width, height);
            this.measureLock = true;
            let buttonSize = this.menuButton.measure(0, 0);
            let minSizes = [];
            for (i = 0; i < this.items.length; i++) {
                let item = this.items[i];
                if (item.parent !== this) {
                    if ((item.parent != undefined) && (item.parent instanceof Ui.Container))
                        item.parent.removeChild(item);
                    this.appendChild(item);
                }
                minSizes.push(item.measure(0, 0));
            }
            this.keepItems = [];
            let totalWidth = 0;
            let countResizable = 0;
            let maxItemWidth = 0;
            let maxItemHeight = buttonSize.height;
            let minItemsSize = 0;
            i = (this._menuPosition === 'left') ? (i = this.items.length - 1) : 0;
            while ((i >= 0) && (i < this.items.length)) {
                let minSize = minSizes[i];
                if (totalWidth + minSize.width + this._spacing > constraintWidth)
                    break;
                totalWidth += minSize.width + this._spacing;
                if (totalWidth + buttonSize.width > constraintWidth)
                    break;
                if (this._menuPosition === 'left')
                    this.keepItems.unshift(this.items[i]);
                else
                    this.keepItems.push(this.items[i]);
                if (this.items[i].resizable)
                    countResizable++;
                else {
                    minItemsSize += minSize.width;
                    if (minSize.height > maxItemHeight)
                        maxItemHeight = minSize.height;
                }
                if (minSize.width > maxItemWidth)
                    maxItemWidth = minSize.width;
                if (this._menuPosition === 'left')
                    i--;
                else
                    i++;
            }
            if (totalWidth > 0)
                totalWidth -= this._spacing;
            this.menuNeeded = this.keepItems.length !== this.items.length;
            let constraintSize = constraintWidth;
            if (this.menuNeeded) {
                constraintSize -= buttonSize.width + this._spacing;
                while ((i >= 0) && (i < this.items.length)) {
                    this.removeChild(this.items[i]);
                    if (this._menuPosition === 'left')
                        i--;
                    else
                        i++;
                }
            }
            if (this._uniform) {
                if ((this.keepItems.length * (maxItemWidth + this._spacing)) - this._spacing <= constraintWidth) {
                    for (i = 0; i < this.keepItems.length; i++)
                        this.keepItems[i].measure(maxItemWidth, maxItemHeight);
                    this.uniformSize = maxItemWidth;
                    size = { width: ((this.keepItems.length * (maxItemWidth + this._spacing)) - this._spacing), height: maxItemHeight };
                }
                else {
                    this.uniformSize = undefined;
                    size = { width: totalWidth, height: maxItemHeight };
                }
            }
            else {
                if (countResizable > 0) {
                    let remainWidth = constraintSize - minItemsSize - ((this.keepItems.length - 1) * this._spacing);
                    let starFound = true;
                    let star = remainWidth / countResizable;
                    do {
                        starFound = true;
                        for (i = 0; i < this.keepItems.length; i++) {
                            let child = this.keepItems[i];
                            if (child.resizable) {
                                if (!child.menutoolbarStarDone) {
                                    size = child.measure(star, constraintHeight);
                                    if (size.height > maxItemHeight)
                                        maxItemHeight = size.height;
                                    if (size.width > star) {
                                        child.menutoolbarStarDone = true;
                                        starFound = false;
                                        remainWidth -= size.width;
                                        minItemsSize += size.width;
                                        countResizable--;
                                        star = remainWidth / countResizable;
                                        break;
                                    }
                                }
                            }
                        }
                    } while (!starFound);
                    minItemsSize += this._spacing * (this.keepItems.length - 1);
                    if (countResizable > 0) {
                        minItemsSize += star * countResizable;
                        this.star = star;
                    }
                    else
                        this.star = 0;
                    size = { width: minItemsSize, height: maxItemHeight };
                }
                else
                    size = { width: totalWidth, height: maxItemHeight };
            }
            if (this.menuNeeded)
                size.width += buttonSize.width + this._spacing;
            size.width += left + right;
            size.height += top + bottom;
            this.measureLock = undefined;
            return size;
        }
        arrangeCore(width, height) {
            this.bg.arrange(0, 0, width, height);
            let left = this._paddingLeft;
            let right = this._paddingRight;
            let top = this._paddingTop;
            let bottom = this._paddingBottom;
            width -= left + right;
            height -= top + bottom;
            let x = left;
            let y = top;
            let first = true;
            if (this._itemsAlign !== 'left')
                x = width - this.measureWidth;
            if (this.menuNeeded && (this._menuPosition === 'left')) {
                first = false;
                this.menuButton.arrange(x, y, this.menuButton.measureWidth, height);
                x += this.menuButton.measureWidth;
            }
            for (let i = 0; i < this.keepItems.length; i++) {
                let item = this.keepItems[i];
                if (first)
                    first = false;
                else
                    x += this._spacing;
                let itemWidth;
                if (this._uniform && (this.uniformSize !== undefined))
                    itemWidth = this.uniformSize;
                else {
                    itemWidth = item.measureWidth;
                    if (item.resizable && (itemWidth < this.star))
                        itemWidth = this.star;
                }
                item.arrange(x, y, itemWidth, height);
                x += itemWidth;
            }
            if (this.menuNeeded && (this._menuPosition !== 'left')) {
                if (first)
                    first = false;
                else
                    x += this._spacing;
                this.menuButton.arrange(x, y, this.menuButton.measureWidth, height);
            }
            if (!this.menuNeeded)
                this.menuButton.drawing.style.visibility = 'hidden';
            else
                this.menuButton.drawing.style.visibility = '';
        }
        onChildInvalidateMeasure(child, event) {
            if (this.measureLock !== true)
                super.onChildInvalidateMeasure(child, event);
        }
        onStyleChange() {
            this.bg.fill = this.getStyleProperty('background');
        }
    }
    MenuToolBar.style = {
        background: 'rgba(250, 250, 250, 0)'
    };
    Ui.MenuToolBar = MenuToolBar;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class App extends Ui.Container {
        constructor(init) {
            super(init);
            this._loaded = false;
            this.arguments = undefined;
            this.webApp = true;
            this.lastArrangeHeight = 0;
            this.resized = new Core.Events();
            this.parentmessage = new Core.Events();
            let args;
            Ui.App.current = this;
            if (App.style)
                this.setParentStyle(App.style);
            this.drawing.style.cursor = 'default';
            this.selection = new Ui.Selection();
            this.selection.changed.connect(e => this.onSelectionChange(e.target));
            if ((window.location.search !== undefined) && (window.location.search !== '')) {
                let base64;
                args = {};
                let tab = window.location.search.substring(1).split('&');
                for (let i = 0; i < tab.length; i++) {
                    let tab2 = tab[i].split('=');
                    if (tab2.length == 2) {
                        let key = decodeURIComponent(tab2[0]);
                        let val = decodeURIComponent(tab2[1]);
                        if (key === 'base64')
                            base64 = JSON.parse(Core.Util.fromBase64(val));
                        else
                            args[key] = val;
                    }
                }
                if (base64 !== undefined) {
                    this.arguments = base64;
                    for (let prop in args)
                        this.arguments[prop] = args[prop];
                }
                else
                    this.arguments = args;
            }
            else
                this.arguments = {};
            if (this.arguments.remotedebug !== undefined) {
                args = this.arguments.remotedebug.split(':');
                new Core.RemoteDebug({ host: args[0], port: args[1] });
            }
            this.contentBox = new Ui.VBox();
            this.appendChild(this.contentBox);
            this.setTransformOrigin(0, 0);
            window.addEventListener('beforeprint', () => { Ui.App.isPrint = true; this.invalidateMeasure(); App.update(); });
            window.addEventListener('afterprint', () => { Ui.App.isPrint = false; this.invalidateMeasure(); });
            window.addEventListener('message', (e) => this.onMessage(e));
            if (App.isReady)
                this.onReady();
            if (init) {
                if (init.content !== undefined)
                    this.content = init.content;
            }
        }
        set onresized(value) { this.resized.connect(value); }
        static set onready(value) { this.ready.connect(value); }
        set onparentmessage(value) { this.parentmessage.connect(value); }
        static set onorientationchanged(value) { this.orientationchanged.connect(value); }
        setWebApp(webApp) {
            this.webApp = webApp;
        }
        getSelectionHandler() {
            return this.selection;
        }
        static forceInvalidateMeasure(element) {
            if (element === undefined && Ui.App.current)
                element = Ui.App.current;
            if (element instanceof Ui.Container)
                for (let i = 0; i < element.children.length; i++)
                    this.forceInvalidateMeasure(element.children[i]);
            element.invalidateMeasure();
            if ('invalidateTextMeasure' in element)
                element.invalidateTextMeasure();
        }
        static requireFont(fontFamily, fontWeight) {
            let fontKey = fontFamily + ':' + fontWeight;
            if (this.requireFonts === undefined)
                this.requireFonts = {};
            if (!this.requireFonts[fontKey]) {
                let test = false;
                if (this.isReady)
                    test = Ui.Label.isFontAvailable(fontFamily, fontWeight);
                this.requireFonts[fontKey] = test;
                if (test)
                    App.invalidateAllTextMeasure();
                else if (this.isReady && !test && (this.testFontTask === undefined))
                    this.testFontTask = new Core.DelayedTask(0.25, () => this.testRequireFonts());
            }
        }
        static testRequireFonts() {
            let allDone = true;
            for (let fontKey in this.requireFonts) {
                let test = this.requireFonts[fontKey];
                if (!test) {
                    let fontTab = fontKey.split(':');
                    test = Ui.Label.isFontAvailable(fontTab[0], fontTab[1]);
                    if (test) {
                        this.requireFonts[fontKey] = true;
                        App.invalidateAllTextMeasure();
                    }
                    else
                        allDone = false;
                }
            }
            if (!allDone)
                this.testFontTask = new Core.DelayedTask(0.25, () => this.testRequireFonts());
            else
                this.testFontTask = undefined;
        }
        static invalidateAllTextMeasure() {
            for (let dialog of this.dialogs)
                App.forceInvalidateMeasure(dialog);
            for (let layer of this.topLayers)
                App.forceInvalidateMeasure(layer);
            if (Ui.App.current)
                App.forceInvalidateMeasure(Ui.App.current);
        }
        static checkWindowSize() {
            let innerWidth = document.body.clientWidth;
            let innerHeight = document.body.clientHeight;
            if ((innerWidth !== this.windowWidth) || (innerHeight !== this.windowWidth)) {
                if (Ui.App.current)
                    Ui.App.current.invalidateLayout();
                for (let dialog of Ui.App.dialogs)
                    dialog.invalidateLayout();
                for (let topLayer of Ui.App.topLayers)
                    topLayer.invalidateLayout();
            }
        }
        getOrientation() {
            return App.orientation;
        }
        measureCore(width, height) {
            let minWidth = 0;
            let minHeight = 0;
            for (let child of this.children) {
                let size = child.measure(width, height);
                if (size.width > minWidth)
                    minWidth = size.width;
                if (size.height > minHeight)
                    minHeight = size.height;
            }
            return { width: minWidth, height: minHeight };
        }
        onSelectionChange(selection) {
        }
        static onWindowLoad() {
            if (Core.Navigator.iPad || Core.Navigator.iPhone || Core.Navigator.Android) {
                if (Ui.App.current && Ui.App.current.webApp) {
                    let meta = document.createElement('meta');
                    meta.name = 'apple-mobile-web-app-capable';
                    meta.content = 'yes';
                    document.getElementsByTagName("head")[0].appendChild(meta);
                    meta = document.createElement('meta');
                    meta.name = 'apple-mobile-web-app-status-bar-style';
                    meta.content = 'black';
                    document.getElementsByTagName("head")[0].appendChild(meta);
                    meta = document.createElement('meta');
                    meta.name = 'mobile-web-app-capable';
                    meta.content = 'yes';
                    document.getElementsByTagName("head")[0].appendChild(meta);
                }
            }
            let meta = document.createElement('meta');
            meta.name = 'viewport';
            if (Core.Navigator.iOs)
                meta.content = 'width=device-width, user-scalable=no';
            else
                meta.content = 'width=device-width, initial-scale=1.0, minimum-scale=1';
            document.getElementsByTagName("head")[0].appendChild(meta);
            if (Core.Navigator.isWebkit) {
                let style = document.createElement('style');
                style.type = 'text/css';
                style.innerHTML = '* { -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }';
                document.getElementsByTagName('head')[0].appendChild(style);
            }
            window.addEventListener('resize', e => App.onWindowResize(e));
            window.addEventListener('keyup', e => App.onWindowKeyUp(e));
            if ('onorientationchange' in window)
                window.addEventListener('orientationchange', (e) => App.onOrientationChange(e));
            window.addEventListener('focus', (event) => {
                if (event.target == undefined)
                    return;
                App.focusElement = event.target;
            }, true);
            window.addEventListener('blur', (event) => {
                App.focusElement = undefined;
            }, true);
            window.addEventListener('dragstart', (event) => event.preventDefault());
            window.addEventListener('dragenter', (event) => { event.preventDefault(); return false; });
            window.addEventListener('dragover', (event) => {
                if (event.dataTransfer)
                    event.dataTransfer.dropEffect = 'none';
                event.preventDefault();
                return false;
            });
            window.addEventListener('drop', (event) => { event.preventDefault(); return false; });
            if ((this.requireFonts !== undefined) && (this.testFontTask === undefined))
                this.testRequireFonts();
            for (let dialog of this.dialogs) {
                document.body.appendChild(dialog.drawing);
                dialog.isLoaded = true;
                dialog.parentVisible = true;
            }
            for (let layer of this.topLayers) {
                document.body.appendChild(layer.drawing);
                layer.isLoaded = true;
                layer.parentVisible = true;
            }
            if (Ui.App.current)
                Ui.App.current.onReady();
            App.checkWindowSize();
            if (App.updateTask === false) {
                App.updateTask = true;
                requestAnimationFrame(App.update);
            }
            new Ui.DragNativeManager();
            this.ready.fire({ target: this });
            this._ready = true;
        }
        static onWindowResize(event) {
            this.checkWindowSize();
        }
        static onOrientationChange(event) {
            this.orientation = window.orientation;
            this.orientationchanged.fire({ orientation: this.orientation });
            this.checkWindowSize();
        }
        get content() {
            return this._content;
        }
        set content(content) {
            if (this._content !== content) {
                if (this._content !== undefined)
                    this.contentBox.remove(this._content);
                if (content !== undefined)
                    this.contentBox.prepend(content, true);
                this._content = content;
            }
        }
        static appendDialog(dialog, modal = true) {
            if (App.style)
                dialog.setParentStyle(App.style);
            this.dialogsFocus.push(this.focusElement);
            this.dialogs.push(dialog);
            if (modal) {
                if (Ui.App.current)
                    Ui.App.current.contentBox.disable();
                for (let i = 0; i < this.dialogs.length - 1; i++)
                    this.dialogs[i].disable();
            }
            if (document.readyState == 'complete') {
                if (App.topLayers.length > 0)
                    document.body.insertBefore(dialog.drawing, this.topLayers[0].drawing);
                else
                    document.body.appendChild(dialog.drawing);
                dialog.isLoaded = true;
                dialog.parentVisible = true;
            }
            dialog.invalidateLayout();
        }
        static removeDialog(dialog) {
            let dialogFocus = App.dialogsFocus.pop();
            this.dialogs = this.dialogs.filter(d => d !== dialog);
            dialog.layoutValid = true;
            dialog.isLoaded = false;
            dialog.parentVisible = false;
            if (document.readyState == 'complete' && dialog.drawing.parentElement == document.body)
                document.body.removeChild(dialog.drawing);
            if (this.dialogs.length === 0) {
                if (Ui.App.current)
                    Ui.App.current.contentBox.enable();
            }
            else if (this.dialogs.length > 0)
                this.dialogs[this.dialogs.length - 1].enable();
            if (dialogFocus && dialogFocus.focus && (typeof (dialogFocus.focus) == 'function'))
                dialogFocus.focus();
        }
        static appendTopLayer(layer) {
            if (App.style)
                layer.setParentStyle(App.style);
            layer.invalidateLayout();
            this.topLayers.push(layer);
            if (document.readyState == 'complete') {
                document.body.appendChild(layer.drawing);
                layer.isLoaded = true;
                layer.parentVisible = true;
            }
            layer.invalidateLayout();
        }
        static removeTopLayer(layer) {
            App.topLayers = App.topLayers.filter(l => l !== layer);
            if (document.readyState == 'complete')
                document.body.removeChild(layer.drawing);
            layer.isLoaded = false;
            layer.parentVisible = false;
        }
        getArguments() {
            return this.arguments;
        }
        static get isReady() {
            return this._ready;
        }
        onReady() {
            document.documentElement.style.position = 'absolute';
            document.documentElement.style.padding = '0px';
            document.documentElement.style.margin = '0px';
            document.documentElement.style.border = '0px solid black';
            document.documentElement.style.width = '100%';
            document.documentElement.style.height = '100%';
            document.body.style.position = 'absolute';
            document.body.style.overflow = 'hidden';
            document.body.style.padding = '0px';
            document.body.style.margin = '0px';
            document.body.style.border = '0px solid black';
            document.body.style.outline = 'none';
            document.body.style.width = '100%';
            document.body.style.height = '100%';
            if (document.body.children.length > 0)
                document.body.insertBefore(this.drawing, document.body.children[0]);
            else
                document.body.appendChild(this.drawing);
            this.isLoaded = true;
            this.parentVisible = true;
        }
        static onWindowKeyUp(event) {
            let key = event.which;
            if ((key == 27) && (App.dialogs !== undefined) && (App.dialogs.length > 0)) {
                let element = App.dialogs[App.dialogs.length - 1];
                if (element instanceof Ui.Dialog) {
                    let dialog = element;
                    if (dialog.dialogSelection.watchers.length > 0)
                        dialog.dialogSelection.watchers = [];
                    else
                        dialog.close();
                }
                else if (element instanceof Ui.Popup) {
                    let popup = element;
                    if (popup.popupSelection.watchers.length > 0)
                        popup.popupSelection.watchers = [];
                    else
                        popup.close();
                }
                event.preventDefault();
                event.stopPropagation();
            }
        }
        onLoad() {
            this.onInternalStyleChange();
            super.onLoad();
        }
        onMessage(event) {
            if (parent === event.source) {
                event.preventDefault();
                event.stopPropagation();
                let msg = JSON.parse(event.data);
                this.parentmessage.fire({ target: this, message: msg });
            }
        }
        sendMessageToParent(msg) {
            parent.postMessage(msg.serialize(), "*");
        }
        findFocusableDiv(current) {
            if (('tabIndex' in current) && (current.tabIndex >= 0))
                return current;
            if ('childNodes' in current) {
                for (let i = 0; i < current.childNodes.length; i++) {
                    let res = this.findFocusableDiv(current.childNodes[i]);
                    if (res !== undefined)
                        return res;
                }
            }
            return undefined;
        }
        static enqueueDraw(element) {
            element.drawNext = App.drawList;
            App.drawList = element;
            if (App.isReady && App.updateTask === false) {
                App.updateTask = true;
                setTimeout(App.update, 0);
            }
        }
        static enqueueLayout(element) {
            element.layoutNext = App.layoutList;
            App.layoutList = element;
            if (App.isReady && App.updateTask === false) {
                App.updateTask = true;
                requestAnimationFrame(App.update);
            }
        }
        static get style() {
            return this._style;
        }
        static set style(style) {
            this._style = style;
            for (let dialog of this.dialogs)
                dialog.setParentStyle(style);
            for (let layer of this.topLayers)
                layer.setParentStyle(style);
            if (Ui.App.current)
                Ui.App.current.setParentStyle(style);
        }
        getElementsByClass(className) {
            let res = new Array();
            let reqSearch = function (current) {
                if (current instanceof className)
                    res.push(current);
                if (current instanceof Ui.Container) {
                    for (let i = 0; i < current.children.length; i++)
                        reqSearch(current.children[i]);
                }
            };
            reqSearch(this);
            return res;
        }
        getElementByDrawing(drawing) {
            let reqSearch = function (current) {
                if (current.drawing === drawing)
                    return current;
                if (current.children !== undefined) {
                    for (let i = 0; i < current.children.length; i++) {
                        let res = reqSearch(current.children[i]);
                        if (res !== undefined)
                            return res;
                    }
                }
            };
            return reqSearch(this);
        }
        getInverseLayoutTransform() {
            return Ui.Matrix.createTranslate(-document.body.scrollLeft, -document.body.scrollTop).
                multiply(super.getInverseLayoutTransform());
        }
        getLayoutTransform() {
            return super.getLayoutTransform().translate(document.body.scrollLeft, document.body.scrollTop);
        }
        invalidateMeasure() {
            this.invalidateLayout();
        }
        invalidateArrange() {
            this.invalidateLayout();
        }
        arrangeCore(w, h) {
            if (Core.Navigator.Android && Core.Navigator.isWebkit) {
                if ((App.focusElement != undefined) && ((App.focusElement.tagName === 'INPUT') || (App.focusElement.tagName === 'TEXTAREA') || (App.focusElement.contenteditable))) {
                    if (h - 100 > this.lastArrangeHeight)
                        App.focusElement.blur();
                }
            }
            this.lastArrangeHeight = h;
            for (let child of this.children)
                child.arrange(0, 0, w, h);
        }
        static getWindowIFrame(currentWindow) {
            if (currentWindow === undefined)
                currentWindow = window;
            let iframe;
            if (currentWindow.parent !== currentWindow) {
                try {
                    let frames = currentWindow.parent.document.getElementsByTagName("IFRAME");
                    for (let i = 0; i < frames.length; i++) {
                        if (frames[i].contentWindow === currentWindow) {
                            iframe = frames[i];
                            break;
                        }
                    }
                }
                catch (e) { }
            }
            return iframe;
        }
        static getRootWindow() {
            let rootWindow = window;
            while (rootWindow.parent != rootWindow)
                rootWindow = rootWindow.parent;
            return rootWindow;
        }
        static initialize() {
            if (document.readyState == 'complete')
                App.onWindowLoad();
            else
                window.addEventListener('load', () => App.onWindowLoad());
        }
    }
    App.focusElement = undefined;
    App._ready = false;
    App.orientation = 0;
    App.updateTask = false;
    App.windowWidth = 0;
    App.windowHeight = 0;
    App.dialogs = [];
    App.dialogsFocus = [];
    App.topLayers = [];
    App.ready = new Core.Events();
    App.orientationchanged = new Core.Events();
    App.update = () => {
        let innerWidth = window.innerWidth;
        let innerHeight = window.innerHeight;
        App.updateTask = false;
        if ((App.windowWidth !== innerWidth) || (App.windowHeight !== innerHeight)) {
            App.windowWidth = innerWidth;
            App.windowHeight = innerHeight;
            if (Ui.App.current) {
                Ui.App.current.resized.fire({ target: Ui.App.current, width: App.windowWidth, height: App.windowHeight });
                Ui.App.current.invalidateLayout();
            }
            for (let dialog of App.dialogs)
                dialog.invalidateLayout();
        }
        let layoutList = App.layoutList;
        App.layoutList = undefined;
        while (layoutList != undefined) {
            let current = layoutList;
            layoutList = layoutList.layoutNext;
            current.layoutValid = true;
            current.layoutNext = undefined;
            current.updateLayout(App.windowWidth, App.windowHeight);
        }
        let drawList = App.drawList;
        App.drawList = undefined;
        while (drawList != undefined) {
            let next = drawList.drawNext;
            drawList.drawNext = undefined;
            drawList.draw();
            drawList = next;
        }
    };
    App.current = undefined;
    App.isPrint = false;
    Ui.App = App;
})(Ui || (Ui = {}));
Ui.App.initialize();
var Ui;
(function (Ui) {
    class Form extends Ui.LBox {
        constructor(init) {
            super(init);
            this.submited = new Core.Events();
            this.drawing.addEventListener('submit', (e) => this.onSubmit(e));
        }
        set onsubmited(value) { this.submited.connect(value); }
        onSubmit(event) {
            event.preventDefault();
            event.stopPropagation();
            this.submited.fire({ target: this });
        }
        submit() {
            this.drawing.submit();
        }
        renderDrawing() {
            let drawing = document.createElement('form');
            let submit = document.createElement('input');
            submit.type = 'submit';
            submit.style.visibility = 'hidden';
            drawing.appendChild(submit);
            let container = document.createElement('div');
            this.containerDrawing = container;
            drawing.appendChild(container);
            return drawing;
        }
    }
    Ui.Form = Form;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class DialogCloseButton extends Ui.Button {
        constructor(init) {
            super(init);
            this.icon = 'close';
            this.text = 'Fermer';
        }
    }
    DialogCloseButton.style = {
        showText: false,
        background: 'rgba(250,250,250,0)',
        backgroundBorder: 'rgba(250,250,250,0)',
        activeBackground: 'rgba(250,250,250,0)',
        activeBackgroundBorder: 'rgba(250,250,250,0)'
    };
    Ui.DialogCloseButton = DialogCloseButton;
    class DialogTitle extends Ui.Label {
    }
    DialogTitle.style = {
        color: Ui.Color.create('#666666'),
        fontWeight: 'bold',
        fontSize: 18
    };
    Ui.DialogTitle = DialogTitle;
    class DialogButtonBox extends Ui.LBox {
        constructor() {
            super();
            this.cancelled = new Core.Events();
            this.onCancelPress = () => {
                this.cancelled.fire({ target: this });
            };
            this.bg = new Ui.Rectangle();
            this.append(this.bg);
            this.actionBox = new Ui.HBox();
            this.actionBox.margin = 5;
            this.append(new Ui.ScrollingArea({ content: this.actionBox, scrollVertical: false }));
            this.actionButtonsBox = new Ui.HBox();
            this.actionButtonsBox.spacing = 5;
            this.actionBox.append(this.actionButtonsBox, true);
            this.titleLabel = new DialogTitle({
                marginLeft: 10, marginRight: 10, resizable: true,
                verticalAlign: 'center', horizontalAlign: 'left'
            });
            this.actionButtonsBox.append(this.titleLabel);
        }
        getTitle() {
            return this.titleLabel.text;
        }
        setTitle(title) {
            this.titleLabel.text = title;
        }
        get titleResizable() {
            return this.titleLabel.resizable;
        }
        set titleResizable(value) {
            this.titleLabel.resizable = value;
        }
        getCancelButton() {
            return this.cancelButton;
        }
        setCancelButton(button) {
            if (this.cancelButton !== undefined) {
                if (this.cancelButton instanceof Ui.Pressable)
                    this.cancelButton.pressed.disconnect(this.onCancelPress);
                this.actionBox.remove(this.cancelButton);
            }
            this.cancelButton = button;
            if (this.cancelButton !== undefined) {
                if (this.cancelButton instanceof Ui.Pressable)
                    this.cancelButton.pressed.connect(this.onCancelPress);
                this.actionBox.prepend(this.cancelButton);
            }
        }
        setActionButtons(buttons) {
            this.actionButtonsBox.content = buttons;
            this.actionButtonsBox.prepend(this.titleLabel);
        }
        getActionButtons() {
            return this.actionButtonsBox.children.slice(1);
        }
        onStyleChange() {
            this.bg.fill = this.getStyleProperty('background');
        }
    }
    DialogButtonBox.style = {
        background: '#e8e8e8'
    };
    Ui.DialogButtonBox = DialogButtonBox;
    class Dialog extends Ui.Container {
        constructor(init) {
            super(init);
            this.buttonsVisible = false;
            this._modal = true;
            this.isClosed = true;
            this.closed = new Core.Events();
            this.drawing.style.position = 'fixed';
            this.drawing.style.top = '0';
            this.drawing.style.bottom = '0';
            this.drawing.style.left = '0';
            this.drawing.style.right = '0';
            this.dialogSelection = new Ui.Selection();
            this.shadowGraphic = new Ui.Rectangle();
            new Ui.PressWatcher({
                element: this.shadowGraphic,
                onpressed: () => this.onShadowPress()
            });
            this.appendChild(this.shadowGraphic);
            this.lbox = new Ui.Form();
            this.lbox.submited.connect(() => this.onFormSubmit());
            this.appendChild(this.lbox);
            this.vbox = new Ui.VBox();
            this.vbox.margin = 3;
            this.vbox.drawing.style.boxShadow = '0px 0px 4px rgba(0,0,0,0.5)';
            this.vbox.drawing.style.overflow = 'hidden';
            this.lbox.append(this.vbox);
            this.buttonsBox = new Ui.LBox();
            this.buttonsBox.height = 32;
            this.buttonsBox.hide(true);
            this.vbox.append(this.buttonsBox);
            this.scroll = new Ui.ScrollingArea();
            this.vbox.append(this.scroll, true);
            this.contentVBox = new Ui.VBox();
            this.scroll.content = this.contentVBox;
            this.contentBox = new Ui.LBox();
            this.contentBox.margin = 8;
            this.contentVBox.append(this.contentBox, true);
            this.contextBox = new Ui.ContextBar();
            this.contextBox.selection = this.dialogSelection;
            this.contextBox.hide();
            this.buttonsBox.append(this.contextBox);
            this.actionBox = new Ui.DialogButtonBox();
            this.actionBox.cancelled.connect(() => this.close());
            this.buttonsBox.append(this.actionBox);
            this.dialogSelection.changed.connect((e) => this.onDialogSelectionChange(e.target));
            this.drawing.addEventListener('keyup', (e) => this.onKeyUp(e));
            this.cancelButton = new DialogCloseButton();
            this.onStyleChange();
            if (init) {
                if (init.padding !== undefined)
                    this.padding = init.padding;
                if (init.preferredWidth !== undefined)
                    this.preferredWidth = init.preferredWidth;
                if (init.preferredHeight !== undefined)
                    this.preferredHeight = init.preferredHeight;
                if (init.title !== undefined)
                    this.title = init.title;
                if (init.cancelButton !== undefined)
                    this.cancelButton = init.cancelButton;
                if (init.actionButtons !== undefined)
                    this.actionButtons = init.actionButtons;
                if (init.autoClose !== undefined)
                    this.autoClose = init.autoClose;
                if (init.content !== undefined)
                    this.content = init.content;
                if (init.onclosed)
                    this.closed.connect(init.onclosed);
            }
        }
        set onclosed(value) { this.closed.connect(value); }
        getSelectionHandler() {
            return this.dialogSelection;
        }
        get modal() {
            return this._modal;
        }
        set modal(value) {
            if (this._modal != value) {
                this._modal = value;
                this.shadowGraphic.opacity = value ? 1 : 0.01;
            }
        }
        set preferredWidth(width) {
            this._preferredWidth = width;
            this.invalidateMeasure();
        }
        set preferredHeight(height) {
            this._preferredHeight = height;
            this.invalidateMeasure();
        }
        get padding() {
            return this.contentBox.marginLeft;
        }
        set padding(padding) {
            this.contentBox.margin = padding;
        }
        open() {
            if (this.isClosed) {
                Ui.App.appendDialog(this, this.modal);
                this.isClosed = false;
                if (this.openClock == undefined) {
                    this.openClock = new Anim.Clock({
                        duration: 1, target: this, speed: 5,
                        ease: new Anim.PowerEase({ mode: 'out' })
                    });
                    this.openClock.timeupdate.connect((e) => this.onOpenTick(e.target, e.progress, e.deltaTick));
                    this.onOpenTick(this.openClock, 0, 0);
                    this.invalidateArrange();
                }
            }
        }
        close() {
            if (!this.isClosed) {
                this.closed.fire({ target: this });
                this.isClosed = true;
                this.lbox.disable();
                if (this.openClock === undefined) {
                    this.openClock = new Anim.Clock({
                        duration: 1, target: this, speed: 5,
                        ease: new Anim.PowerEase({ mode: 'out' })
                    });
                    this.openClock.timeupdate.connect((e) => this.onOpenTick(e.target, e.progress, e.deltaTick));
                    this.openClock.begin();
                }
            }
        }
        onOpenTick(clock, progress, delta) {
            let end = (progress >= 1);
            if (this.isClosed)
                progress = 1 - progress;
            this.shadowGraphic.opacity = progress;
            this.lbox.opacity = progress;
            this.lbox.transform = Ui.Matrix.createTranslate(0, -20 * (1 - progress));
            if (end) {
                if (this.openClock)
                    this.openClock.stop();
                this.openClock = undefined;
                if (this.isClosed) {
                    Ui.App.removeDialog(this);
                    this.lbox.enable();
                }
            }
        }
        getDefaultButton() {
            let buttons = this.actionBox.getActionButtons();
            for (let i = 0; i < buttons.length; i++)
                if (buttons[i] instanceof Ui.DefaultButton)
                    return buttons[i];
        }
        defaultAction() {
            let defaultButton = this.getDefaultButton();
            if (defaultButton !== undefined)
                defaultButton.press();
        }
        get title() {
            return this.actionBox.getTitle();
        }
        set title(title) {
            this.actionBox.setTitle(title);
        }
        get titleResizable() {
            return this.actionBox.titleResizable;
        }
        set titleResizable(value) {
            this.actionBox.titleResizable = value;
        }
        updateButtonsBoxVisible() {
            let visible = (this._cancelButton !== undefined) || (this._actionButtons !== undefined) ||
                (this.dialogSelection.elements.length > 0);
            if (!this.buttonsVisible && visible) {
                this.buttonsVisible = true;
                this.buttonsBox.show();
            }
            else if (this.buttonsVisible && !visible) {
                this.buttonsVisible = false;
                this.buttonsBox.hide(true);
            }
        }
        get cancelButton() {
            return this.actionBox.getCancelButton();
        }
        set cancelButton(button) {
            this._cancelButton = button;
            this.actionBox.setCancelButton(button);
            this.updateButtonsBoxVisible();
        }
        get actionButtons() {
            return this.actionBox.getActionButtons();
        }
        set actionButtons(buttons) {
            this._actionButtons = buttons;
            this.actionBox.setActionButtons(buttons);
            this.updateButtonsBoxVisible();
        }
        set content(content) {
            this.contentBox.content = content;
        }
        get content() {
            return this.contentBox.firstChild;
        }
        set autoClose(autoClose) {
            this._autoClose = autoClose;
        }
        onCancelPress() {
            this.close();
        }
        onFormSubmit() {
            this.defaultAction();
        }
        onDialogSelectionChange(selection) {
            if (selection.elements.length === 0) {
                this.contextBox.hide();
                this.actionBox.show();
            }
            else {
                this.contextBox.show();
                this.actionBox.hide();
            }
            this.updateButtonsBoxVisible();
        }
        onKeyUp(event) {
            if (event.which === 46) {
                if (this.dialogSelection.elements.length !== 0) {
                    if (this.dialogSelection.executeDeleteAction()) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }
            }
        }
        onShadowPress() {
            if (!this.isDisabled && (this._autoClose || this.getStyleProperty('autoClose') == true))
                this.close();
        }
        onStyleChange() {
            this.shadowGraphic.fill = this.getStyleProperty('shadow');
            this.vbox.drawing.style.backgroundColor = Ui.Color.create(this.getStyleProperty('background')).getCssRgba();
            this.vbox.drawing.style.borderRadius = `${this.getStyleProperty('radius')}px`;
        }
        invalidateArrange() {
            super.invalidateArrange();
            this.invalidateLayout();
        }
        invalidateMeasure() {
            super.invalidateMeasure();
            this.invalidateLayout();
        }
        measureCore(width, height) {
            this.shadowGraphic.measure(width, height);
            let preferredWidth = this._preferredWidth ? this._preferredWidth : width;
            let preferredHeight = this._preferredHeight ? this._preferredHeight : height;
            this.lbox.measure((width < preferredWidth) ? width : preferredWidth, (height < preferredHeight) ? height : preferredHeight);
            return { width: width, height: height };
        }
        arrangeCore(width, height) {
            if ((this.openClock !== undefined) && !this.openClock.isActive)
                this.openClock.begin();
            this.shadowGraphic.arrange(0, 0, width, height);
            let usedWidth = Math.min(this._preferredWidth ? Math.max(this.lbox.measureWidth, this._preferredWidth) : this.lbox.measureWidth, width);
            let usedHeight = Math.min(this._preferredHeight ? Math.max(this.lbox.measureHeight, this._preferredHeight) : this.lbox.measureHeight, height);
            this.lbox.arrange((width - usedWidth) / 2, (height - usedHeight) / 2, usedWidth, usedHeight);
        }
    }
    Dialog.style = {
        autoClose: true,
        shadow: 'rgba(0,0,0,0.5)',
        background: '#f8f8f8',
        radius: 5
    };
    Ui.Dialog = Dialog;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Html extends Ui.Element {
        constructor(init) {
            super(init);
            this.captureLink = true;
            this.bindedOnImageLoad = undefined;
            this._color = undefined;
            this.link = new Core.Events();
            this.bindedOnImageLoad = this.onImageLoad.bind(this);
            this.drawing.addEventListener('click', (e) => this.onClick(e));
            this.drawing.addEventListener('keypress', (e) => this.onKeyPress(e));
            if (init) {
                if (init.text !== undefined)
                    this.text = init.text;
                if (init.html !== undefined)
                    this.html = init.html;
                if (init.textAlign !== undefined)
                    this.textAlign = init.textAlign;
                if (init.fontSize !== undefined)
                    this.fontSize = init.fontSize;
                if (init.fontFamily !== undefined)
                    this.fontFamily = init.fontFamily;
                if (init.fontWeight !== undefined)
                    this.fontWeight = init.fontWeight;
                if (init.interLine !== undefined)
                    this.interLine = init.interLine;
                if (init.wordWrap !== undefined)
                    this.wordWrap = init.wordWrap;
                if (init.whiteSpace !== undefined)
                    this.whiteSpace = init.whiteSpace;
                if (init.color !== undefined)
                    this.color = init.color;
                if (init.onlink !== undefined)
                    this.link.connect(init.onlink);
            }
        }
        set onlink(value) { this.link.connect(value); }
        getElements(tagName) {
            let res = new Array();
            this.searchElements(tagName.toUpperCase(), this.htmlDrawing, res);
            return res;
        }
        searchElements(tagName, element, res) {
            for (let i = 0; i < element.childNodes.length; i++) {
                let child = element.childNodes[i];
                if (!(child instanceof HTMLElement))
                    continue;
                if (child.tagName.toUpperCase() == tagName)
                    res.push(child);
                this.searchElements(tagName, child, res);
            }
        }
        getParentElement(tagName, element) {
            do {
                if (('tagName' in element) && (element.tagName.toUpperCase() == tagName))
                    return element;
                if (element.parentNode == undefined)
                    return undefined;
                if (element.parentNode === this.drawing)
                    return undefined;
                element = element.parentNode;
            } while (true);
        }
        onSetHtml() {
        }
        get html() {
            return this.htmlDrawing.innerHTML;
        }
        bindChildEvents() {
            let tab = this.getElements('IMG');
            for (let i = 0; i < tab.length; i++)
                tab[i].onload = this.bindedOnImageLoad;
        }
        set html(html) {
            this.htmlDrawing.innerHTML = html;
            this.onSetHtml();
            this.bindChildEvents();
            this.invalidateMeasure();
        }
        set htmlElement(htmlElement) {
            while (this.htmlDrawing.firstChild)
                this.htmlDrawing.removeChild(this.htmlDrawing.firstChild);
            this.htmlDrawing.appendChild(htmlElement);
            this.onSetHtml();
            this.bindChildEvents();
            this.invalidateMeasure();
        }
        get text() {
            if ('innerText' in this.htmlDrawing)
                return this.htmlDrawing.innerText;
            else
                return this.getTextContent(this.htmlDrawing);
        }
        set text(text) {
            if ('innerText' in this.htmlDrawing)
                this.htmlDrawing.innerText = text;
            else {
                let div = document.createElement('div');
                let content;
                div.textContent = text;
                content = div.textContent;
                let lines = content.split('\n');
                let content2 = '';
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i] !== '') {
                        if (content2 !== '')
                            content2 += "<br>";
                        content2 += lines[i];
                    }
                }
                this.html = content2;
            }
            this.onSetHtml();
            this.invalidateMeasure();
        }
        getTextContent(el) {
            let text = '';
            if (el.nodeType === 3)
                text += el.textContent;
            else if ((el.nodeType === 1) && ((el.nodeName == "BR") || (el.nodeName == "P")))
                text += '\n';
            if ('childNodes' in el) {
                for (let i = 0; i < el.childNodes.length; i++)
                    text += this.getTextContent(el.childNodes[i]);
            }
            return text;
        }
        get textAlign() {
            if (this._textAlign !== undefined)
                return this._textAlign;
            else
                return this.getStyleProperty('textAlign');
        }
        set textAlign(textAlign) {
            if (this._textAlign !== textAlign) {
                this._textAlign = textAlign;
                this.drawing.style.textAlign = this.textAlign;
            }
        }
        get fontSize() {
            if (this._fontSize !== undefined)
                return this._fontSize;
            else
                return this.getStyleProperty('fontSize');
        }
        set fontSize(fontSize) {
            if (this._fontSize !== fontSize) {
                this._fontSize = fontSize;
                this.drawing.style.fontSize = this.fontSize + 'px';
                this.invalidateMeasure();
            }
        }
        get fontFamily() {
            if (this._fontFamily !== undefined)
                return this._fontFamily;
            else
                return this.getStyleProperty('fontFamily');
        }
        set fontFamily(fontFamily) {
            if (this._fontFamily !== fontFamily) {
                this._fontFamily = fontFamily;
                this.drawing.style.fontFamily = this.fontFamily;
                this.invalidateMeasure();
            }
        }
        get fontWeight() {
            if (this._fontWeight !== undefined)
                return this._fontWeight;
            else
                return this.getStyleProperty('fontWeight');
        }
        set fontWeight(fontWeight) {
            if (this._fontWeight !== fontWeight) {
                this._fontWeight = fontWeight;
                this.drawing.style.fontWeight = this.fontWeight;
                this.invalidateMeasure();
            }
        }
        get interLine() {
            if (this._interLine !== undefined)
                return this._interLine;
            else
                return this.getStyleProperty('interLine');
        }
        set interLine(interLine) {
            if (this._interLine !== interLine) {
                this._interLine = interLine;
                this.drawing.style.lineHeight = this.interLine.toString();
                this.invalidateMeasure();
            }
        }
        get wordWrap() {
            if (this._wordWrap !== undefined)
                return this._wordWrap;
            else
                return this.getStyleProperty('wordWrap');
        }
        set wordWrap(wordWrap) {
            if (this._wordWrap !== wordWrap) {
                this._wordWrap = wordWrap;
                this.drawing.style.wordWrap = this.wordWrap;
                this.invalidateMeasure();
            }
        }
        get wordBreak() {
            if (this._wordBreak !== undefined)
                return this._wordBreak;
            else
                return this.getStyleProperty('wordBreak');
        }
        set wordBreak(wordBreak) {
            if (this._wordBreak !== wordBreak) {
                this._wordBreak = wordBreak;
                this.drawing.style.wordBreak = this.wordBreak;
                this.invalidateMeasure();
            }
        }
        get whiteSpace() {
            if (this._whiteSpace !== undefined)
                return this._whiteSpace;
            else
                return this.getStyleProperty('whiteSpace');
        }
        set whiteSpace(whiteSpace) {
            if (this._whiteSpace !== whiteSpace) {
                this._whiteSpace = whiteSpace;
                this.drawing.style.whiteSpace = this.whiteSpace;
                this.invalidateMeasure();
            }
        }
        getColor() {
            if (this._color !== undefined)
                return this._color;
            else
                return Ui.Color.create(this.getStyleProperty('color'));
        }
        set color(color) {
            if (this._color !== color) {
                if (color == undefined) {
                    this._color = undefined;
                    this.drawing.style.color = this.getColor().getCssRgba();
                }
                else {
                    this._color = Ui.Color.create(color);
                    this.drawing.style.color = this._color.getCssRgba();
                }
            }
        }
        onSubtreeModified(event) {
            this.invalidateMeasure();
        }
        onKeyPress(event) {
            this.invalidateMeasure();
        }
        onImageLoad(event) {
            this.invalidateMeasure();
        }
        onClick(event) {
            let target = this.getParentElement('A', event.target);
            if (target !== undefined) {
                if (this.captureLink) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                this.link.fire({ target: this, ref: target.href });
            }
        }
        onVisible() {
            this.invalidateMeasure();
        }
        onStyleChange() {
            this.drawing.style.textAlign = this.textAlign;
            this.drawing.style.fontSize = this.fontSize + 'px';
            this.drawing.style.fontFamily = this.fontFamily;
            this.drawing.style.fontWeight = this.fontWeight;
            this.drawing.style.color = this.getColor().getCssRgba();
            this.drawing.style.lineHeight = this.interLine.toString();
            this.drawing.style.wordWrap = this.wordWrap;
        }
        renderDrawing() {
            let drawing = super.renderDrawing();
            this.htmlDrawing = document.createElement('div');
            this.htmlDrawing.style.outline = 'none';
            this.htmlDrawing.style.padding = '0px';
            this.htmlDrawing.style.margin = '0px';
            this.htmlDrawing.style.display = 'inline-block';
            this.htmlDrawing.style.width = '';
            drawing.appendChild(this.htmlDrawing);
            return drawing;
        }
        measureCore(width, height) {
            width = (this.width !== undefined) ? Math.max(width, this.width) : width;
            this.drawing.style.width = width + 'px';
            this.htmlDrawing.style.width = '';
            this.htmlDrawing.style.height = '';
            let measureWidth;
            if (this.htmlDrawing.clientWidth == width)
                measureWidth = width;
            else
                measureWidth = Math.max(this.htmlDrawing.clientWidth, this.htmlDrawing.scrollWidth) + 1;
            let measureHeight = Math.max(this.htmlDrawing.clientHeight, this.fontSize);
            this.htmlDrawing.style.width = `${this.layoutWidth}px`;
            this.htmlDrawing.style.height = `${this.layoutHeight}px`;
            return {
                width: measureWidth,
                height: measureHeight
            };
        }
        arrangeCore(width, height) {
            this.htmlDrawing.style.width = `${width}px`;
            this.htmlDrawing.style.height = `${height}px`;
        }
    }
    Html.style = {
        color: 'black',
        fontSize: 16,
        fontFamily: 'Sans-serif',
        fontWeight: 'normal',
        textAlign: 'left',
        wordWrap: 'normal',
        wordBreak: 'normal',
        whiteSpace: 'normal',
        interLine: 1
    };
    Ui.Html = Html;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Text extends Ui.CompactLabel {
        constructor(init) {
            super(init);
        }
    }
    Ui.Text = Text;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Shadow extends Ui.CanvasElement {
        constructor(init) {
            super(init);
            this._radiusTopLeft = 0;
            this._radiusTopRight = 0;
            this._radiusBottomLeft = 0;
            this._radiusBottomRight = 0;
            this._shadowWidth = 4;
            this._inner = false;
            this._color = Ui.Color.create('black');
            if (init) {
                if (init.color !== undefined)
                    this.color = init.color;
                if (init.inner !== undefined)
                    this.inner = init.inner;
                if (init.shadowWidth !== undefined)
                    this.shadowWidth = init.shadowWidth;
                if (init.radius !== undefined)
                    this.radius = init.radius;
                if (init.radiusTopLeft !== undefined)
                    this.radiusTopLeft = init.radiusTopLeft;
                if (init.radiusTopRight !== undefined)
                    this.radiusTopRight = init.radiusTopRight;
                if (init.radiusBottomLeft !== undefined)
                    this.radiusBottomLeft = init.radiusBottomLeft;
                if (init.radiusBottomRight !== undefined)
                    this.radiusBottomRight = init.radiusBottomRight;
            }
        }
        set color(color) {
            if (this._color != color) {
                this._color = Ui.Color.create(color);
                this.invalidateDraw();
            }
        }
        get inner() {
            return this._inner;
        }
        set inner(inner) {
            if (this._inner != inner) {
                this._inner = inner;
                this.invalidateDraw();
            }
        }
        set shadowWidth(shadowWidth) {
            if (this._shadowWidth != shadowWidth) {
                this._shadowWidth = shadowWidth;
                this.invalidateDraw();
            }
        }
        get shadowWidth() {
            return this._shadowWidth;
        }
        set radius(radius) {
            this._radiusTopLeft = radius;
            this._radiusTopRight = radius;
            this._radiusBottomLeft = radius;
            this._radiusBottomRight = radius;
            this.invalidateDraw();
        }
        get radiusTopLeft() {
            return this._radiusTopLeft;
        }
        set radiusTopLeft(radiusTopLeft) {
            if (this._radiusTopLeft != radiusTopLeft) {
                this._radiusTopLeft = radiusTopLeft;
                this.invalidateDraw();
            }
        }
        get radiusTopRight() {
            return this._radiusTopRight;
        }
        set radiusTopRight(radiusTopRight) {
            if (this._radiusTopRight != radiusTopRight) {
                this._radiusTopRight = radiusTopRight;
                this.invalidateDraw();
            }
        }
        get radiusBottomLeft() {
            return this._radiusBottomLeft;
        }
        set radiusBottomLeft(radiusBottomLeft) {
            if (this._radiusBottomLeft != radiusBottomLeft) {
                this._radiusBottomLeft = radiusBottomLeft;
                this.invalidateDraw();
            }
        }
        get radiusBottomRight() {
            return this._radiusBottomRight;
        }
        set radiusBottomRight(radiusBottomRight) {
            if (this._radiusBottomRight != radiusBottomRight) {
                this._radiusBottomRight = radiusBottomRight;
                this.invalidateDraw();
            }
        }
        updateCanvas(ctx) {
            let width = this.layoutWidth;
            let height = this.layoutHeight;
            for (let i = 0; i < this._shadowWidth; i++) {
                let rgba = this._color.getRgba();
                let opacity;
                if (this._inner) {
                    if (this._shadowWidth == 1)
                        opacity = 1;
                    else {
                        let x = (i + 1) / this._shadowWidth;
                        opacity = x * x;
                    }
                }
                else
                    opacity = (i + 1) / (this._shadowWidth + 1);
                let color = new Ui.Color(rgba.r, rgba.g, rgba.b, rgba.a * opacity);
                ctx.fillStyle = color.getCssRgba();
                if (this._inner) {
                    ctx.beginPath();
                    ctx.roundRect(0, 0, width, height, this._radiusTopLeft, this._radiusTopRight, this._radiusBottomRight, this._radiusBottomLeft);
                    ctx.roundRect(this._shadowWidth - i, this._shadowWidth - i, width - ((this._shadowWidth - i) * 2), height - ((this._shadowWidth - i) * 2), this._radiusTopLeft, this._radiusTopRight, this._radiusBottomRight, this._radiusBottomLeft, true);
                    ctx.closePath();
                    ctx.fill();
                }
                else {
                    ctx.beginPath();
                    ctx.roundRect(i, i, width - i * 2, height - i * 2, this._radiusTopLeft, this._radiusTopRight, this._radiusBottomRight, this._radiusBottomLeft);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }
    }
    Ui.Shadow = Shadow;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Toaster extends Ui.Container {
        constructor(position) {
            super();
            this.position = position;
            this.eventsHidden = true;
            this.drawing.style.position = 'fixed';
            this.drawing.style.top = '0';
            this.drawing.style.left = '0';
        }
        appendToast(toast) {
            toast.newToast = true;
            if (this.children.length === 0)
                Ui.App.appendTopLayer(this);
            this.appendChild(toast);
        }
        removeToast(toast) {
            this.removeChild(toast);
            if (this.children.length === 0)
                Ui.App.removeTopLayer(this);
        }
        onArrangeTick(clock, progress, delta) {
            for (let i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                if (progress === 1) {
                    child.transform = undefined;
                    child.newToast = false;
                }
                else if (child.newToast !== true)
                    child.transform = (Ui.Matrix.createTranslate((child.lastLayoutX - child.layoutX) * (1 - progress), (child.lastLayoutY - child.layoutY) * (1 - progress)));
            }
            if (progress === 1)
                this.arrangeClock = undefined;
        }
        invalidateArrange() {
            super.invalidateArrange();
            this.invalidateLayout();
        }
        invalidateMeasure() {
            super.invalidateMeasure();
            this.invalidateLayout();
        }
        measureCore(width, height) {
            let spacing = 10;
            let maxWidth = 0;
            let totalHeight = 0;
            for (let i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                let size = child.measure(0, 0);
                totalHeight += size.height;
                if (size.width > maxWidth)
                    maxWidth = size.width;
            }
            totalHeight += Math.max(0, this.children.length - 1) * spacing;
            return { width: maxWidth + 10, height: totalHeight + 10 };
        }
        arrangeCore(width, height) {
            let spacing = 10;
            let y = 0;
            for (let i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                child.lastLayoutX = child.layoutX;
                child.lastLayoutY = child.layoutY;
                y += child.measureHeight;
                if (this.position == 'TopLeft')
                    child.arrange(10, 10 + y - child.measureHeight, this.measureWidth, child.measureHeight);
                else if (this.position == 'TopRight')
                    child.arrange(width - (10 + child.measureWidth), 10 + y - child.measureHeight, this.measureWidth, child.measureHeight);
                else if (this.position == 'BottomRight')
                    child.arrange(width - (10 + child.measureWidth), height - (y + 10), this.measureWidth, child.measureHeight);
                else
                    child.arrange(10, height - (y + 10), this.measureWidth, child.measureHeight);
                y += spacing;
            }
            if (this.arrangeClock === undefined) {
                this.arrangeClock = new Anim.Clock({ duration: 1, speed: 5 });
                this.arrangeClock.timeupdate.connect((e) => this.onArrangeTick(e.target, e.progress, e.deltaTick));
                this.arrangeClock.begin();
            }
        }
        static appendToast(toast) {
            Ui.Toaster.currentBottomLeft.appendToast(toast);
        }
        static removeToast(toast) {
            Ui.Toaster.currentBottomLeft.removeToast(toast);
        }
    }
    Ui.Toaster = Toaster;
    class Toast extends Ui.LBox {
        constructor() {
            super();
            this._isClosed = true;
            this.progress = new Ui.ProgressBar();
            this.newToast = false;
            this.lastLayoutX = 0;
            this.lastLayoutY = 0;
            this.lastLayoutWidth = 0;
            this.lastLayoutHeight = 0;
            this.duration = 2;
            this.closed = new Core.Events();
            this.clipToBounds = true;
            this.drawing.style.boxShadow = '0px 0px 3px rgba(0,0,0,0.4)';
            this.drawing.style.background = 'black';
            this.toastContentBox = new Ui.LBox();
            this.toastContentBox.margin = 10;
            this.toastContentBox.width = 200;
            this.append(this.toastContentBox);
            this.progress.setStyleProperty('background', 'rgba(0,0,0,0)');
            this.append(this.progress.assign({
                verticalAlign: 'bottom'
            }));
        }
        get background() {
            return this.drawing.style.backgroundColor;
        }
        set background(value) {
            this.drawing.style.backgroundColor = value;
        }
        get isClosed() {
            return this._isClosed;
        }
        open(position = 'BottomLeft') {
            if (this._isClosed) {
                this._isClosed = false;
                if (this.openClock == undefined) {
                    this.openClock = new Anim.Clock({
                        duration: 1, target: this, speed: 5,
                        ease: new Anim.PowerEase({ mode: 'out' })
                    });
                    this.openClock.timeupdate.connect((e) => this.onOpenTick(e.target, e.progress, e.deltaTick));
                    this.opacity = 0;
                }
                if (this.duration > 2) {
                    this.append(new Ui.FlatButton().assign({
                        icon: 'close',
                        horizontalAlign: 'right', verticalAlign: 'top',
                        onpressed: () => this.close()
                    }));
                }
                this.runClock = new Anim.Clock({
                    duration: this.duration,
                    ontimeupdate: (e) => this.progress.value = 1 - e.progress,
                    oncompleted: () => this.close()
                });
                this.runClock.begin();
                if (position == 'TopLeft')
                    this.toaster = Ui.Toaster.currentTopLeft;
                else if (position == 'TopRight')
                    this.toaster = Ui.Toaster.currentTopRight;
                else if (position == 'BottomRight')
                    this.toaster = Ui.Toaster.currentBottomRight;
                else
                    this.toaster = Ui.Toaster.currentBottomLeft;
                this.toaster.appendToast(this);
            }
        }
        close() {
            if (!this._isClosed) {
                this._isClosed = true;
                this.disable();
                if (this.runClock != undefined) {
                    this.runClock.stop();
                    this.runClock = undefined;
                }
                if (this.openClock == undefined) {
                    this.openClock = new Anim.Clock({
                        duration: 1, target: this, speed: 5,
                        ease: new Anim.PowerEase({ mode: 'out' })
                    });
                    this.openClock.timeupdate.connect((e) => this.onOpenTick(e.target, e.progress, e.deltaTick));
                    this.openClock.begin();
                }
            }
        }
        onOpenTick(clock, progress, delta) {
            var _a;
            let end = (progress >= 1);
            if (this._isClosed)
                progress = 1 - progress;
            this.opacity = progress;
            this.transform = Ui.Matrix.createTranslate(-20 * (1 - progress), 0);
            if (end) {
                if (this.openClock)
                    this.openClock.stop();
                this.openClock = undefined;
                if (this._isClosed) {
                    this.enable();
                    this.closed.fire({ target: this });
                    (_a = this.toaster) === null || _a === void 0 ? void 0 : _a.removeToast(this);
                }
            }
        }
        set content(content) {
            this.toastContentBox.content = content;
        }
        arrangeCore(width, height) {
            super.arrangeCore(width, height);
            if ((this.openClock != undefined) && !this.openClock.isActive)
                this.openClock.begin();
        }
        onStyleChange() {
            let radius = this.getStyleProperty('radius');
            this.drawing.style.borderRadius = `${radius}px`;
        }
        static send(content, position = 'BottomLeft', duration = 2) {
            let toast = new Ui.Toast();
            toast.duration = duration;
            if (typeof (content) === 'string') {
                let t = new Ui.Text();
                t.text = content;
                t.verticalAlign = 'center';
                t.fontWeight = 'bold';
                t.margin = 5;
                t.color = Ui.Color.create('#ffffff');
                content = t;
            }
            toast.content = content;
            toast.open(position);
            return toast;
        }
        static sendError(content, position = 'BottomLeft', duration = 2) {
            return Ui.Toast.send(content, position, duration).assign({
                background: '#f04040'
            });
        }
    }
    Toast.style = {
        radius: 0
    };
    Ui.Toast = Toast;
})(Ui || (Ui = {}));
Ui.Toaster.currentTopLeft = new Ui.Toaster('TopLeft');
Ui.Toaster.currentBottomLeft = new Ui.Toaster('BottomLeft');
Ui.Toaster.currentTopRight = new Ui.Toaster('TopRight');
Ui.Toaster.currentBottomRight = new Ui.Toaster('BottomRight');
var Ui;
(function (Ui) {
    class Image extends Ui.Element {
        constructor(init) {
            super(init);
            this.loaddone = false;
            this.setSrcLock = false;
            this.ready = new Core.Events();
            this.error = new Core.Events();
            this.onAppReady = () => {
                Ui.App.ready.disconnect(this.onAppReady);
                this.onImageDelayReady();
            };
            this.imageDrawing.addEventListener('contextmenu', (event) => event.preventDefault());
            this.imageDrawing.addEventListener('load', (e) => this.onImageLoad(e));
            this.imageDrawing.addEventListener('error', (e) => this.onImageError(e));
            if (init) {
                if (init.src !== undefined)
                    this.src = init.src;
                if (init.onready)
                    this.ready.connect(init.onready);
                if (init.onerror)
                    this.error.connect(init.onerror);
            }
        }
        set onready(value) { this.ready.connect(value); }
        set onerror(value) { this.error.connect(value); }
        get src() {
            return this._src;
        }
        set src(src) {
            this.setSrcLock = true;
            this.loaddone = false;
            this._naturalWidth = undefined;
            this._naturalHeight = undefined;
            this._src = src;
            if (src === undefined)
                this.imageDrawing.removeAttribute('src');
            else
                this.imageDrawing.setAttribute('src', src);
            if ((this.imageDrawing.complete === true) && !this.loaddone) {
                this.loaddone = true;
                this._naturalWidth = this.imageDrawing.naturalWidth;
                this._naturalHeight = this.imageDrawing.naturalHeight;
                this.ready.fire({ target: this });
                this.invalidateMeasure();
            }
            this.setSrcLock = false;
        }
        get naturalWidth() {
            return this._naturalWidth;
        }
        get naturalHeight() {
            return this._naturalHeight;
        }
        get isReady() {
            return this.loaddone;
        }
        onImageError(event) {
            this.error.fire({ target: this });
        }
        onImageLoad(event) {
            if ((event.target != undefined) && (event.target.naturalWidth != undefined) && (event.target.naturalHeight != undefined)) {
                this._naturalWidth = event.target.naturalWidth;
                this._naturalHeight = event.target.naturalHeight;
                if (!this.loaddone) {
                    this.loaddone = true;
                    this.ready.fire({ target: this });
                }
                this.invalidateMeasure();
            }
            else {
                if (this.setSrcLock)
                    new Core.DelayedTask(0, this.onImageDelayReady);
                else
                    this.onImageDelayReady();
            }
        }
        onImageDelayReady() {
            if (!Ui.App.isReady)
                Ui.App.ready.connect(this.onAppReady);
            else {
                this.loaddone = true;
                if (document.body == undefined) {
                    let body = document.createElement('body');
                    document.body = body;
                }
                let imgClone = document.createElement('img');
                if (this._src)
                    imgClone.setAttribute('src', this._src);
                document.body.appendChild(imgClone);
                this._naturalWidth = imgClone.width;
                this._naturalHeight = imgClone.height;
                document.body.removeChild(imgClone);
                this.ready.fire({ target: this });
                this.invalidateMeasure();
            }
        }
        renderDrawing() {
            this.imageDrawing = document.createElement('img');
            this.imageDrawing.style.position = 'absolute';
            this.imageDrawing.style.top = '0px';
            this.imageDrawing.style.left = '0px';
            this.imageDrawing.style.width = '0px';
            this.imageDrawing.style.height = '0px';
            this.imageDrawing.style.pointerEvents = 'none';
            this.imageDrawing.style.overflow = 'hidden';
            this.imageDrawing.setAttribute('draggable', 'false');
            if (Core.Navigator.isWebkit) {
                this.imageDrawing.style.webkitUserSelect = 'none';
                this.imageDrawing.style['webkitTouchCallout'] = 'none';
            }
            else if (Core.Navigator.isGecko)
                this.imageDrawing.style['MozUserSelect'] = 'none';
            return this.imageDrawing;
        }
        measureCore(width, height) {
            if (!this.loaddone)
                return { width: 0, height: 0 };
            let size;
            if (this.width === undefined) {
                if (this.height === undefined)
                    size = { width: this._naturalWidth, height: this._naturalHeight };
                else {
                    let fixedHeight = this.height - (this.marginTop + this.marginBottom);
                    size = {
                        width: (this._naturalWidth * fixedHeight) / this._naturalHeight,
                        height: fixedHeight
                    };
                }
            }
            else {
                if (this.height === undefined) {
                    let fixedWidth = this.width - (this.marginLeft + this.marginRight);
                    size = {
                        width: fixedWidth,
                        height: (this._naturalHeight * fixedWidth) / this._naturalWidth
                    };
                }
                else
                    size = { width: 0, height: 0 };
            }
            return size;
        }
        arrangeCore(width, height) {
            if (this.imageDrawing !== undefined) {
                this.imageDrawing.style.width = width + 'px';
                this.imageDrawing.style.height = height + 'px';
            }
        }
    }
    Ui.Image = Image;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Loading extends Ui.CanvasElement {
        constructor(init) {
            super(init);
            this._value = 'infinite';
            this.ease = new Anim.PowerEase({ mode: 'inout' });
            this.clock = new Anim.Clock({ repeat: 'forever', duration: 2 });
            this.clock.timeupdate.connect((e) => this.invalidateDraw());
        }
        onVisible() {
            super.onVisible();
            if (this._value == 'infinite')
                this.clock.begin();
        }
        onHidden() {
            super.onHidden();
            this.clock.stop();
        }
        updateCanvas(ctx) {
            let p = this.clock.progress;
            if (p === undefined)
                p = 0;
            let p2 = (p > 0.8) ? (1 - ((p - 0.8) * 5)) : (p / 0.8);
            let w = this.layoutWidth;
            let h = this.layoutHeight;
            let x = w / 2;
            let y = h / 2;
            let lineWidth = Math.max(2, Math.min(5, Math.min(w, h) * 5 / 60));
            let radius = ((Math.min(w, h) - lineWidth) / 2) - 5;
            let startAngle = Math.PI * 2 * p;
            if (p > 0.8)
                startAngle = Math.PI * 2 * p - (Math.PI * 2 * 5 * this.ease.ease(p2) / 6);
            let endAngle = startAngle + (Math.PI / 4) + (Math.PI * 2 * 5 * this.ease.ease(p2) / 6);
            if (this._value != 'infinite') {
                startAngle = 0;
                endAngle = Math.PI * 2 * this._value;
            }
            ctx.strokeStyle = Ui.Color.create(this.getStyleProperty('color')).getCssRgba();
            ctx.beginPath();
            ctx.arc(x, y, radius, startAngle, endAngle, false);
            ctx.lineWidth = lineWidth;
            ctx.stroke();
        }
        measureCore(width, height) {
            return { width: 30, height: 30 };
        }
        set value(value) {
            if (value != this._value) {
                this._value = value;
                if (value == 'infinite' && this.isVisible)
                    this.clock.begin();
                else
                    this.clock.stop();
                this.invalidateDraw();
            }
        }
        get value() {
            return this._value;
        }
    }
    Loading.style = {
        color: new Ui.Color(0.27, 0.52, 0.9)
    };
    Ui.Loading = Loading;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Entry extends Ui.Element {
        constructor(init) {
            super(init);
            this._value = '';
            this._passwordMode = false;
            this.captureValidated = false;
            this.changed = new Core.Events();
            this.validated = new Core.Events();
            this.selectable = true;
            this.focusable = true;
            this.drawing.addEventListener('change', (e) => this.onChange(e));
            this.drawing.addEventListener('paste', (e) => this.onPaste(e));
            this.drawing.addEventListener('click', (e) => {
                if (!this.isDisabled)
                    e.stopImmediatePropagation();
            });
            this.drawing.addEventListener('keyup', (e) => this.onKeyUp(e));
            this.drawing.addEventListener('keydown', (e) => this.onKeyDown(e));
            if (init) {
                if (init.passwordMode !== undefined)
                    this.passwordMode = init.passwordMode;
                if (init.fontSize !== undefined)
                    this.fontSize = init.fontSize;
                if (init.fontFamily !== undefined)
                    this.fontFamily = init.fontFamily;
                if (init.fontWeight !== undefined)
                    this.fontWeight = init.fontWeight;
                if (init.color !== undefined)
                    this.color = init.color;
                if (init.value !== undefined)
                    this.value = init.value;
                if (init.captureValidated !== undefined)
                    this.captureValidated = init.captureValidated;
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
                if (init.onvalidated)
                    this.validated.connect(init.onvalidated);
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        set onvalidated(value) { this.validated.connect(value); }
        get passwordMode() {
            return this._passwordMode;
        }
        set passwordMode(passwordMode) {
            if (this._passwordMode != passwordMode) {
                this._passwordMode = passwordMode;
                if (this._passwordMode)
                    this.drawing.setAttribute('type', 'password');
                else
                    this.drawing.setAttribute('type', 'text');
            }
        }
        get fontSize() {
            if (this._fontSize != undefined)
                return this._fontSize;
            else
                return this.getStyleProperty('fontSize');
        }
        set fontSize(fontSize) {
            if (this._fontSize != fontSize) {
                this._fontSize = fontSize;
                this.drawing.style.fontSize = this.fontSize + 'px';
                this.invalidateMeasure();
            }
        }
        get fontFamily() {
            if (this._fontFamily != undefined)
                return this._fontFamily;
            else
                return this.getStyleProperty('fontFamily');
        }
        set fontFamily(fontFamily) {
            if (this._fontFamily != fontFamily) {
                this._fontFamily = fontFamily;
                this.drawing.style.fontFamily = this.fontFamily;
                this.invalidateMeasure();
            }
        }
        get fontWeight() {
            if (this._fontWeight != undefined)
                return this._fontWeight;
            else
                return this.getStyleProperty('fontWeight');
        }
        set fontWeight(fontWeight) {
            if (this._fontWeight != fontWeight) {
                this._fontWeight = fontWeight;
                this.drawing.style.fontWeight = this.fontWeight;
                this.invalidateMeasure();
            }
        }
        getColor() {
            if (this._color != undefined)
                return this._color;
            else
                return Ui.Color.create(this.getStyleProperty('color'));
        }
        set color(color) {
            if (this._color != color) {
                this._color = Ui.Color.create(color);
                this.drawing.style.color = this.getColor().getCssRgba();
            }
        }
        get value() {
            return this._value;
        }
        set value(value) {
            if (value == undefined)
                value = '';
            this._value = value;
            this.drawing.value = this._value;
        }
        get inputMode() {
            return this.drawing.inputMode;
        }
        set inputMode(value) {
            this.drawing.inputMode = value;
        }
        get type() {
            return this.drawing.type;
        }
        set type(value) {
            this.drawing.type = value;
            this.invalidateMeasure();
        }
        get autocomplete() {
            return this.drawing.autocomplete;
        }
        set autocomplete(value) {
            this.drawing.autocomplete = value;
        }
        onPaste(event) {
            event.stopPropagation();
            new Core.DelayedTask(0, () => this.onAfterPaste());
        }
        onAfterPaste() {
            if (this.drawing.value != this._value) {
                this._value = this.drawing.value;
                this.changed.fire({ target: this, value: this._value });
            }
        }
        onChange(event) {
            if (this.drawing.value != this._value) {
                this._value = this.drawing.value;
                this.changed.fire({ target: this, value: this._value });
            }
        }
        onKeyDown(event) {
            let key = event.which;
            if ((key == 37) || (key == 39) || (key == 46) || (key == 8))
                event.stopPropagation();
            if (key == 13 && this.captureValidated) {
                event.stopPropagation();
                event.preventDefault();
            }
        }
        onKeyUp(event) {
            let key = event.which;
            if ((key == 37) || (key == 39) || (key == 46) || (key == 8))
                event.stopPropagation();
            if (this.drawing.value !== this._value) {
                this._value = this.drawing.value;
                this.changed.fire({ target: this, value: this._value });
            }
            if (key == 13) {
                this.validated.fire({ target: this, value: this._value });
                if (this.captureValidated) {
                    event.stopPropagation();
                    event.preventDefault();
                }
            }
        }
        renderDrawing() {
            let drawing = document.createElement('input');
            drawing.setAttribute('type', 'text');
            drawing.style.opacity = '1';
            drawing.style.border = '0px';
            drawing.style.margin = '0px';
            drawing.style.padding = '0px';
            drawing.style.outline = 'none';
            drawing.style.background = 'none';
            if (Core.Navigator.isWebkit)
                drawing.style.webkitAppearance = 'none';
            drawing.style.fontSize = this.fontSize + 'px';
            drawing.style.fontFamily = this.fontFamily;
            drawing.style.fontWeight = this.fontWeight;
            drawing.style.color = this.getColor().getCssRgba();
            return drawing;
        }
        measureCore(width, height) {
            this.drawing.style.height = '';
            return { width: this.type == 'text' ? 10 : 30, height: Math.max(this.fontSize, this.drawing.scrollHeight) };
        }
        arrangeCore(width, height) {
            this.drawing.style.width = width + 'px';
            this.drawing.style.height = height + 'px';
        }
        onDisable() {
            super.onDisable();
            this.drawing.blur();
            this.drawing.style.cursor = 'default';
            this.drawing.disabled = true;
        }
        onEnable() {
            super.onEnable();
            this.drawing.style.cursor = 'auto';
            this.drawing.disabled = false;
        }
        onStyleChange() {
            this.drawing.style.fontSize = this.fontSize + 'px';
            this.drawing.style.fontFamily = this.fontFamily;
            this.drawing.style.fontWeight = this.fontWeight;
            this.drawing.style.color = this.getColor().getCssRgba();
            this.invalidateMeasure();
        }
    }
    Entry.style = {
        color: new Ui.Color(0, 0, 0),
        fontSize: 14,
        fontFamily: 'Sans-serif',
        fontWeight: 'normal'
    };
    Ui.Entry = Entry;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Fixed extends Ui.Container {
        constructor(init) {
            super(init);
            this.resize = new Core.Events();
        }
        set onresize(value) { this.resize.connect(value); }
        setPosition(item, x, y) {
            if (x !== undefined)
                item['Ui.Fixed.x'] = x;
            if (y !== undefined)
                item['Ui.Fixed.y'] = y;
            this.updateItemTransform(item);
        }
        setRelativePosition(item, x, y, absolute = false) {
            if (x !== undefined)
                item['Ui.Fixed.relativeX'] = x;
            if (y !== undefined)
                item['Ui.Fixed.relativeY'] = y;
            item['Ui.Fixed.relativeAbsolute'] = absolute === true;
            this.updateItemTransform(item);
        }
        append(child, x, y) {
            child['Ui.Fixed.x'] = x;
            child['Ui.Fixed.y'] = y;
            this.appendChild(child);
        }
        remove(child) {
            delete (child['Ui.Fixed.x']);
            delete (child['Ui.Fixed.y']);
            delete (child['Ui.Fixed.relativeX']);
            delete (child['Ui.Fixed.relativeY']);
            delete (child['Ui.Fixed.relativeAbsolute']);
            this.removeChild(child);
        }
        updateItemTransform(child) {
            let pos = this.getItemPosition(child);
            child.arrange(pos.x, pos.y, child.measureWidth, child.measureHeight);
        }
        getItemPosition(child) {
            let x = 0;
            if (child['Ui.Fixed.x'] !== undefined)
                x = child['Ui.Fixed.x'];
            if (child['Ui.Fixed.relativeX'] !== undefined)
                x -= child['Ui.Fixed.relativeX'] * ((child['Ui.Fixed.relativeAbsolute'] === true) ? 1 : child.measureWidth);
            let y = 0;
            if (child['Ui.Fixed.y'] !== undefined)
                y = child['Ui.Fixed.y'];
            if (child['Ui.Fixed.relativeY'] !== undefined)
                y -= child['Ui.Fixed.relativeY'] * ((child['Ui.Fixed.relativeAbsolute'] === true) ? 1 : child.measureHeight);
            return new Ui.Point(x, y);
        }
        measureCore(width, height) {
            for (let i = 0; i < this.children.length; i++)
                this.children[i].measure(width, height);
            return { width: 0, height: 0 };
        }
        arrangeCore(width, height) {
            this.resize.fire({ target: this, width: width, height: height });
            for (let i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                let pos = this.getItemPosition(child);
                child.arrange(pos.x, pos.y, child.measureWidth, child.measureHeight);
            }
        }
        onChildInvalidateMeasure(child, event) {
            if (event !== 'remove') {
                child.measure(this.layoutWidth, this.layoutHeight);
                let pos = this.getItemPosition(child);
                child.arrange(pos.x, pos.y, child.measureWidth, child.measureHeight);
            }
        }
        onChildInvalidateArrange(child) {
            let pos = this.getItemPosition(child);
            child.arrange(pos.x, pos.y, child.measureWidth, child.measureHeight);
        }
    }
    Ui.Fixed = Fixed;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class ToolBar extends Ui.Container {
        constructor(init) {
            super(init);
            this.scroll = new Ui.ScrollingArea();
            this.scroll.scrollVertical = false;
            this.appendChild(this.scroll);
            this.hbox = new Ui.HBox();
            this.hbox.eventsHidden = true;
            this.scroll.content = this.hbox;
        }
        append(child, resizable = false) {
            this.hbox.append(child, resizable);
        }
        remove(child) {
            this.hbox.remove(child);
        }
        set content(content) {
            this.hbox.content = content;
        }
        measureCore(width, height) {
            return this.scroll.measure(width, height);
        }
        arrangeCore(width, height) {
            this.scroll.arrange(0, 0, width, height);
        }
        onStyleChange() {
            let spacing = this.getStyleProperty('spacing');
            this.hbox.margin = spacing;
            this.hbox.spacing = spacing;
        }
    }
    ToolBar.style = {
        spacing: 3
    };
    Ui.ToolBar = ToolBar;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class TextBgGraphic extends Ui.CanvasElement {
        constructor() {
            super(...arguments);
            this.textHasFocus = false;
        }
        set hasFocus(hasFocus) {
            if (this.textHasFocus !== hasFocus) {
                this.textHasFocus = hasFocus;
                this.invalidateDraw();
            }
        }
        get background() {
            let color;
            if (this.textHasFocus)
                color = Ui.Color.create(this.getStyleProperty('focusBackground'));
            else
                color = Ui.Color.create(this.getStyleProperty('background'));
            return color;
        }
        get backgroundBorder() {
            if (this.textHasFocus)
                return Ui.Color.create(this.getStyleProperty('focusBackgroundBorder'));
            else
                return Ui.Color.create(this.getStyleProperty('backgroundBorder'));
        }
        updateCanvas(ctx) {
            let w = this.layoutWidth;
            let h = this.layoutHeight;
            let radius = this.getStyleProperty('radius');
            radius = Math.max(0, Math.min(radius, Math.min(w / 2, h / 2)));
            let borderWidth = this.getStyleProperty('borderWidth');
            ctx.lineWidth = borderWidth;
            let lh = Math.max(8, h - 4 - 16);
            if (this.isDisabled)
                ctx.globalAlpha = 0.2;
            ctx.fillStyle = this.background.getCssRgba();
            ctx.beginPath();
            ctx.roundRect(0 + borderWidth / 2, 0 + borderWidth / 2, w - borderWidth, h - borderWidth, radius, radius, radius, radius);
            ctx.closePath();
            ctx.fill();
            if (borderWidth > 0) {
                ctx.strokeStyle = this.backgroundBorder.getCssRgba();
                ctx.stroke();
            }
        }
        onDisable() {
            this.invalidateDraw();
        }
        onEnable() {
            this.invalidateDraw();
        }
        onStyleChange() {
            this.invalidateDraw();
        }
    }
    TextBgGraphic.style = {
        radius: 2,
        borderWidth: 1,
        background: Ui.Color.create('rgba(120,120,120,0.2)'),
        focusBackground: Ui.Color.create('rgba(33,211,255,0.4)'),
        backgroundBorder: Ui.Color.create('rgba(60,60,60,0.2)'),
        focusBackgroundBorder: Ui.Color.create('rgba(60,60,60,0.2)')
    };
    Ui.TextBgGraphic = TextBgGraphic;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class TextField extends Ui.LBox {
        constructor(init) {
            super(init);
            this.changed = new Core.Events();
            this.validated = new Core.Events();
            this.graphic = new Ui.TextBgGraphic();
            this.append(this.graphic);
            this.textholder = new Ui.Label({
                opacity: 0.5,
                horizontalAlign: 'left', verticalAlign: 'center',
                marginTop: 7, marginBottom: 7,
                marginLeft: 10, marginRight: 10
            });
            this.append(this.textholder);
            this.entry = new Ui.Entry({
                margin: 7,
                marginLeft: 10,
                marginRight: 10,
                fontSize: 16,
                verticalAlign: 'center'
            });
            this.entry.focused.connect(() => this.onEntryFocus());
            this.entry.blurred.connect(() => this.onEntryBlur());
            this.append(this.entry);
            this.entry.changed.connect((e) => this.onEntryChange(e.target, e.value));
            this.entry.validated.connect(() => this.validated.fire({ target: this }));
            if (init) {
                if (init.textHolder !== undefined)
                    this.textHolder = init.textHolder;
                if (init.passwordMode !== undefined)
                    this.passwordMode = init.passwordMode;
                if (init.value !== undefined)
                    this.value = init.value;
                if (init.captureValidated !== undefined)
                    this.captureValidated = init.captureValidated;
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
                if (init.onvalidated)
                    this.validated.connect(init.onvalidated);
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        set onvalidated(value) { this.validated.connect(value); }
        set textHolder(text) {
            this.textholder.text = text;
        }
        set passwordMode(passwordMode) {
            this.entry.passwordMode = passwordMode;
        }
        get value() {
            return this.entry.value;
        }
        set value(value) {
            this.entry.value = value;
            if (((value === undefined) || (value === '')) && !this.entry.hasFocus)
                this.textholder.show();
            else
                this.textholder.hide();
        }
        get captureValidated() {
            return this.entry.captureValidated;
        }
        set captureValidated(value) {
            this.entry.captureValidated = value;
        }
        get inputMode() {
            return this.entry.inputMode;
        }
        set inputMode(value) {
            this.entry.inputMode = value;
        }
        get type() {
            return this.entry.type;
        }
        set type(value) {
            this.entry.type = value;
        }
        get autocomplete() {
            return this.entry.autocomplete;
        }
        set autocomplete(value) {
            this.entry.autocomplete = value;
        }
        onEntryFocus() {
            this.textholder.hide();
            this.graphic.hasFocus = true;
        }
        onEntryBlur() {
            if (this.value === '')
                this.textholder.show();
            this.graphic.hasFocus = false;
        }
        onEntryChange(entry, value) {
            this.changed.fire({ target: this, value: value });
        }
        onStyleChange() {
            let padding = this.getStyleProperty('padding');
            this.entry.marginTop = padding;
            this.entry.marginBottom = padding;
            this.entry.marginLeft = padding + 3;
            this.entry.marginRight = padding + 3;
            this.textholder.marginTop = padding;
            this.textholder.marginBottom = padding;
            this.textholder.marginLeft = padding + 3;
            this.textholder.marginRight = padding + 3;
        }
    }
    TextField.style = {
        padding: 7
    };
    Ui.TextField = TextField;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class CheckBoxGraphic extends Ui.CanvasElement {
        constructor() {
            super();
            this._isDown = false;
            this._isChecked = false;
            this._borderWidth = 2;
            this._radius = 3;
        }
        get isDown() {
            return this._isDown;
        }
        set isDown(isDown) {
            if (this._isDown != isDown) {
                this._isDown = isDown;
                this.invalidateDraw();
            }
        }
        get isChecked() {
            return this._isChecked;
        }
        set isChecked(isChecked) {
            if (this._isChecked != isChecked) {
                this._isChecked = isChecked;
                this.invalidateDraw();
            }
        }
        get radius() {
            return this._radius;
        }
        set radius(radius) {
            if (this._radius !== radius) {
                this._radius = radius;
                this.invalidateDraw();
            }
        }
        get color() {
            if (this._color)
                return this._color;
            return Ui.Color.create(this.getStyleProperty('color'));
        }
        set color(value) {
            this.setColor(value);
        }
        getColor() {
            return this.color;
        }
        setColor(color) {
            if (this._color !== color) {
                this._color = Ui.Color.create(color);
                this.invalidateDraw();
            }
        }
        get borderWidth() {
            return this._borderWidth;
        }
        set borderWidth(borderWidth) {
            if (this._borderWidth !== borderWidth) {
                this._borderWidth = borderWidth;
                this.invalidateDraw();
            }
        }
        get checkColor() {
            if (this._checkColor)
                return this._checkColor;
            return Ui.Color.create(this.getStyleProperty('checkColor'));
        }
        set checkColor(value) {
            this.setCheckColor(value);
        }
        setCheckColor(color) {
            if (this._checkColor !== color) {
                this._checkColor = Ui.Color.create(color);
                this.invalidateDraw();
            }
        }
        getCheckColor() {
            let deltaY = 0;
            if (this.isDown)
                deltaY = 0.20;
            let yuv = this.checkColor.getYuv();
            return Ui.Color.createFromYuv(yuv.y + deltaY, yuv.u, yuv.v);
        }
        updateCanvas(ctx) {
            let w = this.layoutWidth;
            let h = this.layoutHeight;
            let cx = w / 2;
            let cy = h / 2;
            let radius = Math.min(this.radius, 10);
            if (this.isDown)
                ctx.globalAlpha = 0.8;
            if (this.isDisabled)
                ctx.globalAlpha = 0.4;
            if (!this.isChecked) {
                ctx.strokeStyle = this.getColor().getCssRgba();
                ctx.lineWidth = this.borderWidth;
                ctx.beginPath();
                ctx.roundRect(cx - 10 + this.borderWidth / 2, cy - 10 + this.borderWidth / 2, 20 - this.borderWidth, 20 - this.borderWidth, radius, radius, radius, radius);
                ctx.closePath();
                ctx.stroke();
            }
            else {
                ctx.fillStyle = this.getColor().getCssRgba();
                ctx.beginPath();
                ctx.roundRect(cx - 10, cy - 10, 20, 20, radius, radius, radius, radius);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                let iconSize = 20;
                let path = Ui.Icon.getPath('check');
                let scale = iconSize / 48;
                ctx.save();
                ctx.translate((w - iconSize) / 2, (h - iconSize) / 2);
                ctx.scale(scale, scale);
                ctx.fillStyle = this.getCheckColor().getCssRgba();
                ctx.beginPath();
                ctx.svgPath(path);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }
        measureCore(width, height) {
            return { width: 30, height: 30 };
        }
        onDisable() {
            this.invalidateDraw();
        }
        onEnable() {
            this.invalidateDraw();
        }
    }
    CheckBoxGraphic.style = {
        color: 'rgba(120,120,120,0.2)',
        checkColor: 'rgba(33,211,255,0.4)'
    };
    Ui.CheckBoxGraphic = CheckBoxGraphic;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class CheckBox extends Ui.Pressable {
        constructor(init) {
            super(init);
            this.bg = new Ui.SimpleButtonBackground();
            this._isToggled = false;
            this.changed = new Core.Events();
            this.toggled = new Core.Events();
            this.untoggled = new Core.Events();
            this.role = 'checkbox';
            this.drawing.setAttribute('aria-checked', 'false');
            this.append(this.bg.assign({
                radius: 0
            }));
            this.hbox = new Ui.HBox().assign({ margin: 2 });
            this.append(this.hbox);
            this.graphic = new Ui.CheckBoxGraphic();
            this.hbox.append(this.graphic);
            this.downed.connect(() => this.onCheckBoxDown());
            this.upped.connect(() => this.onCheckBoxUp());
            this.focused.connect(() => this.onCheckFocus());
            this.blurred.connect(() => this.onCheckBlur());
            this.pressed.connect(() => this.onCheckPress());
            if (init) {
                if (init.value !== undefined)
                    this.value = init.value;
                if (init.text !== undefined)
                    this.text = init.text;
                if (init.content !== undefined)
                    this.content = init.content;
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
                if (init.ontoggled)
                    this.toggled.connect(init.ontoggled);
                if (init.onuntoggled)
                    this.untoggled.connect(init.onuntoggled);
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        set ontoggled(value) { this.toggled.connect(value); }
        set onuntoggled(value) { this.untoggled.connect(value); }
        get isToggled() {
            return this._isToggled;
        }
        get value() {
            return this.isToggled;
        }
        set value(value) {
            if (value)
                this.toggle();
            else
                this.untoggle();
        }
        get text() {
            return this._text;
        }
        set text(text) {
            if (text === undefined) {
                if (this.contentBox !== undefined) {
                    this.hbox.remove(this.contentBox);
                    this.contentBox = undefined;
                }
                this._text = undefined;
                this._content = undefined;
            }
            else {
                if (this._text !== undefined) {
                    this._text = text;
                    this.contentBox.text = this._text;
                }
                else {
                    if (this._content !== undefined) {
                        this.hbox.remove(this.contentBox);
                        this._content = undefined;
                    }
                    this._text = text;
                    this.contentBox = new Ui.Text({ margin: 8, text: this._text, verticalAlign: 'center' });
                    this.hbox.append(this.contentBox, true);
                }
            }
        }
        get content() {
            return this._content;
        }
        set content(content) {
            if (content === undefined) {
                if (this.contentBox !== undefined) {
                    this.hbox.remove(this.contentBox);
                    this.contentBox = undefined;
                }
                this._text = undefined;
                this._content = undefined;
            }
            else {
                if (this._text !== undefined) {
                    this.hbox.remove(this.contentBox);
                    this._text = undefined;
                }
                if (this._content !== undefined)
                    this.contentBox.remove(this._content);
                else {
                    this.contentBox = new Ui.LBox().assign({ padding: 8, verticalAlign: 'center', resizable: true });
                    this.hbox.append(this.contentBox);
                }
                this._content = content;
                this.contentBox.append(this._content);
            }
        }
        toggle() {
            this.onToggle();
        }
        untoggle() {
            this.onUntoggle();
        }
        onCheckPress() {
            if (!this._isToggled)
                this.onToggle();
            else
                this.onUntoggle();
        }
        onToggle() {
            if (!this._isToggled) {
                this._isToggled = true;
                this.drawing.setAttribute('aria-checked', 'true');
                this.toggled.fire({ target: this });
                this.graphic.isChecked = true;
                this.graphic.color = this.getStyleProperty('activeColor');
                this.changed.fire({ target: this, value: true });
            }
        }
        onUntoggle() {
            if (this._isToggled) {
                this._isToggled = false;
                this.drawing.setAttribute('aria-checked', 'false');
                this.untoggled.fire({ target: this });
                this.graphic.isChecked = false;
                this.graphic.color = this.getStyleProperty('color');
                this.changed.fire({ target: this, value: false });
            }
        }
        onCheckFocus() {
            if (!this.getIsMouseFocus()) {
                this.graphic.color = this.getStyleProperty('focusColor');
                this.bg.border = this.getStyleProperty('focusBackgroundBorder');
            }
        }
        onCheckBlur() {
            if (this._isToggled)
                this.graphic.color = this.getStyleProperty('activeColor');
            else
                this.graphic.color = this.getStyleProperty('color');
            this.bg.border = this.getStyleProperty('backgroundBorder');
        }
        onCheckBoxDown() {
            this.graphic.isDown = true;
        }
        onCheckBoxUp() {
            this.graphic.isDown = false;
        }
        onStyleChange() {
            if (this.hasFocus) {
                this.graphic.color = this.getStyleProperty('focusColor');
                this.bg.border = this.getStyleProperty('focusBackgroundBorder');
            }
            else {
                this.bg.border = this.getStyleProperty('backgroundBorder');
                if (this._isToggled)
                    this.graphic.color = this.getStyleProperty('activeColor');
                else
                    this.graphic.color = this.getStyleProperty('color');
            }
            this.graphic.checkColor = this.getStyleProperty('checkColor');
            this.graphic.borderWidth = this.getStyleProperty('checkWidth');
            this.graphic.radius = this.getStyleProperty('radius');
            this.bg.borderWidth = parseInt(this.getStyleProperty('borderWidth'));
            this.bg.background = this.getStyleProperty('background');
            this.bg.radius = parseInt(this.getStyleProperty('borderRadius'));
        }
    }
    CheckBox.style = {
        borderWidth: 0,
        checkWidth: 2,
        color: '#444444',
        activeColor: '#07a0e5',
        focusColor: '#21d3ff',
        checkColor: '#ffffff',
        background: 'rgba(250,250,250,0)',
        backgroundBorder: 'rgba(250,250,250,0)',
        focusBackgroundBorder: '#21d3ff',
        radius: 3,
        borderRadius: 4
    };
    Ui.CheckBox = CheckBox;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Frame extends Ui.CanvasElement {
        constructor(init) {
            super(init);
            this._fill = new Ui.Color();
            this._radiusTopLeft = 0;
            this._radiusTopRight = 0;
            this._radiusBottomLeft = 0;
            this._radiusBottomRight = 0;
            this._frameWidth = 10;
            if (init) {
                if (init.frameWidth !== undefined)
                    this.frameWidth = init.frameWidth;
                if (init.fill !== undefined)
                    this.fill = init.fill;
                if (init.radius !== undefined)
                    this.radius = init.radius;
                if (init.radiusTopLeft !== undefined)
                    this.radiusTopLeft = init.radiusTopLeft;
                if (init.radiusTopRight !== undefined)
                    this.radiusTopRight = init.radiusTopRight;
                if (init.radiusBottomLeft !== undefined)
                    this.radiusBottomLeft = init.radiusBottomLeft;
                if (init.radiusBottomRight !== undefined)
                    this.radiusBottomRight = init.radiusBottomRight;
            }
        }
        get frameWidth() {
            return this._frameWidth;
        }
        set frameWidth(frameWidth) {
            if (frameWidth != this._frameWidth) {
                this._frameWidth = frameWidth;
                this.invalidateDraw();
            }
        }
        set fill(fill) {
            if (this._fill != fill) {
                if (typeof (fill) === 'string')
                    fill = Ui.Color.create(fill);
                this._fill = fill;
                this.invalidateDraw();
            }
        }
        set radius(radius) {
            this.radiusTopLeft = radius;
            this.radiusTopRight = radius;
            this.radiusBottomLeft = radius;
            this.radiusBottomRight = radius;
        }
        get radiusTopLeft() {
            return this._radiusTopLeft;
        }
        set radiusTopLeft(radiusTopLeft) {
            if (this._radiusTopLeft != radiusTopLeft) {
                this._radiusTopLeft = radiusTopLeft;
                this.invalidateDraw();
            }
        }
        get radiusTopRight() {
            return this._radiusTopRight;
        }
        set radiusTopRight(radiusTopRight) {
            if (this._radiusTopRight != radiusTopRight) {
                this._radiusTopRight = radiusTopRight;
                this.invalidateDraw();
            }
        }
        get radiusBottomLeft() {
            return this._radiusBottomLeft;
        }
        set radiusBottomLeft(radiusBottomLeft) {
            if (this._radiusBottomLeft != radiusBottomLeft) {
                this._radiusBottomLeft = radiusBottomLeft;
                this.invalidateDraw();
            }
        }
        get radiusBottomRight() {
            return this._radiusBottomRight;
        }
        set radiusBottomRight(radiusBottomRight) {
            if (this._radiusBottomRight != radiusBottomRight) {
                this._radiusBottomRight = radiusBottomRight;
                this.invalidateDraw();
            }
        }
        updateCanvas(ctx) {
            let w = this.layoutWidth;
            let h = this.layoutHeight;
            let topLeft = this._radiusTopLeft;
            let topRight = this._radiusTopRight;
            if (topLeft + topRight > w) {
                topLeft = w / 2;
                topRight = w / 2;
            }
            let bottomLeft = this._radiusBottomLeft;
            let bottomRight = this._radiusBottomRight;
            if (bottomLeft + bottomRight > w) {
                bottomLeft = w / 2;
                bottomRight = w / 2;
            }
            if (topLeft + bottomLeft > h) {
                topLeft = h / 2;
                bottomLeft = h / 2;
            }
            if (topRight + bottomRight > h) {
                topRight = h / 2;
                bottomRight = h / 2;
            }
            ctx.beginPath();
            ctx.roundRect(0, 0, w, h, topLeft, topRight, bottomRight, bottomLeft);
            ctx.roundRect(this._frameWidth, this._frameWidth, w - (this._frameWidth * 2), h - (this._frameWidth * 2), Math.max(0, topLeft - this.frameWidth), Math.max(0, topRight - this.frameWidth), Math.max(0, bottomRight - this.frameWidth), Math.max(0, bottomLeft - this.frameWidth), true);
            ctx.closePath();
            if (this._fill instanceof Ui.Color)
                ctx.fillStyle = this._fill.getCssRgba();
            else if (this._fill instanceof Ui.LinearGradient)
                ctx.fillStyle = this._fill.getCanvasGradient(ctx, w, h);
            ctx.fill();
        }
    }
    Ui.Frame = Frame;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class ScaleBox extends Ui.Container {
        constructor(init) {
            super(init);
            this._fixedWidth = 400;
            this._fixedHeight = 300;
            this._itemAlign = 'center';
            if (init) {
                if (init.fixedWidth !== undefined)
                    this.fixedWidth = init.fixedWidth;
                if (init.fixedHeight !== undefined)
                    this.fixedHeight = init.fixedHeight;
                if (init.itemAlign !== undefined)
                    this.itemAlign = init.itemAlign;
                if (init.content !== undefined)
                    this.content = init.content;
            }
        }
        setFixedSize(width, height) {
            let changed = false;
            if ((width !== undefined) && (this._fixedWidth !== width)) {
                this._fixedWidth = width;
                changed = true;
            }
            if ((height !== undefined) && (this._fixedHeight !== height)) {
                this._fixedHeight = height;
                changed = true;
            }
            if (changed)
                this.invalidateMeasure();
        }
        set fixedWidth(width) {
            this.setFixedSize(width, undefined);
        }
        set fixedHeight(height) {
            this.setFixedSize(undefined, height);
        }
        set content(content) {
            this.clear();
            if (content) {
                content.setTransformOrigin(0, 0);
                this.appendChild(content);
            }
        }
        get itemAlign() {
            return this._itemAlign;
        }
        set itemAlign(align) {
            if (this._itemAlign != align) {
                this._itemAlign = align;
                this.invalidateArrange();
            }
        }
        measureCore(width, height) {
            let ratio = this._fixedWidth / this._fixedHeight;
            let aratio = width / height;
            let aw, ah;
            if (ratio > aratio) {
                aw = width;
                ah = aw / ratio;
            }
            else {
                ah = height;
                aw = ah * ratio;
            }
            for (let i = 0; i < this.children.length; i++)
                this.children[i].measure(this._fixedWidth, this._fixedHeight);
            return { width: aw, height: ah };
        }
        arrangeCore(width, height) {
            let ratio = this._fixedWidth / this._fixedHeight;
            let aratio = width / height;
            let aw, ah, ax, ay;
            if (ratio > aratio) {
                aw = width;
                ah = aw / ratio;
                ax = 0;
                ay = (height - ah) / 2;
            }
            else {
                ah = height;
                aw = ah * ratio;
                ay = 0;
                if (this._itemAlign == 'left')
                    ax = 0;
                else if (this._itemAlign == 'right')
                    ax = width - aw;
                else
                    ax = (width - aw) / 2;
            }
            let scale = aw / this._fixedWidth;
            for (let i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                child.arrange(0, 0, this._fixedWidth, this._fixedHeight);
                child.transform = Ui.Matrix.createTranslate(ax, ay).multiply(Ui.Matrix.createScale(scale, scale));
            }
        }
    }
    Ui.ScaleBox = ScaleBox;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class TextArea extends Ui.Element {
        constructor(init) {
            super(init);
            this._value = '';
            this.changed = new Core.Events();
            this.selectable = true;
            this.focusable = true;
            this.drawing.addEventListener('input', (e) => this.onChange(e));
            this.drawing.addEventListener('paste', (e) => this.onPaste(e));
            this.drawing.addEventListener('keydown', (e) => this.onKeyDown(e));
            this.drawing.addEventListener('keyup', (e) => this.onKeyUp(e));
            if (init) {
                if (init.fontSize !== undefined)
                    this.fontSize = init.fontSize;
                if (init.fontFamily !== undefined)
                    this.fontFamily = init.fontFamily;
                if (init.fontWeight !== undefined)
                    this.fontWeight = init.fontWeight;
                if (init.color !== undefined)
                    this.color = init.color;
                if (init.value !== undefined)
                    this.value = init.value;
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        set fontSize(fontSize) {
            if (this._fontSize != fontSize) {
                this._fontSize = fontSize;
                this.drawing.style.fontSize = this.fontSize + 'px';
                this.invalidateMeasure();
            }
        }
        get fontSize() {
            if (this._fontSize !== undefined)
                return this._fontSize;
            else
                return this.getStyleProperty('fontSize');
        }
        set fontFamily(fontFamily) {
            if (this._fontFamily !== fontFamily) {
                this._fontFamily = fontFamily;
                this.drawing.style.fontFamily = this.fontFamily;
                this.invalidateMeasure();
            }
        }
        get fontFamily() {
            if (this._fontFamily !== undefined)
                return this._fontFamily;
            else
                return this.getStyleProperty('fontFamily');
        }
        set fontWeight(fontWeight) {
            if (this._fontWeight !== fontWeight) {
                this._fontWeight = fontWeight;
                this.drawing.style.fontWeight = this.fontWeight;
                this.invalidateMeasure();
            }
        }
        get fontWeight() {
            if (this._fontWeight !== undefined)
                return this._fontWeight;
            else
                return this.getStyleProperty('fontWeight');
        }
        set color(color) {
            if (this._color !== color) {
                this._color = Ui.Color.create(color);
                this.drawing.style.color = this.getColor().getCssRgba();
            }
        }
        getColor() {
            if (this._color !== undefined)
                return this._color;
            else
                return Ui.Color.create(this.getStyleProperty('color'));
        }
        get value() {
            return this.drawing.value;
        }
        set value(value) {
            if ((value === null) || (value === undefined))
                this.drawing.value = '';
            else
                this.drawing.value = value;
            this.invalidateMeasure();
        }
        setOffset(offsetX, offsetY) {
            this.drawing.scrollLeft = offsetX;
            this.drawing.scrollTop = offsetY;
        }
        get offsetX() {
            return this.drawing.scrollLeft;
        }
        get offsetY() {
            return this.drawing.scrollTop;
        }
        onPaste(event) {
            event.stopPropagation();
            new Core.DelayedTask(0, () => this.onAfterPaste());
        }
        onAfterPaste() {
            if (this.drawing.value != this._value) {
                this._value = this.drawing.value;
                this.changed.fire({ target: this, value: this._value });
                this.invalidateMeasure();
            }
        }
        onChange(event) {
            if (this.drawing.value != this._value) {
                this._value = this.drawing.value;
                this.changed.fire({ target: this, value: this._value });
                this.invalidateMeasure();
            }
        }
        onKeyDown(event) {
            let key = event.which;
            if ((key == 37) || (key == 39) || (key == 38) || (key == 40) || (key == 46) || (key == 8))
                event.stopPropagation();
        }
        onKeyUp(event) {
            let key = event.which;
            if ((key == 37) || (key == 39) || (key == 38) || (key == 40) || (key == 46) || (key == 8))
                event.stopPropagation();
            if (this.drawing.value !== this._value) {
                this._value = this.drawing.value;
                this.changed.fire({ target: this, value: this._value });
                this.invalidateMeasure();
            }
        }
        renderDrawing() {
            let drawing = document.createElement('textarea');
            drawing.setAttribute('rows', '1');
            drawing.setAttribute('cols', '1');
            drawing.style.opacity = '1';
            drawing.style.display = 'block';
            drawing.style.resize = 'none';
            drawing.style.overflow = 'hidden';
            drawing.style.border = '0px';
            drawing.style.margin = '0px';
            drawing.style.padding = '0px';
            drawing.style.outline = 'none';
            drawing.style.background = 'none';
            if (Core.Navigator.isWebkit)
                drawing.style.webkitAppearance = 'none';
            drawing.style.fontSize = this.fontSize + 'px';
            drawing.style.fontFamily = this.fontFamily;
            drawing.style.fontWeight = this.fontWeight;
            drawing.style.color = this.getColor().getCssRgba();
            return drawing;
        }
        measureCore(width, height) {
            this.drawing.style.width = width + 'px';
            this.drawing.style.height = '';
            let size = { width: this.drawing.scrollWidth, height: Math.max(this.fontSize, this.drawing.scrollHeight) };
            this.drawing.style.width = this.layoutWidth + 'px';
            this.drawing.style.height = this.layoutHeight + 'px';
            return size;
        }
        arrangeCore(width, height) {
            this.drawing.style.width = width + 'px';
            this.drawing.style.height = height + 'px';
        }
        onDisable() {
            super.onDisable();
            this.drawing.blur();
            this.drawing.style.cursor = 'default';
            this.drawing.disabled = true;
        }
        onEnable() {
            super.onEnable();
            this.drawing.style.cursor = 'auto';
            this.drawing.disabled = false;
        }
        onStyleChange() {
            this.drawing.style.fontSize = this.fontSize + 'px';
            this.drawing.style.fontFamily = this.fontFamily;
            this.drawing.style.fontWeight = this.fontWeight;
            this.drawing.style.color = this.getColor().getCssRgba();
            this.invalidateMeasure();
        }
    }
    TextArea.style = {
        color: new Ui.Color(),
        fontSize: 14,
        fontFamily: 'Sans-serif',
        fontWeight: 'normal'
    };
    Ui.TextArea = TextArea;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class TextAreaField extends Ui.LBox {
        constructor(init) {
            super(init);
            this.changed = new Core.Events();
            this.graphic = new Ui.TextBgGraphic();
            this.append(this.graphic);
            this.textholder = new Ui.Label({
                opacity: 0.5,
                horizontalAlign: 'left',
                verticalAlign: 'top',
                margin: 8,
                marginLeft: 10,
                marginRight: 10
            });
            this.append(this.textholder);
            this.textarea = new Ui.TextArea({
                margin: 7,
                marginLeft: 10,
                marginRight: 10,
                fontSize: 16
            });
            this.append(this.textarea);
            this.textarea.focused.connect(() => this.onTextAreaFocus());
            this.textarea.blurred.connect(() => this.onTextAreaBlur());
            this.textarea.changed.connect((e) => this.onTextAreaChange(e.target, e.value));
            if (init) {
                if (init.textHolder !== undefined)
                    this.textHolder = init.textHolder;
                if (init.value !== undefined)
                    this.value = init.value;
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        set textHolder(text) {
            this.textholder.text = text;
        }
        get value() {
            return this.textarea.value;
        }
        set value(value) {
            this.textarea.value = value;
            if ((value === undefined) || (value === ''))
                this.textholder.show();
            else
                this.textholder.hide();
        }
        onTextAreaFocus() {
            this.textholder.hide();
            this.graphic.hasFocus = true;
        }
        onTextAreaBlur() {
            if (this.value === '')
                this.textholder.show();
            this.graphic.hasFocus = false;
        }
        onTextAreaChange(entry, value) {
            this.changed.fire({ target: this, value: value });
        }
    }
    Ui.TextAreaField = TextAreaField;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Grid extends Ui.Container {
        constructor(init) {
            super(init);
            this._cols = [{ auto: true, star: false, absolute: false, actualWidth: 0, offset: 0, width: 0 }];
            this._rows = [{ auto: true, star: false, absolute: false, actualHeight: 0, offset: 0, height: 0 }];
            if (init) {
                if (init.cols !== undefined)
                    this.cols = init.cols;
                if (init.rows !== undefined)
                    this.rows = init.rows;
            }
        }
        set cols(colsDef) {
            this._cols = [];
            let cols = colsDef.split(',');
            for (let i = 0; i < cols.length; i++) {
                let col = cols[i];
                if (col == 'auto')
                    this._cols.push({ auto: true, star: false, absolute: false, actualWidth: 0, offset: 0, width: 0 });
                else if (col == '*')
                    this._cols.push({ auto: false, star: true, absolute: false, actualWidth: 0, offset: 0, width: 1 });
                else if (col.match(/^[0-9]+\.?[0-9]*\*$/))
                    this._cols.push({ auto: false, star: true, absolute: false, actualWidth: 0, offset: 0, width: parseInt(col.slice(0, col.length - 1)) });
                else if (col.match(/^[0-9]+$/))
                    this._cols.push({ auto: false, star: false, absolute: true, actualWidth: 0, offset: 0, width: parseInt(col) });
                else if (DEBUG)
                    throw ('Ui.Grid column definition "' + col + '" not supported');
            }
        }
        set rows(rowsDef) {
            this._rows = [];
            let rows = rowsDef.split(',');
            for (let i = 0; i < rows.length; i++) {
                let row = rows[i];
                if (row == 'auto')
                    this._rows.push({ auto: true, star: false, absolute: false, actualHeight: 0, offset: 0, height: 0 });
                else if (row == '*')
                    this._rows.push({ auto: false, star: true, absolute: false, actualHeight: 0, offset: 0, height: 1 });
                else if (row.match(/^[0-9]+\.?[0-9]*\*$/))
                    this._rows.push({ auto: false, star: true, absolute: false, actualHeight: 0, offset: 0, height: parseInt(row.slice(0, row.length - 1)) });
                else if (row.match(/^[0-9]+$/))
                    this._rows.push({ auto: false, star: false, absolute: true, actualHeight: 0, offset: 0, height: parseInt(row) });
                else if (DEBUG)
                    throw ('Ui.Grid row definition "' + row + '" not supported');
            }
        }
        attach(child, col, row, colSpan = 1, rowSpan = 1) {
            Grid.setCol(child, col);
            Grid.setRow(child, row);
            Grid.setColSpan(child, colSpan);
            Grid.setRowSpan(child, rowSpan);
            this.appendChild(child);
        }
        detach(child) {
            this.removeChild(child);
        }
        set content(value) {
            while (this.firstChild)
                this.removeChild(this.firstChild);
            for (let item of value) {
                this.attach(item.child, item.col, item.row, item.colSpan, item.rowSpan);
            }
        }
        getColMin(colPos) {
            let i;
            let i2;
            let currentColumn;
            let min = 0;
            for (i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                let childCol = Ui.Grid.getCol(child);
                let childColSpan = Ui.Grid.getColSpan(child);
                if ((childColSpan == 1) && (childCol == colPos)) {
                    if (child.measureWidth > min)
                        min = child.measureWidth;
                }
                else if ((childCol <= colPos) && (childCol + childColSpan > colPos)) {
                    let isLastAuto = true;
                    let hasStar = false;
                    let prev = 0.0;
                    for (i2 = childCol; i2 < colPos; i2++) {
                        currentColumn = this._cols[i2];
                        prev += currentColumn.actualWidth;
                        if (currentColumn.star) {
                            hasStar = true;
                            break;
                        }
                    }
                    if (!hasStar) {
                        for (i2 = colPos + 1; i2 < childCol + childColSpan; i2++) {
                            currentColumn = this._cols[i2];
                            if (currentColumn.star) {
                                hasStar = true;
                                break;
                            }
                            if (currentColumn.auto) {
                                isLastAuto = false;
                                break;
                            }
                        }
                    }
                    if (!hasStar && isLastAuto) {
                        if ((child.measureWidth - prev) > min)
                            min = child.measureWidth - prev;
                    }
                }
            }
            return min;
        }
        getRowMin(rowPos) {
            let i;
            let i2;
            let currentRow;
            let min = 0;
            for (i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                let childRow = Ui.Grid.getRow(child);
                let childRowSpan = Ui.Grid.getRowSpan(child);
                if ((childRowSpan == 1) && (childRow == rowPos)) {
                    if (child.measureHeight > min)
                        min = child.measureHeight;
                }
                else if ((childRow <= rowPos) && (childRow + childRowSpan > rowPos)) {
                    let isLastAuto = true;
                    let hasStar = false;
                    let prev = 0.0;
                    for (i2 = childRow; i2 < rowPos; i2++) {
                        currentRow = this._rows[i2];
                        prev += currentRow.actualHeight;
                        if (currentRow.star) {
                            hasStar = true;
                            break;
                        }
                    }
                    if (!hasStar) {
                        for (i2 = rowPos + 1; i2 < childRow + childRowSpan; i2++) {
                            currentRow = this._rows[i2];
                            if (currentRow.star) {
                                hasStar = true;
                                break;
                            }
                            if (currentRow.auto) {
                                isLastAuto = false;
                                break;
                            }
                        }
                    }
                    if (!hasStar && isLastAuto) {
                        if ((child.measureHeight - prev) > min)
                            min = child.measureHeight - prev;
                    }
                }
            }
            return min;
        }
        measureCore(width, height) {
            for (let i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                let constraintWidth = (width * Ui.Grid.getColSpan(child)) / this._cols.length;
                let constraintHeight = (height * Ui.Grid.getRowSpan(child)) / this._rows.length;
                child.measure(constraintWidth, constraintHeight);
            }
            let colStarCount = 0.0;
            let rowStarCount = 0.0;
            let offsetX = 0;
            for (let colPos = 0; colPos < this._cols.length; colPos++) {
                let col = this._cols[colPos];
                col.offset = offsetX;
                if (col.absolute)
                    col.actualWidth += col.width;
                else if (col.star) {
                    col.actualWidth = 0;
                    colStarCount += col.width;
                }
                else if (col.auto) {
                    col.actualWidth = this.getColMin(colPos);
                }
                offsetX += col.actualWidth;
            }
            let starWidth = 0.0;
            if (colStarCount > 0.0)
                starWidth = (width - offsetX) / colStarCount;
            offsetX = 0;
            for (let i = 0; i < this._cols.length; i++) {
                let col = this._cols[i];
                col.offset = offsetX;
                if (col.star)
                    col.actualWidth = starWidth * col.width;
                offsetX += col.actualWidth;
            }
            for (let i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                let col = Ui.Grid.getCol(child);
                let colSpan = Ui.Grid.getColSpan(child);
                let childWidth = 0.0;
                for (let x = col; x < col + colSpan; x++)
                    childWidth += this._cols[x].actualWidth;
                child.measure(childWidth, height);
            }
            offsetX = 0;
            for (let colPos = 0; colPos < this._cols.length; colPos++) {
                let col = this._cols[colPos];
                col.offset = offsetX;
                if (col.absolute)
                    col.actualWidth = col.width;
                else if (col.star)
                    col.actualWidth = Math.max(this.getColMin(colPos), starWidth * col.width);
                else if (col.auto)
                    col.actualWidth = this.getColMin(colPos);
                offsetX += col.actualWidth;
            }
            for (let i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                let col = Ui.Grid.getCol(child);
                let colSpan = Ui.Grid.getColSpan(child);
                let childWidth = 0.0;
                for (let x = col; x < col + colSpan; x++)
                    childWidth += this._cols[x].actualWidth;
                child.measure(childWidth, height);
            }
            let offsetY = 0;
            for (let rowPos = 0; rowPos < this._rows.length; rowPos++) {
                let row = this._rows[rowPos];
                row.offset = offsetY;
                if (row.absolute)
                    row.actualHeight = row.height;
                else if (row.star) {
                    row.actualHeight = 0;
                    rowStarCount += row.height;
                }
                else if (row.auto)
                    row.actualHeight = this.getRowMin(rowPos);
                offsetY += row.actualHeight;
            }
            let starHeight = 0.0;
            if (rowStarCount > 0.0)
                starHeight = (height - offsetY) / rowStarCount;
            offsetY = 0;
            for (let i = 0; i < this._rows.length; i++) {
                let row = this._rows[i];
                row.offset = offsetY;
                if (row.star)
                    row.actualHeight = starHeight * row.height;
                offsetY += row.actualHeight;
            }
            for (let i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                let col = Ui.Grid.getCol(child);
                let colSpan = Ui.Grid.getColSpan(child);
                let childWidth = 0.0;
                for (let x = col; x < col + colSpan; x++)
                    childWidth += this._cols[x].actualWidth;
                let row = Ui.Grid.getRow(child);
                let rowSpan = Ui.Grid.getRowSpan(child);
                let childHeight = 0.0;
                for (let y = row; y < row + rowSpan; y++)
                    childHeight += this._rows[y].actualHeight;
                child.measure(childWidth, childHeight);
            }
            offsetY = 0;
            for (let rowPos = 0; rowPos < this._rows.length; rowPos++) {
                let row = this._rows[rowPos];
                row.offset = offsetY;
                if (row.absolute)
                    row.actualHeight = row.height;
                else if (row.star) {
                    let rowMin = this.getRowMin(rowPos);
                    row.actualHeight = Math.max(rowMin, starHeight * row.height);
                }
                else if (row.auto)
                    row.actualHeight = this.getRowMin(rowPos);
                offsetY += row.actualHeight;
            }
            return { width: offsetX, height: offsetY };
        }
        arrangeCore(width, height) {
            for (let i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                let col = Ui.Grid.getCol(child);
                let colSpan = Ui.Grid.getColSpan(child);
                let row = Ui.Grid.getRow(child);
                let rowSpan = Ui.Grid.getRowSpan(child);
                let childX = Math.floor(this._cols[col].offset);
                let childWidth = ((col + colSpan >= this._cols.length) ? width : Math.floor(this._cols[col + colSpan].offset)) - childX;
                let childY = Math.floor(this._rows[row].offset);
                let childHeight = ((row + rowSpan >= this._rows.length) ? height : Math.floor(this._rows[row + rowSpan].offset)) - childY;
                child.arrange(childX, childY, Math.round(childWidth), Math.round(childHeight));
            }
        }
        static getCol(child) {
            return (child['Ui.Grid.col'] !== undefined) ? child['Ui.Grid.col'] : 0;
        }
        static setCol(child, col) {
            if (Ui.Grid.getCol(child) != col) {
                child['Ui.Grid.col'] = col;
                child.invalidateMeasure();
            }
        }
        static getRow(child) {
            return (child['Ui.Grid.row'] !== undefined) ? child['Ui.Grid.row'] : 0;
        }
        static setRow(child, row) {
            if (Ui.Grid.getRow(child) !== row) {
                child['Ui.Grid.row'] = row;
                child.invalidateMeasure();
            }
        }
        static getColSpan(child) {
            return (child['Ui.Grid.colSpan'] !== undefined) ? child['Ui.Grid.colSpan'] : 1;
        }
        static setColSpan(child, colSpan) {
            if (Ui.Grid.getColSpan(child) !== colSpan) {
                child['Ui.Grid.colSpan'] = colSpan;
                child.invalidateMeasure();
            }
        }
        static getRowSpan(child) {
            return (child['Ui.Grid.rowSpan'] !== undefined) ? child['Ui.Grid.rowSpan'] : 1;
        }
        static setRowSpan(child, rowSpan) {
            if (Ui.Grid.getRowSpan(child) !== rowSpan) {
                child['Ui.Grid.rowSpan'] = rowSpan;
                child.invalidateMeasure();
            }
        }
    }
    Ui.Grid = Grid;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Flow extends Ui.Container {
        constructor(init) {
            super(init);
            this.lines = new Array();
            this._uniform = false;
            this.uniformWidth = 0;
            this.uniformHeight = 0;
            this._itemAlign = 'left';
            this._spacing = 0;
            if (init) {
                if (init.spacing !== undefined)
                    this.spacing = init.spacing;
                if (init.itemAlign !== undefined)
                    this.itemAlign = init.itemAlign;
                if (init.uniform !== undefined)
                    this.uniform = init.uniform;
                if (init.content !== undefined)
                    this.content = init.content;
            }
        }
        set content(content) {
            while (this.firstChild !== undefined)
                this.removeChild(this.firstChild);
            if (content != undefined) {
                for (let i = 0; i < content.length; i++)
                    this.appendChild(content[i]);
            }
        }
        get spacing() {
            return this._spacing;
        }
        set spacing(spacing) {
            if (this._spacing != spacing) {
                this._spacing = spacing;
                this.invalidateMeasure();
                this.invalidateArrange();
            }
        }
        get itemAlign() {
            return this._itemAlign;
        }
        set itemAlign(itemAlign) {
            if (itemAlign != this._itemAlign) {
                this._itemAlign = itemAlign;
                this.invalidateMeasure();
                this.invalidateArrange();
            }
        }
        get uniform() {
            return this._uniform;
        }
        set uniform(uniform) {
            if (this._uniform != uniform) {
                this._uniform = uniform;
                this.invalidateMeasure();
            }
        }
        append(child) {
            this.appendChild(child);
        }
        prepend(child) {
            this.prependChild(child);
        }
        insertAt(child, position) {
            this.insertChildAt(child, position);
        }
        insertBefore(child, beforeChild) {
            this.insertChildBefore(child, beforeChild);
        }
        moveAt(child, position) {
            this.moveChildAt(child, position);
        }
        remove(child) {
            this.removeChild(child);
        }
        measureChildrenNonUniform(width, height) {
            this.lines = [];
            let line = { pos: 0, y: 0, width: 0, height: 0 };
            let ctx = { lineX: 0, lineY: 0, lineCount: 0, lineHeight: 0, minWidth: 0 };
            for (let i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                let size = child.measure(width, height);
                let isFirst = (ctx.lineX === 0);
                if (!isFirst && (ctx.lineX + size.width + (!isFirst ? this._spacing : 0) > width)) {
                    line.width = ctx.lineX;
                    line.height = ctx.lineHeight;
                    ctx.lineX = 0;
                    ctx.lineY += ctx.lineHeight + this._spacing;
                    ctx.lineHeight = 0;
                    isFirst = true;
                    ctx.lineCount++;
                    this.lines.push(line);
                    line = { pos: ctx.lineCount, y: ctx.lineY, width: 0, height: 0 };
                }
                child['Ui.Flow.flowLine'] = line;
                if (!isFirst && !child.isCollapsed)
                    ctx.lineX += this._spacing;
                child['Ui.Flow.flowLineX'] = ctx.lineX;
                ctx.lineX += size.width;
                if (size.height > ctx.lineHeight)
                    ctx.lineHeight = size.height;
                if (ctx.lineX > ctx.minWidth)
                    ctx.minWidth = ctx.lineX;
            }
            ctx.lineY += ctx.lineHeight;
            line.width = ctx.lineX;
            line.height = ctx.lineHeight;
            this.lines.push(line);
            return { width: ctx.minWidth, height: ctx.lineY };
        }
        measureChildrenUniform(width, height) {
            let i;
            let child;
            let size;
            let maxWidth = 0;
            let maxHeight = 0;
            for (i = 0; i < this.children.length; i++) {
                child = this.children[i];
                size = child.measure(width, height);
                if (size.width > maxWidth)
                    maxWidth = size.width;
                if (size.height > maxHeight)
                    maxHeight = size.height;
            }
            let countPerLine = Math.max(Math.floor((width + this._spacing) / (maxWidth + this._spacing)), 1);
            let nbLine = Math.ceil(this.children.length / countPerLine);
            for (i = 0; i < this.children.length; i++)
                this.children[i].measure(maxWidth, maxHeight);
            this.uniformWidth = maxWidth;
            this.uniformHeight = maxHeight;
            return {
                width: maxWidth * countPerLine + (countPerLine - 1) * this._spacing,
                height: nbLine * maxHeight + (nbLine - 1) * this._spacing
            };
        }
        measureCore(width, height) {
            if (this.children.length === 0)
                return { width: 0, height: 0 };
            if (this._uniform)
                return this.measureChildrenUniform(width, height);
            else
                return this.measureChildrenNonUniform(width, height);
        }
        arrangeCore(width, height) {
            if (this._uniform) {
                if (this._itemAlign === 'left') {
                    let x = 0;
                    let y = 0;
                    for (let i = 0; i < this.children.length; i++) {
                        let child = this.children[i];
                        if (x + this.uniformWidth > width) {
                            x = 0;
                            y += this.uniformHeight + this._spacing;
                        }
                        child.arrange(x, y, this.uniformWidth, this.uniformHeight);
                        x += this.uniformWidth + this._spacing;
                    }
                }
                else if (this._itemAlign === 'right') {
                    let nbItemPerLine = Math.max(Math.floor((width + this._spacing) / (this.uniformWidth + this._spacing)), 1);
                    let lineWidth = nbItemPerLine * this.uniformWidth + (nbItemPerLine - 1) * this._spacing;
                    let x = 0;
                    if (this.children.length < nbItemPerLine)
                        x = width - ((this.children.length * (this.uniformWidth + this._spacing)) - this._spacing);
                    else
                        x = width - lineWidth;
                    let y = 0;
                    for (let i = 0; i < this.children.length; i++) {
                        let child = this.children[i];
                        if (x + this.uniformWidth > width) {
                            if (this.children.length - i < nbItemPerLine)
                                x = width - (((this.children.length - i) * (this.uniformWidth + this._spacing)) - this._spacing);
                            else
                                x = width - lineWidth;
                            y += this.uniformHeight + this._spacing;
                        }
                        child.arrange(x, y, this.uniformWidth, this.uniformHeight);
                        x += this.uniformWidth + this._spacing;
                    }
                }
            }
            else {
                for (let i = 0; i < this.children.length; i++) {
                    let child = this.children[i];
                    if (this._itemAlign == 'left')
                        child.arrange(child['Ui.Flow.flowLineX'], child['Ui.Flow.flowLine'].y, child.measureWidth, child['Ui.Flow.flowLine'].height);
                    else
                        child.arrange(child['Ui.Flow.flowLineX'] + (width - child['Ui.Flow.flowLine'].width), child['Ui.Flow.flowLine'].y, child.measureWidth, child['Ui.Flow.flowLine'].height);
                }
            }
        }
    }
    Ui.Flow = Flow;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class LimitedFlow extends Ui.Flow {
        constructor() {
            super();
            this._canExpand = false;
            this.canexpandchanged = new Core.Events();
            this.linechanged = new Core.Events();
            this.clipToBounds = true;
        }
        set oncanexpandchanged(value) { this.canexpandchanged.connect(value); }
        set onlinechanged(value) { this.linechanged.connect(value); }
        get maxLines() {
            return this._maxLines;
        }
        set maxLines(value) {
            this._maxLines = value;
            this.invalidateMeasure();
        }
        get linesCount() {
            if (!this.uniform)
                return this.lines.length;
            let countPerLine = Math.max(Math.floor((this.layoutWidth + this.spacing) / (this.uniformWidth + this.spacing)), 1);
            return Math.ceil(this.children.length / countPerLine);
        }
        get canExpand() {
            return this._canExpand;
        }
        measureCore(width, height) {
            let res = super.measureCore(width, height);
            if (this._maxLines == undefined)
                return res;
            if (!this.uniform) {
                let pos = Math.min(this._maxLines, this.lines.length) - 1;
                if (pos < 0)
                    return { width: 0, height: 0 };
                else
                    return { width: res.width, height: this.lines[pos].y + this.lines[pos].height };
            }
            else {
                let countPerLine = Math.max(Math.floor((width + this.spacing) / (this.uniformWidth + this.spacing)), 1);
                let nbLine = Math.ceil(this.children.length / countPerLine);
                nbLine = Math.min(nbLine, this._maxLines);
                return {
                    width: res.width,
                    height: nbLine * this.uniformHeight + (nbLine - 1) * this.spacing
                };
            }
        }
        arrangeCore(width, height) {
            super.arrangeCore(width, height);
            let linesCount = this.linesCount;
            let canExpand = this._maxLines != undefined && linesCount > this._maxLines;
            if (canExpand != this._canExpand) {
                this._canExpand = canExpand;
                this.canexpandchanged.fire({ target: this, value: this._canExpand });
            }
            if (this._linesCount != linesCount) {
                this._linesCount = linesCount;
                this.linechanged.fire({ target: this, value: linesCount });
            }
        }
    }
    Ui.LimitedFlow = LimitedFlow;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class ProgressBar extends Ui.Container {
        constructor(init) {
            super(init);
            this._value = 0;
            this._orientation = 'horizontal';
            this.background = new Ui.Rectangle({ width: 4, height: 4 });
            this.appendChild(this.background);
            this.bar = new Ui.Rectangle({ width: 4, height: 4 });
            this.appendChild(this.bar);
            this.clock = new Anim.Clock({
                repeat: 'forever', duration: 2,
                ontimeupdate: e => {
                    let p = e.progress;
                    let p2 = (p > 0.5) ? 2 - 2 * p : 2 * p;
                    if (this.orientation == 'horizontal') {
                        let x = p2 * (this.layoutWidth - this.bar.layoutWidth);
                        this.bar.transform = new Ui.Matrix().translate(x, 0);
                    }
                    else {
                        let y = (1 - p2) * (this.layoutHeight - this.bar.layoutHeight);
                        this.bar.transform = new Ui.Matrix().translate(0, y);
                    }
                }
            });
            if (init) {
                if (init.orientation !== undefined)
                    this.orientation = init.orientation;
                if (init.value !== undefined)
                    this.value = init.value;
            }
        }
        get value() {
            return this._value;
        }
        set value(value) {
            if (value != this._value) {
                this._value = value;
                if (value == 'infinite' && this.isVisible)
                    this.clock.begin();
                else {
                    this.clock.stop();
                    this.bar.transform = new Ui.Matrix().translate(0, 0);
                }
                if (typeof this._value == 'number')
                    this._value = Math.max(0, Math.min(1, this._value));
                this.invalidateArrange();
            }
        }
        get orientation() {
            return this._orientation;
        }
        set orientation(value) {
            if (this._orientation != value) {
                this._orientation = value;
                this.invalidateMeasure();
            }
        }
        measureCore(width, height) {
            let minHeight = 0;
            let minWidth = 0;
            let size = this.bar.measure(width, height);
            minHeight = Math.max(size.height, minHeight);
            minWidth = Math.max(size.width, minWidth);
            size = this.background.measure(width, height);
            minHeight = Math.max(size.height, minHeight);
            minWidth = Math.max(size.width, minWidth);
            if (this.orientation == 'horizontal')
                return { width: Math.max(minWidth, 8), height: minHeight };
            else
                return { width: minWidth, height: Math.max(minHeight, 8) };
        }
        arrangeCore(width, height) {
            this.background.arrange(0, 0, width, height);
            let barWidth = (this.orientation == 'horizontal' ? width : height) * (typeof this.value == 'number' ? this.value : 0.2);
            barWidth = Math.floor(barWidth);
            if (barWidth < 2)
                this.bar.hide();
            else {
                this.bar.show();
                if (this.orientation == 'horizontal')
                    this.bar.arrange(0, 0, barWidth, height);
                else
                    this.bar.arrange(0, height - barWidth, width, barWidth);
            }
        }
        onVisible() {
            super.onVisible();
            if (this.value == 'infinite')
                this.clock.begin();
        }
        onHidden() {
            super.onHidden();
            if (this.value == 'infinite')
                this.clock.stop();
        }
        onStyleChange() {
            let radius = this.getStyleProperty('radius');
            this.bar.radius = radius;
            this.bar.fill = this.getStyleProperty('foreground');
            this.background.radius = radius;
            this.background.fill = this.getStyleProperty('background');
        }
    }
    ProgressBar.style = {
        background: 'rgba(0,0,0,0.2)',
        foreground: '#07a0e5',
        color: '#999999',
        radius: 0
    };
    Ui.ProgressBar = ProgressBar;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Paned extends Ui.Container {
        constructor(init) {
            super(init);
            this.vertical = true;
            this.minContent1Size = 0;
            this.minContent2Size = 0;
            this._pos = 0.5;
            this.changed = new Core.Events();
            this.onCursorMove = () => {
                this.cursor.moved.disconnect(this.onCursorMove);
                var p;
                var aSize;
                if (this.vertical) {
                    p = this.cursor.positionY;
                    aSize = this.layoutHeight - this.cursor.layoutHeight;
                }
                else {
                    p = this.cursor.positionX;
                    aSize = this.layoutWidth - this.cursor.layoutWidth;
                }
                this._pos = p / aSize;
                if (aSize * this._pos < this.minContent1Size)
                    this._pos = this.minContent1Size / aSize;
                if (aSize * (1 - this._pos) < this.minContent2Size)
                    this._pos = 1 - (this.minContent2Size / aSize);
                p = this._pos * aSize;
                if (p < 0)
                    p = 0;
                if (p > aSize)
                    p = aSize;
                if (this.vertical)
                    this.cursor.setPosition(0, p);
                else
                    this.cursor.setPosition(p, 0);
                this.invalidateMeasure();
                this.cursor.moved.connect(this.onCursorMove);
                this.changed.fire({ target: this, position: this._pos });
            };
            this.content1Box = new Ui.LBox();
            this.appendChild(this.content1Box);
            this.content2Box = new Ui.LBox();
            this.appendChild(this.content2Box);
            this.cursor = new Ui.Movable({
                content: new Ui.VPanedCursor(),
                onmoved: () => this.onCursorMove()
            });
            this.appendChild(this.cursor);
            if (init) {
                if (init.orientation !== undefined)
                    this.orientation = init.orientation;
                if (init.pos !== undefined)
                    this.pos = init.pos;
                if (init.content1 !== undefined)
                    this.content1 = init.content1;
                if (init.content2 !== undefined)
                    this.content2 = init.content2;
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        get orientation() {
            if (this.vertical)
                return 'vertical';
            else
                return 'horizontal';
        }
        set orientation(orientation) {
            var vertical = true;
            if (orientation != 'vertical')
                vertical = false;
            if (this.vertical != vertical) {
                this.vertical = vertical;
                if (this.vertical)
                    this.cursor.content = new Ui.VPanedCursor();
                else
                    this.cursor.content = new Ui.HPanedCursor();
                this.invalidateMeasure();
            }
        }
        get pos() {
            return this._pos;
        }
        set pos(pos) {
            this._pos = pos;
            this.invalidateMeasure();
        }
        get content1() {
            return this._content1;
        }
        set content1(content1) {
            if (this._content1 !== content1) {
                if (this._content1 !== undefined)
                    this.content1Box.remove(this._content1);
                this._content1 = content1;
                if (this._content1 !== undefined)
                    this.content1Box.append(this._content1);
            }
        }
        get content2() {
            return this._content2;
        }
        set content2(content2) {
            if (this._content2 !== content2) {
                if (this._content2 !== undefined)
                    this.content2Box.remove(this._content2);
                this._content2 = content2;
                if (this._content2 !== undefined)
                    this.content2Box.append(this._content2);
            }
        }
        invert() {
            var tmp;
            tmp = this.content1Box;
            this.content1Box = this.content2Box;
            this.content2Box = tmp;
            tmp = this._content1;
            this._content1 = this._content2;
            this._content2 = tmp;
            this._pos = 1 - this._pos;
            this.invalidateArrange();
        }
        measureCore(width, height) {
            var cursorSize;
            var content1Size;
            var content2Size;
            if (this.vertical) {
                cursorSize = this.cursor.measure(width, 0);
                if (!this.content1Box.measureValid)
                    this.minContent1Size = this.content1Box.measure(width, 0).height;
                if (!this.content2Box.measureValid)
                    this.minContent2Size = this.content2Box.measure(width, 0).height;
                content1Size = this.content1Box.measure(width, (height - cursorSize.height) * this._pos);
                content2Size = this.content2Box.measure(width, (height - cursorSize.height) * (1 - this._pos));
                return { width: Math.max(cursorSize.width, Math.max(content1Size.width, content2Size.width)), height: content1Size.height + cursorSize.height + content2Size.height };
            }
            else {
                cursorSize = this.cursor.measure(0, height);
                if (!this.content1Box.measureValid)
                    this.minContent1Size = this.content1Box.measure(0, 0).width;
                if (!this.content2Box.measureValid)
                    this.minContent2Size = this.content2Box.measure(0, 0).width;
                content1Size = this.content1Box.measure((width - cursorSize.width) * this._pos, height);
                content2Size = this.content2Box.measure((width - cursorSize.width) * (1 - this._pos), height);
                return { width: content1Size.width + cursorSize.width + content2Size.width, height: Math.max(cursorSize.height, Math.max(content1Size.height, content2Size.height)) };
            }
        }
        arrangeCore(width, height) {
            if (this.vertical) {
                var cHeight = this.cursor.measureHeight;
                var aHeight = height - cHeight;
                this.cursor.arrange(0, 0, width, cHeight);
                this.cursor.setPosition(0, aHeight * this._pos);
                this.content1Box.arrange(0, 0, width, aHeight * this._pos);
                this.content2Box.arrange(0, (aHeight * this._pos) + cHeight, width, aHeight * (1 - this._pos));
            }
            else {
                var cWidth = this.cursor.measureWidth;
                var aWidth = width - cWidth;
                this.content1Box.arrange(0, 0, aWidth * this._pos, height);
                this.cursor.arrange(0, 0, cWidth, height);
                this.cursor.setPosition(aWidth * this._pos, 0);
                this.content2Box.arrange((aWidth * this._pos) + cWidth, 0, aWidth * (1 - this._pos), height);
            }
        }
    }
    Ui.Paned = Paned;
    class VPaned extends Paned {
        constructor(init) {
            super(init);
            this.orientation = 'vertical';
        }
    }
    Ui.VPaned = VPaned;
    class HPaned extends Paned {
        constructor(init) {
            super(init);
            this.orientation = 'horizontal';
        }
    }
    Ui.HPaned = HPaned;
    class HPanedCursor extends Ui.LBox {
        constructor() {
            super();
            this.append(new Ui.Rectangle({ fill: new Ui.Color(0, 0, 0, 0.05) }));
            this.append(new Ui.Rectangle({ fill: 'rgba(140,140,140,1)', width: 1, margin: 5, marginRight: 10, height: 30, verticalAlign: 'center' }));
            this.append(new Ui.Rectangle({ fill: 'rgba(140,140,140,1)', width: 1, margin: 5, marginLeft: 10, height: 30, verticalAlign: 'center' }));
            this.append(new Ui.Frame({ frameWidth: 1, fill: 'rgba(140,140,140,1)' }));
        }
    }
    Ui.HPanedCursor = HPanedCursor;
    class VPanedCursor extends Ui.LBox {
        constructor() {
            super();
            this.append(new Ui.Rectangle({ fill: 'rgba(250,250,250,1)' }));
            this.append(new Ui.Rectangle({ fill: 'rgba(140,140,140,1)', height: 1, margin: 5, marginTop: 10, width: 30, horizontalAlign: 'center' }));
            this.append(new Ui.Rectangle({ fill: 'rgba(140,140,140,1)', height: 1, margin: 5, marginBottom: 10, width: 30, horizontalAlign: 'center' }));
            this.append(new Ui.Frame({ frameWidth: 1, radius: 0, fill: 'rgba(140,140,140,1)' }));
        }
    }
    Ui.VPanedCursor = VPanedCursor;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Slider extends Ui.Container {
        constructor(init) {
            super(init);
            this._value = 0;
            this._orientation = 'horizontal';
            this.updateLock = false;
            this.changed = new Core.Events();
            this.onButtonMove = () => {
                var oldValue = this._value;
                if (this.updateLock !== true) {
                    var pos;
                    var size;
                    var max;
                    if (this.orientation === 'horizontal') {
                        pos = this.button.positionX;
                        size = this.layoutWidth;
                        max = size - this.button.layoutWidth;
                    }
                    else {
                        size = this.layoutHeight;
                        max = size - this.button.layoutHeight;
                        pos = max - this.button.positionY;
                    }
                    if (pos < 0)
                        pos = 0;
                    else if (pos > max)
                        pos = max;
                    this._value = pos / max;
                }
                this.button.moved.disconnect(this.onButtonMove);
                this.updateValue();
                this.button.moved.connect(this.onButtonMove);
                if (oldValue != this._value)
                    this.changed.fire({ target: this, value: this._value });
            };
            this.background = new Ui.Rectangle({ width: 4, height: 4 });
            this.appendChild(this.background);
            this.bar = new Ui.Rectangle({ width: 4, height: 4 });
            this.appendChild(this.bar);
            this.button = new Ui.Movable({ moveVertical: false });
            this.appendChild(this.button);
            this.button.moved.connect(this.onButtonMove);
            this.button.focused.connect(() => this.updateColors());
            this.button.blurred.connect(() => this.updateColors());
            this.button.downed.connect(() => this.updateColors());
            this.button.upped.connect(() => this.updateColors());
            this.buttonContent = new Ui.Rectangle({ radius: 10, width: 20, height: 20, margin: 10 });
            this.button.content = this.buttonContent;
            if (init) {
                if (init.value !== undefined)
                    this.value = init.value;
                if (init.orientation !== undefined)
                    this.orientation = init.orientation;
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        get value() {
            return this._value;
        }
        set value(value) {
            this.setValue(value);
        }
        setValue(value, dontSignal = false) {
            value = Math.min(1, Math.max(0, value));
            if (this._value !== value) {
                this._value = value;
                this.button.moved.disconnect(this.onButtonMove);
                this.updateValue();
                this.button.moved.connect(this.onButtonMove);
                if (dontSignal !== true)
                    this.changed.fire({ target: this, value: this._value });
            }
        }
        get orientation() {
            return this._orientation;
        }
        set orientation(orientation) {
            if (this._orientation !== orientation) {
                this._orientation = orientation;
                this.button.moveHorizontal = true;
                this.button.moveVertical = true;
                this.updateValue();
                if (this._orientation === 'horizontal') {
                    this.button.moveHorizontal = true;
                    this.button.moveVertical = false;
                }
                else {
                    this.button.moveHorizontal = false;
                    this.button.moveVertical = true;
                }
                this.invalidateMeasure();
                this.onStyleChange();
            }
        }
        updateValue() {
            this.updateLock = true;
            let width = this.layoutWidth;
            let height = this.layoutHeight;
            if (this.orientation === 'horizontal') {
                let max = width - this.button.layoutWidth;
                this.button.setPosition(max * this._value, 0);
                this.bar.arrange(this.button.layoutWidth / 2, (height - this.bar.measureHeight) / 2, max * this._value, this.bar.measureHeight);
            }
            else {
                let max = height - this.button.layoutHeight;
                this.button.setPosition(0, max * (1 - this._value));
                this.bar.arrange((width - this.bar.measureWidth) / 2, this.button.layoutHeight / 2 + max * (1 - this._value), this.bar.measureWidth, max * this._value);
            }
            this.updateLock = false;
        }
        getColor() {
            return Ui.Color.create(this.getStyleProperty('background'));
        }
        getForeground() {
            return Ui.Color.create(this.getStyleProperty('foreground'));
        }
        getBackground() {
            var yuv = Ui.Color.create(this.getStyleProperty('background')).getYuv();
            var deltaY = 0;
            if (this.button.isDown)
                deltaY = -0.30;
            return Ui.Color.createFromYuv(yuv.y + deltaY, yuv.u, yuv.v);
        }
        getButtonColor() {
            var yuv = Ui.Color.create(this.getStyleProperty('background')).getYuv();
            var deltaY = 0;
            if (this.button.isDown)
                deltaY = -0.30;
            else if (this.button.hasFocus)
                deltaY = 0.10;
            return Ui.Color.createFromYuv(yuv.y + deltaY, yuv.u, yuv.v);
        }
        updateColors() {
            this.bar.fill = this.getForeground();
            this.background.fill = this.getBackground();
            this.buttonContent.fill = this.getForeground();
        }
        measureCore(width, height) {
            var buttonSize = this.button.measure(0, 0);
            var size = buttonSize;
            var res;
            if (this.orientation === 'horizontal') {
                res = this.background.measure(width - buttonSize.width, 0);
                if (res.width > size.width)
                    size.width = res.width;
                if (res.height > size.height)
                    size.height = res.height;
                res = this.bar.measure(width - buttonSize.width, 0);
                if (res.width > size.width)
                    size.width = res.width;
                if (res.height > size.height)
                    size.height = res.height;
            }
            else {
                res = this.background.measure(0, height - buttonSize.height);
                if (res.width > size.width)
                    size.width = res.width;
                if (res.height > size.height)
                    size.height = res.height;
                res = this.bar.measure(0, height - buttonSize.height);
                if (res.width > size.width)
                    size.width = res.width;
                if (res.height > size.height)
                    size.height = res.height;
            }
            return size;
        }
        arrangeCore(width, height) {
            if (this.orientation === 'horizontal') {
                this.button.arrange(0, (height - this.button.measureHeight) / 2, this.button.measureWidth, this.button.measureHeight);
                this.background.arrange(this.button.layoutWidth / 2, (height - this.background.measureHeight) / 2, width - this.button.layoutWidth, this.background.measureHeight);
            }
            else {
                this.button.arrange((width - this.button.measureWidth) / 2, 0, this.button.measureWidth, this.button.measureHeight);
                this.background.arrange((width - this.background.measureWidth) / 2, this.button.layoutHeight / 2, this.background.measureWidth, height - this.button.layoutHeight);
            }
            this.updateValue();
        }
        onStyleChange() {
            this.background.radius = this.getStyleProperty('radius');
            this.bar.radius = this.getStyleProperty('radius');
            this.updateColors();
        }
        onDisable() {
            super.onDisable();
            this.button.opacity = 0.2;
        }
        onEnable() {
            super.onEnable();
            this.button.opacity = 1;
        }
    }
    Slider.style = {
        radius: 4,
        background: '#e1e1e1',
        backgroundBorder: '#919191',
        foreground: '#07a0e5'
    };
    Ui.Slider = Slider;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Audio extends Ui.Element {
        constructor(init) {
            super();
            this.canplaythrough = false;
            this._state = 'initial';
            this.audioMeasureValid = false;
            this.audioSize = { width: 0, height: 0 };
            this.ready = new Core.Events();
            this.ended = new Core.Events();
            this.timeupdate = new Core.Events();
            this.bufferingupdate = new Core.Events();
            this.statechange = new Core.Events();
            this.error = new Core.Events();
            if (init) {
                if (init.oggSrc || init.mp3Src || init.aacSrc) {
                    if (init.oggSrc && Ui.Audio.supportOgg)
                        this.src = init.oggSrc;
                    else if (init.mp3Src && Ui.Audio.supportMp3)
                        this.src = init.mp3Src;
                    else if (init.aacSrc && Ui.Audio.supportAac)
                        this.src = init.aacSrc;
                }
                else if (init.src)
                    this.src = init.src;
                if (init.volume !== undefined)
                    this.volume = init.volume;
                if (init.currentTime !== undefined)
                    this.currentTime = init.currentTime;
                if (init.controls !== undefined)
                    this.controls = init.controls;
                if (init.controlsList !== undefined)
                    this.controlsList = init.controlsList;
                if (init.onerror !== undefined)
                    this.onerror = init.onerror;
                if (init.onready !== undefined)
                    this.onready = init.onready;
            }
        }
        set onready(value) { this.ready.connect(value); }
        set onended(value) { this.ended.connect(value); }
        set ontimeupdate(value) { this.timeupdate.connect(value); }
        set onbufferingupdate(value) { this.bufferingupdate.connect(value); }
        set onstatechange(value) { this.statechange.connect(value); }
        set onerror(value) { this.error.connect(value); }
        set src(src) {
            this.canplaythrough = false;
            this._state = 'initial';
            this._src = src;
            if (src === undefined)
                this.audioDrawing.removeAttribute('src');
            else
                this.audioDrawing.setAttribute('src', src);
            try {
                this.audioDrawing.load();
            }
            catch (e) { }
        }
        play() {
            this._state = 'playing';
            this.statechange.fire({ target: this, state: this._state });
            if (this.canplaythrough)
                this.audioDrawing.play();
            else
                this.audioDrawing.load();
        }
        pause() {
            this._state = 'paused';
            this.statechange.fire({ target: this, state: this._state });
            if (this.canplaythrough)
                this.audioDrawing.pause();
            else
                this.audioDrawing.load();
        }
        stop() {
            this.audioDrawing.pause();
            this.onEnded();
        }
        set controls(value) {
            if (value)
                this.audioDrawing.controls = true;
            else
                this.audioDrawing.controls = false;
            this.audioMeasureValid = false;
            this.invalidateMeasure();
        }
        get controls() {
            return this.audioDrawing.controls;
        }
        set controlsList(value) {
            if ('controlsList' in this.audioDrawing) {
                let tokenList = this.audioDrawing['controlsList'];
                for (const element of value) {
                    if (!tokenList.supports(element))
                        continue;
                    tokenList.add(element);
                }
                this.audioMeasureValid = false;
                this.invalidateMeasure();
            }
        }
        get controlsList() {
            if (this.audioDrawing['controlsList'] === undefined)
                return [];
            let controlsList = [];
            this.audioDrawing['controlsList'].forEach(token => controlsList.push(token));
            return controlsList;
        }
        set volume(volume) {
            this.audioDrawing.volume = volume;
        }
        get volume() {
            return this.audioDrawing.volume;
        }
        get duration() {
            var duration = this.audioDrawing.duration;
            if ((duration === undefined) || isNaN(duration) || (duration === null))
                return undefined;
            else
                return duration;
        }
        set currentTime(time) {
            this.audioDrawing.currentTime = time;
        }
        get currentTime() {
            if (this.audioDrawing.currentTime === undefined)
                return 0;
            else
                return this.audioDrawing.currentTime;
        }
        get state() {
            return this._state;
        }
        get isReady() {
            return this.canplaythrough;
        }
        onReady() {
            this.canplaythrough = true;
            if (this._state == 'playing')
                this.audioDrawing.play();
            else if (this._state == 'paused')
                this.audioDrawing.pause();
            this.ready.fire({ target: this });
        }
        onTimeUpdate() {
            this.timeupdate.fire({ target: this, time: this.audioDrawing.currentTime });
            this.checkBuffering();
        }
        onEnded() {
            this.audioDrawing.pause();
            this._state = 'initial';
            this.audioDrawing.currentTime = 0;
            this.ended.fire({ target: this });
            this.statechange.fire({ target: this, state: this._state });
        }
        onProgress() {
            this.checkBuffering();
        }
        get currentBufferSize() {
            var buffered = this.audioDrawing.buffered;
            var timebuffer = 0;
            var time = this.audioDrawing.currentTime;
            if (time === undefined)
                time = 0;
            var lastEnd;
            for (var i = 0; i < buffered.length; i++) {
                var start = buffered.start(i);
                var end = buffered.end(i);
                if (lastEnd === undefined) {
                    if ((start <= time) && (end >= time)) {
                        timebuffer = end - time;
                        lastEnd = end;
                    }
                }
                else {
                    if ((lastEnd >= (start - 0.01)) && (lastEnd <= end)) {
                        timebuffer += (end - lastEnd);
                        lastEnd = end;
                    }
                }
            }
            return timebuffer;
        }
        checkBuffering() {
            var timebuffer = this.currentBufferSize;
            var time = this.audioDrawing.currentTime;
            var duration = this.audioDrawing.duration;
            this.bufferingupdate.fire({ target: this, buffer: timebuffer });
        }
        onError() {
            this._state = 'error';
            this.error.fire({ target: this, code: this.audioDrawing.error ? this.audioDrawing.error.code : 0 });
            this.statechange.fire({ target: this, state: this._state });
        }
        onWaiting() {
            if (!this.canplaythrough)
                this.audioDrawing.load();
        }
        onUnload() {
            super.onUnload();
            if (this.canplaythrough)
                this.pause();
        }
        renderDrawing() {
            let drawing;
            if (Ui.Audio.htmlAudio) {
                this.audioDrawing = document.createElement('audio');
                this.audioDrawing.addEventListener('canplaythrough', () => this.onReady());
                this.audioDrawing.addEventListener('ended', () => this.onEnded());
                this.audioDrawing.addEventListener('timeupdate', () => this.onTimeUpdate());
                this.audioDrawing.addEventListener('error', () => this.onError());
                this.audioDrawing.addEventListener('progress', () => this.onProgress());
                this.audioDrawing.addEventListener('waiting', () => this.onWaiting());
                this.audioDrawing.setAttribute('preload', 'auto');
                this.audioDrawing.load();
                this.audioDrawing.style.position = 'absolute';
                this.audioDrawing.style.left = '0px';
                this.audioDrawing.style.top = '0px';
                drawing = this.audioDrawing;
            }
            else {
                drawing = super.renderDrawing();
            }
            return drawing;
        }
        measureCore(width, height) {
            if (!this.audioMeasureValid) {
                this.audioMeasureValid = true;
                let size = Ui.Audio.measure(this.controls);
                this.audioSize = size;
            }
            return this.audioSize;
        }
        static measure(isPlayerVisible) {
            if (!isPlayerVisible)
                return { width: 0, height: 0 };
            return Ui.Audio.measureTextHtml();
        }
        static measureTextHtml() {
            if (Ui.Audio.measureBox === undefined)
                this.createMeasureHtml();
            return { width: Ui.Audio.measureBox.offsetWidth, height: Ui.Audio.measureBox.offsetHeight };
        }
        static createMeasureHtml() {
            let measureWindow = window;
            if (Core.Navigator.isGecko)
                measureWindow = Ui.App.getRootWindow();
            if (measureWindow.document.body === undefined) {
                let body = measureWindow.document.createElement('body');
                measureWindow.document.body = body;
            }
            Ui.Audio.measureBox = measureWindow.document.createElement('audio');
            Ui.Audio.measureBox.controls = true;
            Ui.Audio.measureBox.style.whiteSpace = 'nowrap';
            Ui.Audio.measureBox.style.position = 'absolute';
            Ui.Audio.measureBox.style.left = '0px';
            Ui.Audio.measureBox.style.top = '0px';
            Ui.Audio.measureBox.style.position = 'absolute';
            Ui.Audio.measureBox.style.display = 'inline';
            Ui.Audio.measureBox.style.visibility = 'hidden';
            measureWindow.document.body.appendChild(Ui.Audio.measureBox);
        }
        static initialize() {
            let audioTest = document.createElement('audio');
            if (audioTest.play !== undefined) {
                this.htmlAudio = true;
                this.supportWav = !!audioTest.canPlayType && '' !== audioTest.canPlayType('audio/wav');
                this.supportMp3 = !!audioTest.canPlayType && '' !== audioTest.canPlayType('audio/mpeg');
                this.supportOgg = !!audioTest.canPlayType && '' !== audioTest.canPlayType('audio/ogg; codecs="vorbis"');
                this.supportAac = !!audioTest.canPlayType && '' !== audioTest.canPlayType('audio/mp4; codecs="mp4a.40.2"');
            }
        }
    }
    Audio.htmlAudio = false;
    Audio.supportOgg = false;
    Audio.supportMp3 = false;
    Audio.supportWav = false;
    Audio.supportAac = false;
    Ui.Audio = Audio;
})(Ui || (Ui = {}));
Ui.Audio.initialize();
var Ui;
(function (Ui) {
    class LinkButton extends Ui.Button {
        constructor(init) {
            super(init);
            this.openWindow = true;
            this.target = '_blank';
            this.link = new Core.Events();
            this.pressed.connect(() => this.onLinkButtonPress());
            if (init) {
                if (init.src !== undefined)
                    this.src = init.src;
                if (init.openWindow !== undefined)
                    this.openWindow = init.openWindow;
                if (init.target !== undefined)
                    this.target = init.target;
            }
        }
        set onlink(value) { this.link.connect(value); }
        onLinkButtonPress() {
            this.link.fire({ target: this });
            if (this.src) {
                if (this.openWindow)
                    window.open(this.src, this.target);
                else
                    window.location.replace(this.src);
            }
        }
    }
    LinkButton.style = {
        background: '#a4f4f4'
    };
    Ui.LinkButton = LinkButton;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class SFlowState extends Core.Object {
        constructor(init) {
            super();
            this.x = 0;
            this.y = 0;
            this.width = 0;
            this.height = 0;
            this.xpos = 0;
            this.ypos = 0;
            this.lineHeight = 0;
            this.drawCount = 0;
            this.drawWidth = 0;
            this.drawSpaceWidth = 0;
            this.render = false;
            this.centerstatus = false;
            this.spacing = 0;
            this.align = 'left';
            this.stretchMaxRatio = 1.7;
            this.uniform = false;
            this.firstLine = true;
            this.lastLine = false;
            this.width = init.width;
            this.render = init.render;
            if (init.spacing !== undefined)
                this.spacing = init.spacing;
            if (init.align !== undefined)
                this.align = init.align;
            if (init.uniform !== undefined)
                this.uniform = init.uniform;
            if (init.uniformWidth !== undefined) {
                this.uniformWidth = init.uniformWidth;
                this.stretchUniformWidth = this.uniformWidth;
            }
            if (init.uniformHeight !== undefined)
                this.uniformHeight = init.uniformHeight;
            if (init.stretchMaxRatio !== undefined)
                this.stretchMaxRatio = init.stretchMaxRatio;
            this.zones = [{ xstart: 0, xend: this.width }];
            this.currentZone = 0;
            this.boxes = [];
            this.drawCmd = [];
        }
        getSize() {
            this.lastLine = true;
            this.flush();
            return { width: this.width, height: this.ypos };
        }
        append(el) {
            var zone;
            var isstart;
            var isstartline;
            var isendline;
            var flushVal = SFlow.getFlush(el);
            if (flushVal === 'flush')
                this.flush();
            else if (flushVal === 'flushleft')
                this.flushLeft();
            else if (flushVal === 'flushright')
                this.flushRight();
            else if (flushVal === 'newline')
                this.nextLine();
            var floatVal = SFlow.getFloat(el);
            if (floatVal === 'none') {
                var size;
                if (this.uniform) {
                    size = el.measure(this.uniformWidth, this.uniformHeight);
                    size = { width: this.uniformWidth, height: this.uniformHeight };
                }
                else
                    size = el.measure(this.width, 0);
                while (true) {
                    zone = this.zones[this.currentZone];
                    isstart = false;
                    if (zone.xstart === this.xpos)
                        isstart = true;
                    if ((this.xpos + size.width + ((isstart) ? 0 : this.spacing) <= zone.xend) ||
                        (isstart && (zone.xend === this.width) && (size.width >= this.width))) {
                        this.pushDraw({ width: size.width, height: size.height, spaceWidth: isstart ? 0 : this.spacing, el: el });
                        if (!isstart)
                            this.xpos += this.spacing;
                        this.xpos += size.width;
                        if (size.height > this.lineHeight) {
                            this.lineHeight = size.height;
                        }
                        break;
                    }
                    else {
                        this.nextZone();
                    }
                }
            }
            else if (floatVal === 'left') {
                var size = el.measure(this.width, 0);
                while (true) {
                    zone = this.zones[this.currentZone];
                    isstartline = false;
                    if (this.xpos === 0)
                        isstartline = true;
                    if (isstartline && ((size.width <= zone.xend - this.xpos) || (zone.xend == this.width && size.width >= this.width))) {
                        if (this.render)
                            el.arrange(this.xpos, this.ypos, size.width, size.height);
                        this.insertBox({ x: this.xpos, y: this.ypos, width: size.width, height: size.height });
                        break;
                    }
                    else
                        this.nextZone();
                }
            }
            else if (floatVal === 'right') {
                var size = el.measure(this.width, 0);
                while (true) {
                    zone = this.zones[this.currentZone];
                    isendline = false;
                    if (this.width == zone.xend)
                        isendline = true;
                    if (isendline && ((size.width <= zone.xend - this.xpos) || (this.xpos == 0 && size.width >= this.width))) {
                        if (this.render)
                            el.arrange(zone.xend - size.width, this.ypos, size.width, size.height);
                        this.insertBox({ x: zone.xend - size.width, y: this.ypos, width: size.width, height: size.height });
                        break;
                    }
                    else
                        this.nextZone();
                }
            }
        }
        flushDraw() {
            if (this.render && (this.drawCmd.length > 0)) {
                var zone = this.zones[this.currentZone];
                var xpos = zone.xstart;
                var widthBonus = 0;
                var itemWidth = 0;
                if (this.align === 'right')
                    xpos += (zone.xend - zone.xstart) - (this.drawWidth + this.drawSpaceWidth);
                else if (this.align === 'center')
                    xpos += Math.floor(((zone.xend - zone.xstart) - (this.drawWidth + this.drawSpaceWidth)) / 2);
                else if (this.align === 'stretch')
                    widthBonus = Math.floor(((zone.xend - zone.xstart) - (this.drawWidth + this.drawSpaceWidth)) / this.drawCmd.length);
                for (var i = 0; i < this.drawCmd.length; i++) {
                    var cmd = this.drawCmd[i];
                    if (cmd.width + widthBonus > cmd.width * this.stretchMaxRatio)
                        itemWidth = cmd.width * this.stretchMaxRatio;
                    else
                        itemWidth = cmd.width + widthBonus;
                    if (this.uniform && (this.align === 'stretch')) {
                        if (this.lastLine && !this.firstLine)
                            itemWidth = Math.max(cmd.width, this.stretchUniformWidth);
                        else
                            this.stretchUniformWidth = itemWidth;
                    }
                    cmd.el.arrange(xpos + cmd.spaceWidth, this.ypos, itemWidth, this.lineHeight);
                    xpos += itemWidth + cmd.spaceWidth;
                }
            }
            this.drawCmd = [];
            this.drawWidth = 0;
            this.drawCount = 0;
            this.drawSpaceWidth = 0;
        }
        pushDraw(cmd) {
            this.drawCmd.push(cmd);
            this.drawCount++;
            this.drawWidth += cmd.width;
            this.drawSpaceWidth += cmd.spaceWidth;
        }
        insertBox(box) {
            this.boxes.push(box);
            this.calculZone();
        }
        calculZone() {
            var zone;
            this.zones = [{ xstart: 0, xend: this.width }];
            for (var i2 = 0; i2 < this.boxes.length; i2++) {
                var box = this.boxes[i2];
                if ((this.ypos + this.lineHeight < box.y) || (this.ypos >= box.y + box.height)) {
                    continue;
                }
                let tmpZones = new Array();
                for (let i = 0; i < this.zones.length; i++) {
                    zone = this.zones[i];
                    if ((box.x <= zone.xstart) && (box.x + box.width < zone.xend))
                        tmpZones.push({ xstart: box.x + box.width, xend: zone.xend });
                    else if ((box.x < zone.xend) && (box.x + box.width >= zone.xend))
                        tmpZones.push({ xstart: zone.xstart, xend: box.x });
                    else if ((box.x > zone.xstart) && (box.x + box.width < zone.xend)) {
                        tmpZones.push({ xstart: zone.xstart, xend: box.x });
                        tmpZones.push({ xstart: box.x + box.width, xend: zone.xend });
                    }
                    else if ((box.x <= zone.xstart) && (box.x + box.width >= zone.xend)) {
                    }
                    else {
                        tmpZones.push({ xstart: zone.xstart, xend: zone.xend });
                    }
                }
                this.zones = tmpZones;
            }
            for (this.currentZone = 0; this.currentZone < this.zones.length; this.currentZone++) {
                zone = this.zones[this.currentZone];
                if ((this.xpos >= zone.xstart) && (this.xpos <= zone.xend)) {
                    break;
                }
            }
            if (this.currentZone >= this.zones.length) {
                this.currentZone = -1;
                for (this.currentZone = 0; this.currentZone < this.zones.length; this.currentZone++) {
                    zone = this.zones[this.currentZone];
                    if (zone.xstart >= this.xpos) {
                        this.xpos = zone.xstart;
                        break;
                    }
                }
                if (this.currentZone >= this.zones.length) {
                    this.xpos = 0;
                    this.nextLine();
                }
            }
        }
        flush() {
            if (this.drawCount !== 0)
                this.nextLine();
            while (true) {
                var zone = this.zones[this.currentZone];
                if ((zone.xstart === 0) && (zone.xend === this.width))
                    break;
                else
                    this.nextZone();
            }
        }
        flushLeft() {
            if (this.drawCount !== 0)
                this.nextLine();
            while (true) {
                var zone = this.zones[this.currentZone];
                if (zone.xstart === 0)
                    break;
                else
                    this.nextZone();
            }
        }
        flushRight() {
            if (this.drawCount !== 0)
                this.nextLine();
            while (true) {
                var zone = this.zones[this.currentZone];
                if (zone.xend === this.width)
                    break;
                else
                    this.nextZone();
            }
        }
        nextLine() {
            this.flushDraw();
            do {
                if (this.lineHeight > 0) {
                    this.ypos += this.lineHeight + this.spacing;
                    this.lineHeight = 0;
                    this.calculZone();
                }
                else if (this.boxes.length > 0) {
                    var nexty = Number.MAX_VALUE;
                    for (var i = 0; i < this.boxes.length; i++) {
                        var box = this.boxes[i];
                        if ((this.ypos < box.y + box.height) && (nexty > box.y + box.height))
                            nexty = box.y + box.height;
                    }
                    if (nexty !== Number.MAX_VALUE)
                        this.ypos = nexty + this.spacing;
                    this.calculZone();
                }
            } while (this.zones.length === 0);
            this.currentZone = 0;
            this.xpos = this.zones[0].xstart;
            this.firstLine = false;
        }
        nextZone() {
            this.flushDraw();
            if (this.currentZone >= this.zones.length - 1) {
                this.nextLine();
            }
            else {
                this.currentZone++;
                this.xpos = this.zones[this.currentZone].xstart;
            }
        }
    }
    class SFlow extends Ui.Container {
        constructor(init) {
            super(init);
            this._uniform = false;
            this._itemAlign = 'left';
            this._stretchMaxRatio = 1.3;
            this._spacing = 0;
            if (init) {
                if (init.content !== undefined)
                    this.content = init.content;
                if (init.spacing !== undefined)
                    this.spacing = init.spacing;
                if (init.itemAlign !== undefined)
                    this.itemAlign = init.itemAlign;
                if (init.uniform !== undefined)
                    this.uniform = init.uniform;
                if (init.uniformRatio !== undefined)
                    this.uniformRatio = init.uniformRatio;
                if (init.stretchMaxRatio !== undefined)
                    this.stretchMaxRatio = init.stretchMaxRatio;
            }
        }
        set content(content) {
            while (this.firstChild !== undefined)
                this.removeChild(this.firstChild);
            if ((content != undefined) && (typeof (content) === 'object')) {
                for (var i = 0; i < content.length; i++)
                    this.appendChild(content[i]);
            }
        }
        get spacing() {
            return this._spacing;
        }
        set spacing(spacing) {
            if (this._spacing != spacing) {
                this._spacing = spacing;
                this.invalidateMeasure();
                this.invalidateArrange();
            }
        }
        get itemAlign() {
            return this._itemAlign;
        }
        set itemAlign(itemAlign) {
            if (itemAlign != this._itemAlign) {
                this._itemAlign = itemAlign;
                this.invalidateMeasure();
                this.invalidateArrange();
            }
        }
        get uniform() {
            return this._uniform;
        }
        set uniform(uniform) {
            if (this._uniform != uniform) {
                this._uniform = uniform;
                this.invalidateMeasure();
            }
        }
        get uniformRatio() {
            return this._uniformRatio ? this._uniformRatio : 1;
        }
        set uniformRatio(uniformRatio) {
            if (this._uniformRatio != uniformRatio) {
                this._uniformRatio = uniformRatio;
                this.invalidateMeasure();
            }
        }
        get stretchMaxRatio() {
            return this._stretchMaxRatio;
        }
        set stretchMaxRatio(stretchMaxRatio) {
            if (this._stretchMaxRatio != stretchMaxRatio) {
                this._stretchMaxRatio = stretchMaxRatio;
                this.invalidateMeasure();
            }
        }
        append(child, floatVal, flushVal) {
            this.appendChild(child);
            if (floatVal !== undefined)
                SFlow.setFloat(child, floatVal);
            if (flushVal !== undefined)
                SFlow.setFlush(child, flushVal);
        }
        prepend(child, floatVal, flushVal) {
            this.prependChild(child);
            if (floatVal !== undefined)
                SFlow.setFloat(child, floatVal);
            if (flushVal !== undefined)
                SFlow.setFlush(child, flushVal);
        }
        insertAt(child, position, floatVal, flushVal) {
            this.insertChildAt(child, position);
            if (floatVal !== undefined)
                SFlow.setFloat(child, floatVal);
            if (flushVal !== undefined)
                SFlow.setFlush(child, flushVal);
        }
        insertBefore(child, beforeChild, floatVal, flushVal) {
            this.insertChildBefore(child, beforeChild);
            if (floatVal !== undefined)
                SFlow.setFloat(child, floatVal);
            if (flushVal !== undefined)
                SFlow.setFlush(child, flushVal);
        }
        moveAt(child, position) {
            this.moveChildAt(child, position);
        }
        remove(child) {
            this.removeChild(child);
        }
        measureCore(width, height) {
            if (this.children.length === 0)
                return { width: 0, height: 0 };
            if (this._uniform) {
                this._uniformWidth = 0;
                this._uniformHeight = 0;
                for (var i = 0; i < this.children.length; i++) {
                    var child = this.children[i];
                    var childSize = child.measure(width, height);
                    if (childSize.width > this._uniformWidth)
                        this._uniformWidth = childSize.width;
                    if (childSize.height > this._uniformHeight)
                        this._uniformHeight = childSize.height;
                }
                if (this._uniformRatio !== undefined) {
                    var aratio = this._uniformWidth / this._uniformHeight;
                    var aw, ah;
                    if (this._uniformRatio < aratio) {
                        aw = this._uniformWidth;
                        ah = aw / this._uniformRatio;
                    }
                    else {
                        ah = this._uniformHeight;
                        aw = ah * this._uniformRatio;
                    }
                    this._uniformWidth = aw;
                    this._uniformHeight = ah;
                }
            }
            var state = new SFlowState({
                width: width, render: false, spacing: this._spacing,
                align: this.itemAlign, uniform: this._uniform,
                uniformWidth: this._uniformWidth, uniformHeight: this._uniformHeight,
                stretchMaxRatio: this._stretchMaxRatio
            });
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (!child.isCollapsed)
                    state.append(child);
            }
            return state.getSize();
        }
        arrangeCore(width, height) {
            var state = new SFlowState({
                width: width, render: true, spacing: this._spacing,
                align: this.itemAlign, uniform: this._uniform,
                uniformWidth: this._uniformWidth, uniformHeight: this._uniformHeight,
                stretchMaxRatio: this._stretchMaxRatio
            });
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (!child.isCollapsed)
                    state.append(child);
            }
            state.getSize();
        }
        static getFloat(child) {
            return child['Ui.SFlow.float'] ? child['Ui.SFlow.float'] : 'none';
        }
        static setFloat(child, floatVal) {
            if (SFlow.getFloat(child) !== floatVal) {
                child['Ui.SFlow.float'] = floatVal;
                child.invalidateMeasure();
            }
        }
        static getFlush(child) {
            return child['Ui.SFlow.flush'] ? child['Ui.SFlow.flush'] : 'none';
        }
        static setFlush(child, flushVal) {
            if (SFlow.getFlush(child) !== flushVal) {
                child['Ui.SFlow.flush'] = flushVal;
                child.invalidateMeasure();
            }
        }
    }
    Ui.SFlow = SFlow;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Video extends Ui.Element {
        constructor(init) {
            super(init);
            this.loaddone = false;
            this.canplaythrough = false;
            this._state = 'initial';
            this.statechanged = new Core.Events();
            this.ready = new Core.Events();
            this.ended = new Core.Events();
            this.error = new Core.Events();
            this.timeupdated = new Core.Events();
            this.bufferingupdated = new Core.Events();
            if (init) {
                if (init.src !== undefined)
                    this.src = init.src;
                if (init.oggSrc || init.mp4Src || init.webmSrc) {
                    if (init.mp4Src && Ui.Video.supportMp4)
                        this.src = init.mp4Src;
                    else if (init.webmSrc && Ui.Video.supportWebm)
                        this.src = init.webmSrc;
                    else if (init.oggSrc && Ui.Video.supportOgg)
                        this.src = init.oggSrc;
                }
                if (init.poster !== undefined)
                    this.poster = init.poster;
                if (init.autoplay !== undefined)
                    this.autoplay = init.autoplay;
                if (init.volume !== undefined)
                    this.volume = init.volume;
                if (init.currentTime !== undefined)
                    this.currentTime = init.currentTime;
                if (init.controls !== undefined)
                    this.controls = init.controls;
                if (init.controlsList !== undefined)
                    this.controlsList = init.controlsList;
                if (init.onstatechanged)
                    this.statechanged.connect(init.onstatechanged);
                if (init.onready)
                    this.ready.connect(init.onready);
                if (init.onended)
                    this.ended.connect(init.onended);
                if (init.onerror)
                    this.error.connect(init.onerror);
                if (init.ontimeupdated)
                    this.timeupdated.connect(init.ontimeupdated);
                if (init.onbufferingupdated)
                    this.bufferingupdated.connect(init.onbufferingupdated);
            }
        }
        set onstatechanged(value) { this.statechanged.connect(value); }
        set onready(value) { this.ready.connect(value); }
        set onended(value) { this.ended.connect(value); }
        set onerror(value) { this.error.connect(value); }
        set ontimeupdated(value) { this.timeupdated.connect(value); }
        set onbufferingupdated(value) { this.bufferingupdated.connect(value); }
        set src(src) {
            this.canplaythrough = false;
            this._state = 'initial';
            if (typeof (src) === 'object')
                this.videoDrawing.src = URL.createObjectURL(src);
            else if (src !== undefined)
                this.videoDrawing.setAttribute('src', src);
            else
                this.videoDrawing.removeAttribute('src');
            try {
                this.videoDrawing.load();
            }
            catch (e) { }
        }
        set poster(src) {
            this.videoDrawing.setAttribute('poster', src);
        }
        set autoplay(autoplay) {
            this.videoDrawing.autoplay = autoplay;
        }
        play() {
            this._state = 'playing';
            this.statechanged.fire({ target: this, state: this._state });
            if (this.canplaythrough)
                this.videoDrawing.play();
            else
                this.videoDrawing.load();
        }
        pause() {
            this._state = 'paused';
            this.statechanged.fire({ target: this, state: this._state });
            if (this.canplaythrough)
                this.videoDrawing.pause();
            else
                this.videoDrawing.load();
        }
        stop() {
            this.videoDrawing.pause();
            this.onEnded();
        }
        set controls(value) {
            if (value)
                this.videoDrawing.controls = true;
            else
                this.videoDrawing.controls = false;
        }
        get controls() {
            return this.videoDrawing.controls;
        }
        set controlsList(value) {
            if ('controlsList' in this.videoDrawing) {
                let tokenList = this.videoDrawing['controlsList'];
                for (const element of value) {
                    if (!tokenList.supports(element))
                        continue;
                    tokenList.add(element);
                }
            }
        }
        get controlsList() {
            if (this.videoDrawing['controlsList'] === undefined)
                return [];
            let controlsList = new Array();
            this.videoDrawing['controlsList'].forEach(token => controlsList.push(token));
            return controlsList;
        }
        set volume(volume) {
            this.videoDrawing.volume = volume;
        }
        get volume() {
            return this.videoDrawing.volume;
        }
        get duration() {
            return this.videoDrawing.duration;
        }
        set currentTime(time) {
            this.videoDrawing.currentTime = time;
        }
        get currentTime() {
            if (this.videoDrawing.currentTime === undefined)
                return 0;
            else
                return this.videoDrawing.currentTime;
        }
        get state() {
            return this._state;
        }
        get isReady() {
            return this.canplaythrough;
        }
        get naturalWidth() {
            return this.videoDrawing.videoWidth;
        }
        get naturalHeight() {
            return this.videoDrawing.videoHeight;
        }
        onReady() {
            this.canplaythrough = true;
            this.videoDrawing.videoWidth;
            this.videoDrawing.videoHeight;
            if (this._state == 'playing')
                this.videoDrawing.play();
            else if (this._state == 'paused')
                this.videoDrawing.pause();
            this.ready.fire({ target: this });
        }
        onTimeUpdate() {
            this.timeupdated.fire({ target: this, time: this.videoDrawing.currentTime });
            this.checkBuffering();
        }
        onEnded() {
            this.videoDrawing.pause();
            this._state = 'initial';
            this.videoDrawing.currentTime = 0;
            this.ended.fire({ target: this });
            this.statechanged.fire({ target: this, state: this._state });
        }
        onProgress() {
            this.checkBuffering();
        }
        get currentBufferSize() {
            var buffered = this.videoDrawing.buffered;
            var timebuffer = 0;
            var time = this.videoDrawing.currentTime;
            if (time === undefined)
                time = 0;
            var lastEnd;
            for (var i = 0; i < buffered.length; i++) {
                var start = buffered.start(i);
                var end = buffered.end(i);
                if (lastEnd === undefined) {
                    if ((start <= time) && (end >= time)) {
                        timebuffer = end - time;
                        lastEnd = end;
                    }
                }
                else {
                    if ((lastEnd >= (start - 0.01)) && (lastEnd <= end)) {
                        timebuffer += (end - lastEnd);
                        lastEnd = end;
                    }
                }
            }
            return timebuffer;
        }
        checkBuffering() {
            var timebuffer = this.currentBufferSize;
            var time = this.videoDrawing.currentTime;
            var duration = this.videoDrawing.duration;
            this.bufferingupdated.fire({ target: this, buffer: timebuffer });
        }
        onError() {
            this._state = 'error';
            this.error.fire({ target: this, code: this.videoDrawing.error ? this.videoDrawing.error.code : 0 });
            this.statechanged.fire({ target: this, state: this._state });
        }
        onWaiting() {
            if (!this.canplaythrough)
                this.videoDrawing.load();
        }
        onUnload() {
            super.onUnload();
            if (this.canplaythrough)
                this.pause();
            this.videoDrawing.removeAttribute('src');
            try {
                this.videoDrawing.load();
            }
            catch (e) { }
        }
        renderDrawing() {
            if (Ui.Video.htmlVideo) {
                this.videoDrawing = document.createElement('video');
                this.videoDrawing.addEventListener('canplaythrough', () => this.onReady());
                this.videoDrawing.addEventListener('ended', () => this.onEnded());
                this.videoDrawing.addEventListener('timeupdate', () => this.onTimeUpdate());
                this.videoDrawing.addEventListener('error', () => this.onError());
                this.videoDrawing.addEventListener('progress', () => this.onProgress());
                this.videoDrawing.addEventListener('waiting', () => this.onWaiting());
                this.videoDrawing.setAttribute('preload', 'auto');
                this.videoDrawing.load();
                this.videoDrawing.style.position = 'absolute';
                this.videoDrawing.style.left = '0px';
                this.videoDrawing.style.top = '0px';
            }
            return this.videoDrawing;
        }
        arrangeCore(width, height) {
            if (Ui.Video.htmlVideo) {
                this.videoDrawing.setAttribute('width', width.toString());
                this.videoDrawing.setAttribute('height', height.toString());
            }
        }
        static initialize() {
            let videoTest = document.createElement('video');
            if (videoTest.play !== undefined) {
                this.htmlVideo = true;
                this.supportMp4 = !!videoTest.canPlayType && '' !== videoTest.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
                this.supportOgg = !!videoTest.canPlayType && '' !== videoTest.canPlayType('video/ogg; codecs="theora, vorbis"');
                this.supportWebm = !!videoTest.canPlayType && '' !== videoTest.canPlayType('video/webm; codecs="vp8, vorbis"');
            }
        }
    }
    Video.htmlVideo = false;
    Video.flashVideo = false;
    Video.supportOgg = false;
    Video.supportMp4 = false;
    Video.supportWebm = false;
    Ui.Video = Video;
})(Ui || (Ui = {}));
Ui.Video.initialize();
var Ui;
(function (Ui) {
    class MonthCalendar extends Ui.VBox {
        constructor(init) {
            super(init);
            this._selectMode = 'DAY';
            this._mode = 'DAY';
            this.dayselected = new Core.Events();
            this._date = new Date();
            let hbox = new Ui.HBox();
            this.append(hbox);
            let button = new Ui.FlatButton({
                icon: 'arrowleft',
                verticalAlign: 'center',
                onpressed: () => this.onLeftButtonPress(),
            });
            button.setStyleProperty('iconSize', 16);
            hbox.append(button);
            let datehbox = new Ui.HBox({ spacing: 5, horizontalAlign: 'center' });
            this.monthButton = new MonthYearButton({
                onpressed: () => this.mode = this.mode == 'MONTH' ? 'DAY' : 'MONTH'
            });
            datehbox.append(this.monthButton);
            this.yearButton = new MonthYearButton({
                onpressed: () => this.mode = this.mode == 'YEAR' ? 'DAY' : 'YEAR'
            });
            datehbox.append(this.yearButton);
            hbox.append(datehbox, true);
            button = new Ui.FlatButton({
                icon: 'arrowright',
                verticalAlign: 'center',
                onpressed: () => this.onRightButtonPress()
            });
            button.setStyleProperty('iconSize', 16);
            hbox.append(button);
            this.updateDate();
            if (init) {
                if (init.date !== undefined)
                    this.date = init.date;
                if (init.selectedDate !== undefined)
                    this.selectedDate = init.selectedDate;
                if (init.dayFilter !== undefined)
                    this.dayFilter = init.dayFilter;
                if (init.dateFilter !== undefined)
                    this.dateFilter = init.dateFilter;
                if (init.ondayselected)
                    this.dayselected.connect(init.ondayselected);
            }
        }
        set ondayselected(value) { this.dayselected.connect(value); }
        set dayFilter(dayFilter) {
            this._dayFilter = dayFilter;
            this.updateDate();
        }
        set dateFilter(dateFilter) {
            this._dateFilter = dateFilter;
            this.updateDate();
        }
        set date(date) {
            this._date = new Date(date.getTime());
            this.updateDate();
        }
        get selectedDate() {
            return new Date(this._selectedDate.getTime());
        }
        set selectedDate(selectedDate) {
            this._selectedDate = new Date(selectedDate.getTime());
            this._date = new Date(selectedDate.getTime());
            this.updateDate();
        }
        get selectMode() {
            return this._selectMode;
        }
        set selectMode(value) {
            if (value != this._selectMode) {
                this._selectMode = value;
                this.updateDate(false);
            }
        }
        get mode() {
            return this._mode;
        }
        set mode(value) {
            if (value != this.mode) {
                this._mode = value;
                this.updateDate(false);
            }
        }
        onLeftButtonPress() {
            if (this.mode == 'YEAR')
                this._date.setFullYear(this._date.getFullYear() - 12);
            else {
                this._date.setDate(1);
                this._date.setMonth(this._date.getMonth() - 1);
            }
            this.updateDate();
        }
        onRightButtonPress() {
            if (this.mode == 'YEAR')
                this._date.setFullYear(this._date.getFullYear() + 12);
            else {
                this._date.setDate(1);
                this._date.setMonth(this._date.getMonth() + 1);
            }
            this.updateDate();
        }
        onDaySelect(button) {
            this._selectedDate = button.monthCalendarDate;
            this.updateDate();
            this.dayselected.fire({ target: this, value: this._selectedDate });
        }
        updateDate(reuseGrid = true) {
            let monthNames = ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'];
            this.monthButton.text = monthNames[this._date.getMonth()];
            this.yearButton.text = this._date.getFullYear().toString();
            if (this.mode == 'DAY')
                this.updateDayGrid(reuseGrid);
            else if (this.mode == 'MONTH')
                this.updateMonthGrid(reuseGrid);
            else
                this.updateYearGrid(reuseGrid);
            this.onStyleChange();
        }
        updateDayGrid(reuseGrid) {
            let i = 0;
            let dayPivot = [6, 0, 1, 2, 3, 4, 5];
            let dayNames = ['Lu', 'Ma', 'Me', 'Je', 'Ve', 'Sa', 'Di'];
            let color = this.getStyleProperty('color');
            let dayColor = this.getStyleProperty('dayColor');
            let selectColor = this.getStyleProperty('selectColor');
            if (reuseGrid && this.grid)
                while (this.grid.firstChild !== undefined)
                    this.grid.detach(this.grid.firstChild);
            else {
                this.remove(this.grid);
                this.grid = new Ui.Grid({
                    cols: '*,*,*,*,*,*,*',
                    rows: '*,*,*,*,*,*,*',
                    horizontalAlign: 'stretch'
                });
                this.append(this.grid);
            }
            for (i = 0; i < 7; i++)
                this.grid.attach(new Ui.Label({ text: dayNames[i], fontWeight: 'bold', color: color, margin: 5 }), i, 0);
            let month = this._date.getMonth();
            let current = new Date(this._date.getTime());
            current.setDate(1);
            let day = (current.getDay() + 6) % 7;
            let weekStart = new Date(current.getTime() - day * 24 * 3600 * 1000);
            current = weekStart;
            let selectedWeekStart = undefined;
            if (this._selectedDate) {
                let day = (this._selectedDate.getDay() + 6) % 7;
                selectedWeekStart = new Date(this._selectedDate.getTime() - day * 24 * 3600 * 1000);
            }
            let row = 1;
            let now = new Date();
            do {
                let day = (current.getDay() + 6) % 7;
                let weekStart = new Date(current.getTime() - day * 24 * 3600 * 1000);
                for (let col = 0; col < 7; col++) {
                    let day = new DayButton({
                        onpressed: () => this.onDaySelect(day)
                    });
                    let isSelected = false;
                    if (this._selectMode == 'DAY')
                        isSelected = (this._selectedDate !== undefined) && (current.getFullYear() === this._selectedDate.getFullYear()) && (current.getMonth() === this._selectedDate.getMonth()) && (current.getDate() === this._selectedDate.getDate());
                    else if (this._selectMode == 'WEEK')
                        isSelected = selectedWeekStart != undefined && (weekStart.getFullYear() === selectedWeekStart.getFullYear()) && (weekStart.getMonth() === selectedWeekStart.getMonth()) && (weekStart.getDate() === selectedWeekStart.getDate());
                    let currentMonth = current.getMonth() == month;
                    day.monthCalendarDate = current;
                    day.monthCalendarCurrent = (current.getFullYear() == now.getFullYear()) && (current.getMonth() == now.getMonth()) && (current.getDate() == now.getDate());
                    day.isSelected = isSelected;
                    day.append(new Ui.Rectangle().assign({ fill: day.isSelected ? selectColor : dayColor, opacity: currentMonth ? 1 : 0.5 }));
                    let disable = false;
                    if (this._dayFilter !== undefined) {
                        let weekday = current.getDay();
                        for (i = 0; (i < this._dayFilter.length) && !disable; i++)
                            if (weekday == this._dayFilter[i])
                                disable = true;
                    }
                    if (this._dateFilter !== undefined) {
                        let daystr = current.getFullYear() + '/';
                        if (current.getMonth() + 1 < 10)
                            daystr += '0';
                        daystr += (current.getMonth() + 1) + '/';
                        if (current.getDate() < 10)
                            daystr += '0';
                        daystr += current.getDate();
                        for (i = 0; (i < this._dateFilter.length) && !disable; i++) {
                            let re = new RegExp(this._dateFilter[i]);
                            if (re.test(daystr)) {
                                disable = true;
                            }
                        }
                    }
                    if (disable) {
                        day.disable();
                        day.opacity = 0.2;
                    }
                    day.append(new Ui.Label({ text: current.getDate().toString(), fontWeight: day.monthCalendarCurrent ? 'bold' : 'normal', margin: 5 }));
                    this.grid.attach(day, col, row);
                    current = new Date(current.getTime() + 1000 * 60 * 60 * 24);
                    if (dayPivot[current.getDay()] === 0)
                        row++;
                }
            } while (month == current.getMonth());
        }
        updateMonthGrid(reuseGrid) {
            if (reuseGrid && this.grid)
                while (this.grid.firstChild !== undefined)
                    this.grid.detach(this.grid.firstChild);
            else {
                this.remove(this.grid);
                this.grid = new Ui.Grid({
                    cols: '*,*,*,*',
                    rows: '*,*,*',
                    horizontalAlign: 'stretch'
                });
                this.append(this.grid);
            }
            let monthNames = ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Jun', 'Jui', 'Aoû', 'Sep', 'Oct', 'Nov', 'Déc'];
            let nbCols = 4;
            for (let i = 0; i < monthNames.length; i++) {
                let row = Math.trunc(i / nbCols);
                let col = i % nbCols;
                let current = new Date(this._date.getTime());
                current.setDate(1);
                current.setMonth(i);
                let month = new MonthYearButton().assign({
                    text: monthNames[i],
                    onpressed: () => {
                        this._date = month.monthCalendarDate;
                        this.mode = 'DAY';
                    }
                });
                month.monthCalendarDate = current;
                this.grid.attach(month, col, row);
            }
        }
        updateYearGrid(reuseGrid) {
            if (reuseGrid && this.grid)
                while (this.grid.firstChild !== undefined)
                    this.grid.detach(this.grid.firstChild);
            else {
                this.remove(this.grid);
                this.grid = new Ui.Grid({
                    cols: '*,*,*,*',
                    rows: '*,*,*',
                    horizontalAlign: 'stretch'
                });
                this.append(this.grid);
            }
            let nbCols = 4;
            for (let i = 0; i < 12; i++) {
                let currentYear = this._date.getFullYear() - 6 + i;
                let row = Math.trunc(i / nbCols);
                let col = i % nbCols;
                let current = new Date(currentYear, 0, 1);
                let year = new MonthYearButton().assign({
                    text: currentYear.toString(),
                    onpressed: () => {
                        this._date = year.monthCalendarDate;
                        this.mode = 'DAY';
                    }
                });
                year.monthCalendarDate = current;
                this.grid.attach(year, col, row);
            }
        }
        onStyleChange() {
            let color = this.getStyleProperty('color');
            let dayColor = this.getStyleProperty('dayColor');
            let selectColor = this.getStyleProperty('selectColor');
            for (let i = 0; i < this.grid.children.length; i++) {
                let child = this.grid.children[i];
                if (child instanceof Ui.Label)
                    child.color = color;
                else if (child instanceof DayButton) {
                    for (let i2 = 0; i2 < child.children.length; i2++) {
                        let child2 = child.children[i2];
                        if (child2 instanceof Ui.Label)
                            child2.color = color;
                        else if (child2 instanceof Ui.Rectangle)
                            child2.fill = child.isSelected ? selectColor : dayColor;
                    }
                }
            }
        }
    }
    MonthCalendar.style = {
        color: 'black',
        dayColor: new Ui.Color(0.81, 0.81, 0.81, 0.5),
        selectColor: 'rgba(96,181,255,0.5)'
    };
    Ui.MonthCalendar = MonthCalendar;
    class DayButton extends Ui.Pressable {
        constructor() {
            super(...arguments);
            this.isSelected = false;
        }
    }
    class MonthYearButton extends Ui.FlatButton {
        constructor(init) {
            super(init);
            this.setStyleProperty('textWidth', 10);
            this.setStyleProperty('textTransform', 'none');
            this.setStyleProperty('fontWeight', 'bold');
        }
    }
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class TextFieldButton extends Ui.Button {
    }
    TextFieldButton.style = {
        padding: 6,
        iconSize: 22,
        background: 'rgba(250,250,250,0)',
        backgroundBorder: 'rgba(140,140,140,0)'
    };
    Ui.TextFieldButton = TextFieldButton;
    class TextButtonField extends Ui.Form {
        constructor(init) {
            super(init);
            this.changed = new Core.Events();
            this.buttonpressed = new Core.Events();
            this.validated = new Core.Events();
            this.padding = 0;
            this.graphic = new Ui.TextBgGraphic();
            this.append(this.graphic);
            this._textholder = new Ui.Label({
                opacity: 0.5, horizontalAlign: 'left', margin: 5,
                marginLeft: 10, marginRight: 10
            });
            this.append(this._textholder);
            var hbox = new Ui.HBox();
            this.append(hbox);
            this.entry = new Ui.Entry({
                margin: 5, marginLeft: 10, marginRight: 10, fontSize: 16
            });
            this.entry.focused.connect(() => this.onEntryFocus());
            this.entry.blurred.connect(() => this.onEntryBlur());
            hbox.append(this.entry, true);
            this.entry.changed.connect((e) => this.onEntryChange(e.target, e.value));
            this.button = new TextFieldButton({ orientation: 'horizontal', margin: 0 });
            hbox.append(this.button);
            this.submited.connect(() => this.onFormSubmit());
            this.button.pressed.connect(() => this.onButtonPress());
            if (init) {
                if (init.textHolder !== undefined)
                    this.textHolder = init.textHolder;
                if (init.widthText !== undefined)
                    this.widthText = init.widthText;
                if (init.buttonIcon !== undefined)
                    this.buttonIcon = init.buttonIcon;
                if (init.buttonText !== undefined)
                    this.buttonText = init.buttonText;
                if (init.value !== undefined)
                    this.value = init.value;
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
                if (init.onbuttonpressed)
                    this.buttonpressed.connect(init.onbuttonpressed);
                if (init.onvalidated)
                    this.validated.connect(init.onvalidated);
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        set onbuttonpressed(value) { this.buttonpressed.connect(value); }
        set onvalidated(value) { this.validated.connect(value); }
        set textHolder(text) {
            this._textholder.text = text;
        }
        set widthText(nbchar) {
            this.entry.width = nbchar * 16 * 2 / 3;
        }
        set buttonIcon(icon) {
            this.button.icon = icon;
        }
        set buttonText(text) {
            this.button.text = text;
        }
        get textValue() {
            return this.entry.value;
        }
        set textValue(value) {
            this.entry.value = value;
            if (value && value != '')
                this._textholder.hide();
        }
        get value() {
            return this.textValue;
        }
        set value(value) {
            this.textValue = value;
        }
        get autocomplete() {
            return this.entry.autocomplete;
        }
        set autocomplete(value) {
            this.entry.autocomplete = value;
        }
        get passwordMode() {
            return this.entry.passwordMode;
        }
        set passwordMode(value) {
            this.entry.passwordMode = value;
        }
        onButtonPress() {
            this.buttonpressed.fire({ target: this });
            this.validated.fire({ target: this, value: this.value });
        }
        onEntryChange(entry, value) {
            this.changed.fire({ target: this, value: value });
        }
        onFormSubmit() {
            this.validated.fire({ target: this, value: this.value });
        }
        onEntryFocus() {
            this._textholder.hide();
            this.graphic.hasFocus = true;
        }
        onEntryBlur() {
            if (this.value === '')
                this._textholder.show();
            this.graphic.hasFocus = false;
        }
    }
    Ui.TextButtonField = TextButtonField;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class DatePicker extends Ui.TextButtonField {
        constructor(init) {
            super(init);
            this._isValid = false;
            this.buttonIcon = 'calendar';
            this.widthText = 9;
            this.buttonpressed.connect(() => this.onDatePickerButtonPress());
            this.changed.connect(() => this.onDatePickerChange());
            if (init) {
                if (init.dayFilter !== undefined)
                    this.dayFilter = init.dayFilter;
                if (init.dateFilter !== undefined)
                    this.dateFilter = init.dateFilter;
                if (init.selectedDate !== undefined)
                    this.selectedDate = init.selectedDate;
            }
        }
        set dayFilter(dayFilter) {
            this._dayFilter = dayFilter;
        }
        set dateFilter(dateFilter) {
            this._dateFilter = dateFilter;
        }
        get isValid() {
            return this._isValid;
        }
        get selectedDate() {
            return this._selectedDate;
        }
        set selectedDate(date) {
            if (date === undefined) {
                this._selectedDate = undefined;
                this.textValue = '';
            }
            else {
                this._selectedDate = date;
                this.textValue = `${this.zeroPad(date.getDate(), 2)}/${this.zeroPad(date.getMonth() + 1, 2)}/${date.getFullYear()}`;
            }
            this._isValid = true;
        }
        onDatePickerButtonPress() {
            var splitDate = this.textValue.match(/^(\d{1,2})\/(\d{1,2})\/(\d{1,4})$/);
            if (splitDate !== null)
                this.selectedDate = new Date(parseInt(splitDate[3]), parseInt(splitDate[2]) - 1, parseInt(splitDate[1]));
            this.popup = new Ui.Popup();
            if (this.selectedDate !== undefined)
                this.calendar = new Ui.MonthCalendar({ horizontalAlign: 'center', margin: 10, selectedDate: new Date(this.selectedDate.getTime()), date: new Date(this.selectedDate.getTime()) });
            else
                this.calendar = new Ui.MonthCalendar({ horizontalAlign: 'center', margin: 10 });
            if (this._dayFilter !== undefined)
                this.calendar.dayFilter = this._dayFilter;
            if (this._dateFilter !== undefined)
                this.calendar.dateFilter = this._dateFilter;
            this.popup.content = this.calendar;
            this.calendar.dayselected.connect((e) => this.onDaySelect(e.target, e.value));
            this.popup.openElement(this);
        }
        onDatePickerChange() {
            this._isValid = false;
            this._selectedDate = undefined;
            var dateStr = this.textValue;
            if (dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{1,4})$/)) {
                var splitDate = this.textValue.match(/^(\d{1,2})\/(\d{1,2})\/(\d{1,4})$/);
                var date = new Date(parseInt(splitDate[3]), parseInt(splitDate[2]) - 1, parseInt(splitDate[1]));
                var newStr = ((date.getDate() < 10) ? '0' : '') + date.getDate() + '/' + ((date.getMonth() < 9) ? '0' : '') + (date.getMonth() + 1) + '/' + date.getFullYear();
                if (!((parseInt(splitDate[3]) != date.getFullYear()) || (parseInt(splitDate[2]) - 1 != date.getMonth()) || (parseInt(splitDate[1]) != date.getDate()))) {
                    this._selectedDate = date;
                    this._isValid = true;
                }
            }
        }
        zeroPad(val, size = 2) {
            let s = val.toString();
            while (s.length < size)
                s = "0" + s;
            return s;
        }
        onDaySelect(monthcalendar, date) {
            this.selectedDate = date;
            if (this.popup)
                this.popup.close();
            this.popup = undefined;
            this.changed.fire({ target: this, value: this.textValue });
        }
    }
    Ui.DatePicker = DatePicker;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class DownloadButton extends Ui.LinkButton {
        constructor(init) {
            super(init);
            this.download = new Core.Events();
            this.link.connect(() => this.onLinkPress());
        }
        set ondownload(value) { this.download.connect(value); }
        onLinkPress() {
            this.download.fire({ target: this });
        }
    }
    DownloadButton.style = {
        background: '#a4f4a4'
    };
    Ui.DownloadButton = DownloadButton;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class SVGElement extends Ui.Element {
        renderSVG(svg) {
        }
        renderDrawing() {
            let svg = document.createElementNS(svgNS, 'svg');
            svg.setAttribute('focusable', 'false');
            let content = this.renderSVG(svg);
            if (content !== undefined)
                svg.appendChild(content);
            return svg;
        }
    }
    Ui.SVGElement = SVGElement;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class ShapeIcon extends Ui.Shape {
        constructor(init) {
            super(init);
            if (init) {
                if (init.icon !== undefined)
                    this.icon = init.icon;
            }
        }
        set icon(icon) {
            this.path = Ui.Icon.icons[icon];
        }
        arrangeCore(width, height) {
            super.arrangeCore(width, height);
            this.scale = Math.min(width, height) / 48;
        }
    }
    Ui.ShapeIcon = ShapeIcon;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class IFrame extends Ui.Element {
        constructor(init) {
            super(init);
            this._isReady = false;
            this.ready = new Core.Events();
            this.locationchanged = new Core.Events();
            this.iframeDrawing.addEventListener('load', () => {
                try {
                    if (this.isReady) {
                        let location = this.iframeDrawing.contentWindow.location;
                        this.locationchanged.fire({ target: this, value: location });
                    }
                }
                catch (_a) { }
                this.onIFrameLoad();
            });
            if (init) {
                if (init.src !== undefined)
                    this.src = init.src;
                if (init.allowFullscreen !== undefined)
                    this.allowFullscreen = init.allowFullscreen;
            }
        }
        set onready(value) { this.ready.connect(value); }
        set onlocationchanged(value) { this.locationchanged.connect(value); }
        get src() {
            return this.iframeDrawing.src;
        }
        set src(src) {
            this._isReady = false;
            this.iframeDrawing.src = src;
        }
        get allowFullscreen() {
            return this.iframeDrawing.allowFullscreen;
        }
        set allowFullscreen(allowFullscreen) {
            this.iframeDrawing.allowFullscreen = allowFullscreen;
        }
        get isReady() {
            return this._isReady;
        }
        onIFrameLoad() {
            if (!this._isReady) {
                this._isReady = true;
                this.ready.fire({ target: this });
            }
        }
        renderDrawing() {
            if (Core.Navigator.iOs) {
                var drawing = super.renderDrawing();
                drawing.style.overflow = 'scroll';
                drawing.style.webkitOverflowScrolling = 'touch';
                this.iframeDrawing = document.createElement('iframe');
                this.iframeDrawing.scrolling = 'no';
                this.iframeDrawing.style.border = '0px';
                this.iframeDrawing.style.margin = '0px';
                this.iframeDrawing.style.padding = '0px';
                this.iframeDrawing.style.width = '100%';
                this.iframeDrawing.style.height = '100%';
                drawing.appendChild(this.iframeDrawing);
                return drawing;
            }
            else {
                this.iframeDrawing = document.createElement('iframe');
                this.iframeDrawing.style.border = '0px';
                this.iframeDrawing.style.margin = '0px';
                this.iframeDrawing.style.padding = '0px';
                this.iframeDrawing.style.width = '100%';
                this.iframeDrawing.style.height = '100%';
                return this.iframeDrawing;
            }
        }
        arrangeCore(width, height) {
            this.iframeDrawing.style.width = width + 'px';
        }
    }
    Ui.IFrame = IFrame;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class ContentEditable extends Ui.Html {
        constructor(init) {
            super(init);
            this.anchorOffset = 0;
            this._hasSelection = false;
            this.anchorchanged = new Core.Events();
            this.changed = new Core.Events();
            this.validated = new Core.Events();
            this.selectionentered = new Core.Events();
            this.selectionleaved = new Core.Events();
            this.testAnchorChange = () => {
                var _a;
                let sel = getSelection();
                if (!sel)
                    return;
                let node = sel.anchorNode;
                let currentNode = node;
                while (currentNode != null && currentNode != this.drawing) {
                    currentNode = currentNode.parentNode;
                }
                let hasSelection = (currentNode != null);
                if (this._hasSelection != hasSelection) {
                    this._hasSelection = hasSelection;
                    if (hasSelection)
                        this.selectionentered.fire({ target: this });
                    else
                        this.selectionleaved.fire({ target: this });
                }
                if (!hasSelection) {
                    if (this.hasFocus)
                        this.onBlur();
                    return;
                }
                if (!this.hasFocus)
                    this.onFocus();
                if ((sel.anchorNode != this.anchorNode) ||
                    (sel.anchorOffset != this.anchorOffset)) {
                    this.anchorNode = (_a = sel.anchorNode) !== null && _a !== void 0 ? _a : undefined;
                    this.anchorOffset = sel.anchorOffset;
                    this.anchorchanged.fire({ target: this });
                }
            };
            this.selectable = true;
            this.drawing.removeAttribute('tabindex');
            this.htmlDrawing.setAttribute('contenteditable', 'true');
            this.htmlDrawing.style.display = 'block';
            this.drawing.addEventListener('keyup', (e) => this.onKeyUp(e));
            this.htmlDrawing.addEventListener('input', () => this.onInput());
            if (init) {
                if (init.onanchorchanged)
                    this.anchorchanged.connect(init.onanchorchanged);
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
                if (init.onvalidated)
                    this.validated.connect(init.onvalidated);
            }
        }
        set onanchorchanged(value) { this.anchorchanged.connect(value); }
        set onchanged(value) { this.changed.connect(value); }
        set onvalidated(value) { this.validated.connect(value); }
        set onselectionentered(value) { this.selectionentered.connect(value); }
        set onselectionleaved(value) { this.selectionleaved.connect(value); }
        onDisable() {
            super.onDisable();
            this.htmlDrawing.setAttribute('contenteditable', 'false');
        }
        onEnable() {
            super.onEnable();
            this.htmlDrawing.setAttribute('contenteditable', 'true');
        }
        onLoad() {
            super.onLoad();
            document.addEventListener('selectionchange', this.testAnchorChange);
        }
        onUnload() {
            super.onUnload();
            document.removeEventListener('selectionchange', this.testAnchorChange);
        }
        onKeyUp(event) {
            this.testAnchorChange();
            let key = event.which;
            if (key == 13)
                this.validated.fire({ target: this });
        }
        onInput() {
            this.invalidateMeasure();
            this.changed.fire({ target: this, element: this.htmlDrawing });
        }
        static unwrapNode(node) {
            let parent = node.parentNode;
            if (!parent)
                return;
            while (node.firstChild) {
                parent.insertBefore(node.firstChild, node);
            }
            parent.removeChild(node);
        }
        static filterNode(node, allowedTags, removeScript = false) {
            let childNodes = [];
            for (let i = 0; i < node.childNodes.length; i++)
                childNodes.push(node.childNodes[i]);
            for (let child of childNodes)
                ContentEditable.filterNode(child, allowedTags, removeScript);
            if (allowedTags.indexOf(node.nodeName) == -1)
                ContentEditable.unwrapNode(node);
            let element = node;
            if (element.removeAttribute) {
                element.removeAttribute('style');
                if (removeScript) {
                    let rmAttrs = [];
                    for (let i = 0; i < element.attributes.length; i++) {
                        let attr = element.attributes[i];
                        if (attr.name.indexOf('on') == 0)
                            rmAttrs.push(attr.name);
                    }
                    for (let attrName of rmAttrs)
                        element.removeAttribute(attrName);
                }
            }
        }
        ;
        static filterHtmlContent(rootElement, allowedTags, removeScript = false) {
            let childNodes = [];
            for (let i = 0; i < rootElement.childNodes.length; i++)
                childNodes.push(rootElement.childNodes[i]);
            for (let child of childNodes)
                ContentEditable.filterNode(child, allowedTags, removeScript);
        }
        static filterHtmlString(html, allowedTags, removeScript = false) {
            let parser = new DOMParser();
            let doc = parser.parseFromString(html, 'text/html');
            Ui.ContentEditable.filterHtmlContent(doc.documentElement, allowedTags, removeScript);
            return doc.documentElement.innerHTML;
        }
        findTag(tagName) {
            let selection = window.getSelection();
            if (selection == null)
                return undefined;
            if (selection.anchorNode == null)
                return undefined;
            let current = selection.anchorNode;
            while (current) {
                if (current == this.htmlDrawing)
                    return undefined;
                if (current.nodeName == tagName)
                    return current;
                current = current.parentNode;
            }
            return undefined;
        }
        static saveSelection() {
            let selection = window.getSelection();
            return selection && selection.rangeCount ? selection.getRangeAt(0) : null;
        }
        static restoreSelection(range) {
            if (range) {
                let selection = window.getSelection();
                if (selection) {
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }
        }
    }
    Ui.ContentEditable = ContentEditable;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class ScrollLoader extends Core.Object {
        constructor() {
            super();
            this.changed = new Core.Events();
        }
        getMin() {
            return 0;
        }
        getMax() {
            return -1;
        }
        getElementAt(position) {
            throw 'Invalid position';
        }
    }
    Ui.ScrollLoader = ScrollLoader;
    class VBoxScrollable extends Ui.Container {
        constructor(init) {
            super(init);
            this._scrollHorizontal = true;
            this._scrollVertical = true;
            this.scrollbarHorizontalNeeded = false;
            this.scrollbarVerticalNeeded = false;
            this.showShadows = false;
            this.lock = false;
            this.isOver = false;
            this.offsetX = 0;
            this.offsetY = 0;
            this.viewWidth = 0;
            this.viewHeight = 0;
            this.contentWidth = 0;
            this.contentHeight = 0;
            this.scrollLock = false;
            this.scrolled = new Core.Events();
            this.autoShowScrollbars = () => {
                if (this.showClock == undefined) {
                    this.showClock = new Anim.Clock({ duration: 'forever' });
                    this.showClock.timeupdate.connect((e) => this.onShowBarsTick(e.target, e.progress, e.deltaTick));
                    this.showClock.begin();
                }
            };
            this.autoHideScrollbars = () => {
                if (this.contentBox.isDown || this.contentBox.isInertia || this.isOver ||
                    (this.scrollbarVertical && this.scrollbarVertical.isDown) ||
                    (this.scrollbarHorizontal && this.scrollbarHorizontal.isDown))
                    return;
                if (this.showClock === undefined) {
                    this.showClock = new Anim.Clock({ duration: 'forever' });
                    this.showClock.timeupdate.connect((e) => this.onShowBarsTick(e.target, e.progress, e.deltaTick));
                    this.showClock.begin();
                }
            };
            this.onScrollbarHorizontalMove = () => {
                if (this.scrollLock)
                    return;
                let totalWidth = this.viewWidth - this.scrollbarHorizontal.layoutWidth;
                let offsetX = Math.min(1, Math.max(0, this.scrollbarHorizontal.positionX / totalWidth));
                this.setOffset(offsetX, undefined);
                this.scrollbarHorizontal.setPosition(offsetX * totalWidth, undefined);
            };
            this.onScrollbarVerticalMove = () => {
                if (this.scrollLock)
                    return;
                let totalHeight = this.viewHeight - this.scrollbarVertical.layoutHeight;
                let offsetY = Math.min(1, Math.max(0, this.scrollbarVertical.positionY / totalHeight));
                this.setOffset(undefined, offsetY);
                this.scrollbarVertical.setPosition(undefined, offsetY * totalHeight);
            };
            this.contentBox = new VBoxScrollableContent();
            this.contentBox.scrolled.connect(() => this.onScroll());
            this.contentBox.downed.connect(() => this.autoShowScrollbars());
            this.contentBox.inertiaended.connect(() => this.autoHideScrollbars());
            this.appendChild(this.contentBox);
            new Ui.OverWatcher({
                element: this,
                onentered: () => {
                    this.isOver = true;
                    this.autoShowScrollbars();
                },
                onleaved: () => {
                    this.isOver = false;
                    this.autoHideScrollbars();
                }
            });
            new Ui.WheelWatcher({
                element: this,
                onchanged: (e) => this.onWheel(e)
            });
            if (init) {
                if (init.loader !== undefined)
                    this.loader = init.loader;
                if (init.maxScale !== undefined)
                    this.maxScale = init.maxScale;
                if (init.content !== undefined)
                    this.content = init.content;
                if (init.scrollHorizontal !== undefined)
                    this.scrollHorizontal = init.scrollHorizontal;
                if (init.scrollVertical !== undefined)
                    this.scrollVertical = init.scrollVertical;
                if (init.scrollbarVertical !== undefined)
                    this.scrollbarVertical = init.scrollbarVertical;
                if (init.scrollbarHorizontal !== undefined)
                    this.scrollbarHorizontal = init.scrollbarHorizontal;
            }
        }
        set onscrolled(value) { this.scrolled.connect(value); }
        reload() {
            this.contentBox.reload();
        }
        getActiveItems() {
            return this.contentBox.getActiveItems();
        }
        set loader(loader) {
            this.contentBox.setLoader(loader);
        }
        set maxScale(maxScale) {
            this.contentBox.maxScale = maxScale;
        }
        set content(content) {
            this.contentBox.content = content;
        }
        get content() {
            return this.contentBox.content;
        }
        get scrollHorizontal() {
            return this._scrollHorizontal;
        }
        set scrollHorizontal(scroll) {
            if (scroll !== this._scrollHorizontal) {
                this._scrollHorizontal = scroll;
                this.invalidateMeasure();
            }
        }
        get scrollVertical() {
            return this._scrollVertical;
        }
        set scrollVertical(scroll) {
            if (scroll !== this._scrollVertical) {
                this._scrollVertical = scroll;
                this.invalidateMeasure();
            }
        }
        get scrollbarVertical() {
            return this._scrollbarVertical;
        }
        set scrollbarVertical(scrollbarVertical) {
            if (this._scrollbarVertical) {
                this._scrollbarVertical.downed.disconnect(this.autoShowScrollbars);
                this._scrollbarVertical.upped.disconnect(this.autoHideScrollbars);
                this._scrollbarVertical.moved.disconnect(this.onScrollbarVerticalMove);
                this.removeChild(this._scrollbarVertical);
            }
            if (scrollbarVertical) {
                this._scrollbarVertical = scrollbarVertical;
                this._scrollbarVertical.moveHorizontal = false;
                this._scrollbarVertical.downed.connect(this.autoShowScrollbars);
                this._scrollbarVertical.upped.connect(this.autoHideScrollbars);
                this._scrollbarVertical.moved.connect(this.onScrollbarVerticalMove);
                this._scrollbarVertical.opacity = 0;
                this.appendChild(this._scrollbarVertical);
            }
        }
        get scrollbarHorizontal() {
            return this._scrollbarHorizontal;
        }
        set scrollbarHorizontal(scrollbarHorizontal) {
            if (this._scrollbarHorizontal) {
                this._scrollbarHorizontal.downed.disconnect(this.autoShowScrollbars);
                this._scrollbarHorizontal.upped.disconnect(this.autoHideScrollbars);
                this._scrollbarHorizontal.moved.disconnect(this.onScrollbarHorizontalMove);
                this.removeChild(this._scrollbarHorizontal);
            }
            if (scrollbarHorizontal) {
                this._scrollbarHorizontal = scrollbarHorizontal;
                this._scrollbarHorizontal.moveVertical = false;
                this._scrollbarHorizontal.downed.connect(this.autoShowScrollbars);
                this._scrollbarHorizontal.upped.connect(this.autoHideScrollbars);
                this._scrollbarHorizontal.moved.connect(this.onScrollbarHorizontalMove);
                this._scrollbarHorizontal.opacity = 0;
                this.appendChild(this._scrollbarHorizontal);
            }
        }
        setOffset(offsetX, offsetY, absolute = false) {
            if (offsetX === undefined)
                offsetX = this.offsetX;
            else if (!absolute)
                offsetX *= this.contentWidth - this.viewWidth;
            if (offsetY === undefined)
                offsetY = this.offsetY;
            else if (!absolute)
                offsetY *= this.contentHeight - this.viewHeight;
            if (offsetX < 0)
                offsetX = 0;
            else if (this.viewWidth + offsetX > this.contentWidth)
                offsetX = this.contentWidth - this.viewWidth;
            if (offsetY < 0)
                offsetY = 0;
            else if (this.viewHeight + offsetY > this.contentHeight)
                offsetY = this.contentHeight - this.viewHeight;
            this.relativeOffsetX = (this.contentWidth - this.viewWidth) > 0 ? offsetX / (this.contentWidth - this.viewWidth) : 0;
            this.relativeOffsetY = (this.contentHeight - this.viewHeight) > 0 ? offsetY / (this.contentHeight - this.viewHeight) : 0;
            if ((this.offsetX !== offsetX) || (this.offsetY !== offsetY)) {
                this.offsetX = offsetX;
                this.offsetY = offsetY;
                this.contentBox.setOffset(offsetX, offsetY);
                return true;
            }
            else
                return false;
        }
        getOffsetX() {
            return this.contentBox.offsetX;
        }
        getRelativeOffsetX() {
            return this.relativeOffsetX;
        }
        getOffsetY() {
            return this.contentBox.offsetY;
        }
        getRelativeOffsetY() {
            return this.relativeOffsetY;
        }
        onWheel(event) {
            if (this.setOffset(this.contentBox.offsetX + event.deltaX * 3, this.contentBox.offsetY + event.deltaY * 3, true)) {
                event.stopPropagation();
            }
        }
        onShowBarsTick(clock, progress, delta) {
            let show = (this.contentBox.isDown || this.contentBox.isInertia || this.isOver ||
                (this.scrollbarVertical && this.scrollbarVertical.isDown) ||
                (this.scrollbarHorizontal && this.scrollbarHorizontal.isDown));
            let stop = false;
            let speed = 2;
            let opacity = this.scrollbarHorizontal.opacity;
            if (show) {
                opacity += (delta * speed);
                if (opacity >= 1) {
                    opacity = 1;
                    stop = true;
                }
            }
            else {
                opacity -= (delta * speed);
                if (opacity <= 0) {
                    opacity = 0;
                    stop = true;
                }
            }
            this.scrollbarHorizontal.opacity = opacity;
            this.scrollbarVertical.opacity = opacity;
            if (stop) {
                if (this.showClock)
                    this.showClock.stop();
                this.showClock = undefined;
            }
        }
        onScroll() {
            this.updateOffset();
            this.scrolled.fire({ target: this, offsetX: this.offsetX, offsetY: this.offsetY });
        }
        updateOffset() {
            if (this.contentBox === undefined)
                return;
            this.offsetX = this.contentBox.offsetX;
            this.offsetY = this.contentBox.offsetY;
            this.viewWidth = this.layoutWidth;
            this.viewHeight = this.layoutHeight;
            this.contentWidth = this.contentBox.getContentWidth();
            this.contentHeight = this.contentBox.getContentHeight();
            this.relativeOffsetX = (this.contentWidth - this.viewWidth) > 0 ? this.offsetX / (this.contentWidth - this.viewWidth) : 0;
            this.relativeOffsetY = (this.contentHeight - this.viewHeight) > 0 ? this.offsetY / (this.contentHeight - this.viewHeight) : 0;
            if (this.contentHeight > this.viewHeight)
                this.scrollbarVerticalNeeded = true;
            else
                this.scrollbarVerticalNeeded = false;
            if (this.contentWidth > this.viewWidth)
                this.scrollbarHorizontalNeeded = true;
            else
                this.scrollbarHorizontalNeeded = false;
            if (this.scrollbarVerticalNeeded) {
                this.scrollbarVerticalHeight = Math.max((this.viewHeight / this.contentHeight) * this.viewHeight, this.scrollbarVertical.measureHeight);
                this.scrollbarVertical.arrange(this.layoutWidth - this.scrollbarVertical.measureWidth, 0, this.scrollbarVertical.measureWidth, this.scrollbarVerticalHeight);
                this.scrollbarVertical.show();
            }
            else {
                this.scrollbarVertical.hide();
                this.offsetY = 0;
            }
            if (this.scrollbarHorizontalNeeded) {
                this.scrollbarHorizontalWidth = Math.max((this.viewWidth / this.contentWidth) * this.viewWidth, this.scrollbarHorizontal.measureWidth);
                this.scrollbarHorizontal.arrange(0, this.layoutHeight - this.scrollbarHorizontal.measureHeight, this.scrollbarHorizontalWidth, this.scrollbarHorizontal.measureHeight);
                this.scrollbarHorizontal.show();
            }
            else {
                this.scrollbarHorizontal.hide();
                this.offsetX = 0;
            }
            this.scrollLock = true;
            if (this.scrollbarHorizontalNeeded) {
                let relOffsetX = this.offsetX / (this.contentWidth - this.viewWidth);
                if (relOffsetX > 1) {
                    relOffsetX = 1;
                    this.setOffset(relOffsetX, undefined);
                }
                this.scrollbarHorizontal.setPosition((this.viewWidth - this.scrollbarHorizontalWidth) * relOffsetX, undefined);
            }
            if (this.scrollbarVerticalNeeded) {
                let relOffsetY = this.offsetY / (this.contentHeight - this.viewHeight);
                if (relOffsetY > 1) {
                    relOffsetY = 1;
                    this.setOffset(undefined, relOffsetY);
                }
                this.scrollbarVertical.setPosition(undefined, (this.viewHeight - this.scrollbarVerticalHeight) * relOffsetY);
            }
            this.scrollLock = false;
        }
        measureCore(width, height) {
            let size = { width: 0, height: 0 };
            this.scrollbarHorizontal.measure(width, height);
            this.scrollbarVertical.measure(width, height);
            let contentSize = this.contentBox.measure(width, height);
            if (contentSize.width < width)
                size.width = contentSize.width;
            else
                size.width = width;
            if (contentSize.height < height)
                size.height = contentSize.height;
            else
                size.height = height;
            if (!this.scrollVertical)
                size.height = contentSize.height;
            if (!this.scrollHorizontal)
                size.width = contentSize.width;
            return size;
        }
        arrangeCore(width, height) {
            this.viewWidth = width;
            this.viewHeight = height;
            this.contentBox.arrange(0, 0, this.viewWidth, this.viewHeight);
            this.contentWidth = this.contentBox.getContentWidth();
            this.contentHeight = this.contentBox.getContentHeight();
            this.updateOffset();
        }
    }
    Ui.VBoxScrollable = VBoxScrollable;
    class VBoxScrollableContent extends Ui.Transformable {
        constructor() {
            super();
            this.contentWidth = 0;
            this.contentHeight = 0;
            this.estimatedHeight = 36;
            this.estimatedHeightNeeded = true;
            this.beforeRemoveItems = [];
            this.activeItemsPos = 0;
            this.activeItemsY = 0;
            this.activeItemsHeight = 0;
            this.reloadNeeded = false;
            this.scrolled = new Core.Events();
            this.onLoaderChange = () => {
                this.reloadNeeded = true;
                this.invalidateMeasure();
            };
            this.activeItems = [];
            this.allowLeftMouse = false;
            this.clipToBounds = true;
            this.drawing.addEventListener('scroll', () => {
                this.translateX -= this.drawing.scrollLeft;
                this.translateY -= this.drawing.scrollTop;
                this.drawing.scrollLeft = 0;
                this.drawing.scrollTop = 0;
                this.onContentTransform(false);
            });
            this.allowTranslate = true;
            this.allowRotate = false;
            this.minScale = 1;
            this.maxScale = 1;
            this.inertia = true;
            this.setTransformOrigin(0, 0);
            this.removeChild(this.contentBox);
        }
        set onscrolled(value) { this.scrolled.connect(value); }
        setLoader(loader) {
            if (this.loader !== loader) {
                if (this.loader !== undefined)
                    this.loader.changed.disconnect(this.onLoaderChange);
                this.loader = loader;
                if (this.loader !== undefined)
                    this.loader.changed.connect(this.onLoaderChange);
                this.reload();
            }
        }
        getActiveItems() {
            return this.activeItems;
        }
        get offsetX() {
            return -this.translateX;
        }
        get offsetY() {
            return Math.max(0, (((-this.translateY) / this.scale) - this.getMinY()) * this.scale);
        }
        setOffset(x, y) {
            let minY = this.getMinY();
            let translateY = -(((y / this.scale) + minY) * this.scale);
            this.setContentTransform(-x, translateY, undefined, undefined);
        }
        getContentWidth() {
            return this.contentWidth;
        }
        getContentHeight() {
            return this.getEstimatedContentHeight() * this.scale;
        }
        getEstimatedContentHeight() {
            let itemsBefore = (this.activeItemsPos - this.loader.getMin());
            let itemsAfter = (this.loader.getMax() + 1 - (this.activeItemsPos + this.activeItems.length));
            let minY = this.activeItemsY - (itemsBefore * this.estimatedHeight);
            let maxY = this.activeItemsY + this.activeItemsHeight + (itemsAfter * this.estimatedHeight);
            return maxY - minY;
        }
        getMinY() {
            let itemsBefore = (this.activeItemsPos - this.loader.getMin());
            let minY = this.activeItemsY - (itemsBefore * this.estimatedHeight);
            return minY;
        }
        getMaxY() {
            let itemsAfter = (this.loader.getMax() + 1 - (this.activeItemsPos + this.activeItems.length));
            let maxY = this.activeItemsY + this.activeItemsHeight + (itemsAfter * this.estimatedHeight);
            return maxY;
        }
        loadItems(w = this.layoutWidth, h = this.layoutHeight) {
            if (this.loader.getMax() - this.loader.getMin() < 0)
                return;
            if ((w === 0) || (h === 0))
                return;
            let matrix = this.matrix;
            let invMatrix = matrix.inverse();
            let p0 = (new Ui.Point(0, 0)).multiply(invMatrix);
            let p1 = (new Ui.Point(w, h)).multiply(invMatrix);
            let refPos;
            let refY = 0;
            let stillActiveItems = [];
            let stillActiveHeight = 0;
            let y = this.activeItemsY;
            for (let i = 0; i < this.activeItems.length; i++) {
                let activeItem = this.activeItems[i];
                let itemHeight = activeItem.measureHeight;
                if (((y >= p0.y) && (y <= p1.y)) || ((y + itemHeight >= p0.y) && (y + itemHeight <= p1.y)) ||
                    ((y <= p0.y) && (y + itemHeight >= p1.y))) {
                    if (refPos === undefined) {
                        refPos = (i + this.activeItemsPos);
                        refY = y;
                    }
                    stillActiveItems.push(activeItem);
                    stillActiveHeight += activeItem.measureHeight;
                }
                else {
                    this.removeChild(activeItem);
                }
                y += itemHeight;
            }
            if (refPos === undefined) {
                refPos = Math.floor((-this.translateY) / (this.estimatedHeight * this.scale));
                refPos = Math.max(this.loader.getMin(), Math.min(this.loader.getMax(), refPos));
                refY = -this.translateY / this.scale;
                this.activeItemsPos = refPos;
                this.activeItems = [];
                let item = this.loader.getElementAt(refPos);
                if (item.parent !== this)
                    this.appendChild(item);
                let size = item.measure(w, 0);
                item.arrange(0, 0, w, size.height);
                item.setTransformOrigin(0, 0);
                this.activeItems.push(item);
                this.activeItemsHeight = size.height;
            }
            else {
                this.activeItemsPos = refPos;
                this.activeItems = stillActiveItems;
                this.activeItemsHeight = stillActiveHeight;
            }
            while (refY > p0.y) {
                let pos = this.activeItemsPos - 1;
                if (pos < this.loader.getMin())
                    break;
                let item = this.loader.getElementAt(pos);
                this.prependChild(item);
                let size = item.measure(w, 0);
                item.arrange(0, 0, w, size.height);
                item.setTransformOrigin(0, 0);
                this.activeItems.unshift(item);
                this.activeItemsHeight += size.height;
                refY -= size.height;
                this.activeItemsPos = pos;
            }
            while (refY + this.activeItemsHeight < p1.y) {
                let pos = this.activeItemsPos + this.activeItems.length;
                if (pos > this.loader.getMax())
                    break;
                let item = this.loader.getElementAt(pos);
                this.appendChild(item);
                let size = item.measure(w, 0);
                item.arrange(0, 0, w, size.height);
                item.setTransformOrigin(0, 0);
                this.activeItems.push(item);
                this.activeItemsHeight += size.height;
            }
            this.activeItemsY = refY;
            this.activeItemsHeight = 0;
            for (let i = 0; i < this.activeItems.length; i++) {
                let item = this.activeItems[i];
                item.transform = matrix.clone().translate(0, this.activeItemsY + this.activeItemsHeight);
                this.activeItemsHeight += item.measureHeight;
            }
            if (this.estimatedHeightNeeded) {
                this.estimatedHeightNeeded = false;
                this.estimatedHeight = this.activeItemsHeight / this.activeItems.length;
            }
            for (let i = 0; i < this.beforeRemoveItems.length; i++) {
                if (this.activeItems.indexOf(this.beforeRemoveItems[i]) == -1)
                    this.removeChild(this.beforeRemoveItems[i]);
            }
            this.beforeRemoveItems = [];
        }
        reload() {
            for (let i = 0; i < this.beforeRemoveItems.length; i++)
                this.removeChild(this.beforeRemoveItems[i]);
            this.beforeRemoveItems = this.activeItems;
            this.activeItems = [];
            this.activeItems = [];
            this.activeItemsPos = 0;
            this.activeItemsY = 0;
            this.activeItemsHeight = 0;
            this.estimatedHeightNeeded = true;
            this.onContentTransform(false);
        }
        measureCore(width, height) {
            if (this.reloadNeeded) {
                this.reloadNeeded = false;
                this.reload();
            }
            for (let i = 0; i < this.activeItems.length; i++) {
                let item = this.activeItems[i];
                item.measure(width, 0);
            }
            this.loadItems(width, height);
            let y = 0;
            let minWidth = 0;
            for (let i = 0; i < this.activeItems.length; i++) {
                let item = this.activeItems[i];
                minWidth = Math.max(minWidth, item.measureWidth);
                y += item.measureHeight;
            }
            this.activeItemsHeight = y;
            return { width: minWidth, height: this.getEstimatedContentHeight() };
        }
        arrangeCore(width, height) {
            for (let i = 0; i < this.activeItems.length; i++) {
                let item = this.activeItems[i];
                width = Math.max(width, item.measureWidth);
            }
            for (let i = 0; i < this.activeItems.length; i++) {
                let activeItem = this.activeItems[i];
                activeItem.arrange(0, 0, width, activeItem.measureHeight);
            }
            this.loadItems();
        }
        onContentTransform(testOnly) {
            let scale = this.scale;
            if (this.translateX > 0)
                this.translateX = 0;
            let itemsBefore = (this.activeItemsPos - this.loader.getMin());
            let itemsAfter = (this.loader.getMax() + 1 - (this.activeItemsPos + this.activeItems.length));
            let minY = this.activeItemsY - (itemsBefore * this.estimatedHeight);
            let maxY = this.activeItemsY + this.activeItemsHeight + (itemsAfter * this.estimatedHeight);
            minY *= scale;
            maxY *= scale;
            let viewWidth = this.layoutWidth;
            let viewHeight = this.layoutHeight;
            let contentWidth = 0;
            for (let item of this.activeItems)
                contentWidth = Math.max(contentWidth, item.measureWidth);
            this.contentWidth = Math.max(contentWidth, viewWidth) * scale;
            this.contentHeight = this.getEstimatedContentHeight() * scale;
            this.translateX = Math.max(this.translateX, -(this.contentWidth - viewWidth));
            if (this.translateY < -(maxY - viewHeight))
                this.translateY = -(maxY - viewHeight);
            if (this.translateY > -minY)
                this.translateY = -minY;
            this.loadItems();
            contentWidth = 0;
            for (let item of this.activeItems)
                contentWidth = Math.max(contentWidth, item.measureWidth);
            this.contentWidth = contentWidth * scale;
            this.contentHeight = this.getEstimatedContentHeight() * scale;
            if (testOnly !== true)
                this.scrolled.fire({ target: this, offsetX: this.offsetX, offsetY: this.offsetY });
        }
        onChildInvalidateMeasure(child, event) {
            if (event != 'add' && event != 'remove')
                super.onChildInvalidateMeasure(child, event);
        }
    }
    Ui.VBoxScrollableContent = VBoxScrollableContent;
    class VBoxScrollingArea extends VBoxScrollable {
        constructor(init) {
            super(init);
            this.horizontalScrollbar = new Ui.Scrollbar('horizontal');
            this.scrollbarHorizontal = this.horizontalScrollbar;
            this.verticalScrollbar = new Ui.Scrollbar('vertical');
            this.scrollbarVertical = this.verticalScrollbar;
        }
        onStyleChange() {
            let radius = this.getStyleProperty('radius');
            this.horizontalScrollbar.radius = radius;
            this.verticalScrollbar.radius = radius;
            let color = this.getStyleProperty('color');
            this.horizontalScrollbar.fill = color;
            this.verticalScrollbar.fill = color;
        }
    }
    VBoxScrollingArea.style = {
        color: 'rgba(50,50,50,0.7)',
        radius: 0
    };
    Ui.VBoxScrollingArea = VBoxScrollingArea;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class SelectionArea extends Ui.LBox {
        constructor(init) {
            super(init);
            this.lastSelection = new Date('1970-01-01');
            this.lock = false;
            if ('PointerEvent' in window)
                this.drawing.addEventListener('pointerdown', (e) => this.onPointerDown(e), { passive: false });
            else
                this.drawing.addEventListener('mousedown', (e) => this.onMouseDown(e));
            this.drawing.addEventListener('click', (e) => {
                if (Math.abs(Date.now() - this.lastSelection.getTime()) < 60)
                    return;
                var selection = this.getParentSelectionHandler();
                if (selection && selection.elements.length > 0) {
                    selection.clear();
                    e.stopImmediatePropagation();
                }
            });
            this.drawing.addEventListener('click', (e) => {
                if (Math.abs(Date.now() - this.lastSelection.getTime()) < 60) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                }
            }, true);
            this.drawing.addEventListener('keydown', (e) => this.onKeyDown(e));
        }
        getParentSelectionHandler() {
            let parent = this.parent;
            while (parent !== undefined) {
                if ('getSelectionHandler' in parent)
                    return parent.getSelectionHandler();
                parent = parent.parent;
            }
            return undefined;
        }
        findAreaElements(p1, p2) {
            let res = new Array();
            let p = new Ui.Point(Math.min(p1.x, p2.x), Math.min(p1.y, p2.y));
            let s = { width: Math.abs(p1.x - p2.x), height: Math.abs(p1.y - p2.y) };
            let intersect = (el) => {
                let m = el.transformToElement(this);
                let pe1 = (new Ui.Point(0, 0)).multiply(m);
                let pe2 = (new Ui.Point(el.layoutWidth, el.layoutHeight)).multiply(m);
                let pe = new Ui.Point(Math.min(pe1.x, pe2.x), Math.min(pe1.y, pe2.y));
                let se = { width: Math.abs(pe1.x - pe2.x), height: Math.abs(pe1.y - pe2.y) };
                let hoverlap = (p.x < pe.x + se.width) && (pe.x < p.x + s.width);
                let voverlap = (p.y < pe.y + se.height) && (pe.y < p.y + s.height);
                return hoverlap && voverlap;
            };
            let addSelectionable = (el) => {
                let watcher = Ui.SelectionableWatcher.getSelectionableWatcher(el);
                if (watcher) {
                    if (intersect(watcher.element))
                        res.push(watcher);
                }
                else if (el instanceof Ui.Container)
                    el.children.forEach(el2 => addSelectionable(el2));
            };
            addSelectionable(this);
            res = res.sort((a, b) => {
                let m = a.element.transformToElement(this);
                let c1 = (new Ui.Point(a.element.layoutWidth / 2, a.element.layoutHeight / 2)).multiply(m);
                let d1 = Math.sqrt(Math.pow((c1.x - p2.x), 2) + Math.pow((c1.y - p2.y), 2));
                m = b.element.transformToElement(this);
                let c2 = (new Ui.Point(b.element.layoutWidth / 2, b.element.layoutHeight / 2)).multiply(m);
                let d2 = Math.sqrt(Math.pow((c2.x - p2.x), 2) + Math.pow((c2.y - p2.y), 2));
                return d2 - d1;
            });
            return res;
        }
        findSelectionableWatchers() {
            let res = new Array();
            let addSelectionable = (el) => {
                let watcher = Ui.SelectionableWatcher.getSelectionableWatcher(el);
                if (watcher)
                    res.push(watcher);
                else if (el instanceof Ui.Container)
                    el.children.forEach(el2 => addSelectionable(el2));
            };
            addSelectionable(this);
            return res;
        }
        findMatchSelectionable(element, filter) {
            let all = this.findSelectionableWatchers();
            if (all.length == 0)
                return undefined;
            let m = element.transformToElement(this);
            let p1 = (new Ui.Point(0, 0)).multiply(m);
            let p2 = (new Ui.Point(element.layoutWidth, element.layoutHeight)).multiply(m);
            let p = new Ui.Point(Math.min(p1.x, p2.x), Math.min(p1.y, p2.y));
            let s = { width: Math.abs(p1.x - p2.x), height: Math.abs(p1.y - p2.y) };
            let c = new Ui.Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
            let distance = 0;
            let found;
            all.forEach((w) => {
                let el = w.element;
                let m = el.transformToElement(this);
                let pe1 = (new Ui.Point(0, 0)).multiply(m);
                let pe2 = (new Ui.Point(el.layoutWidth, el.layoutHeight)).multiply(m);
                let pe = new Ui.Point(Math.min(pe1.x, pe2.x), Math.min(pe1.y, pe2.y));
                let se = { width: Math.abs(pe1.x - pe2.x), height: Math.abs(pe1.y - pe2.y) };
                let ce = new Ui.Point((pe1.x + pe2.x) / 2, (pe1.y + pe2.y) / 2);
                if (!filter(p, s, c, pe, se, ce))
                    return;
                let d = Math.sqrt(Math.pow((c.x - ce.x), 2) + Math.pow((c.y - ce.y), 2));
                if (!found || d < distance) {
                    distance = d;
                    found = w;
                }
            });
            return found;
        }
        findRightSelectionable(element) {
            return this.findMatchSelectionable(element, (p, s, c, pe, se, ce) => {
                if (pe.x < p.x + s.width)
                    return false;
                let voverlap = (p.y < pe.y + se.height) && (pe.y < p.y + s.height);
                if (!voverlap)
                    return false;
                return true;
            });
        }
        findLeftSelectionable(element) {
            return this.findMatchSelectionable(element, (p, s, c, pe, se, ce) => {
                if (pe.x + se.width > p.x)
                    return false;
                let voverlap = (p.y < pe.y + se.height) && (pe.y < p.y + s.height);
                if (!voverlap)
                    return false;
                return true;
            });
        }
        findBottomSelectionable(element) {
            return this.findMatchSelectionable(element, (p, s, c, pe, se, ce) => {
                if (p.y + s.height > pe.y)
                    return false;
                let hoverlap = (p.x < pe.x + se.width) && (pe.x < p.x + s.width);
                if (!hoverlap)
                    return false;
                return true;
            });
        }
        findTopSelectionable(element) {
            return this.findMatchSelectionable(element, (p, s, c, pe, se, ce) => {
                if (pe.y + se.height > p.y)
                    return false;
                let hoverlap = (p.x < pe.x + se.width) && (pe.x < p.x + s.width);
                if (!hoverlap)
                    return false;
                return true;
            });
        }
        onPointerDown(event) {
            if (this._pointerId != undefined)
                return;
            if (this.isDisabled || this.lock || event.pointerType == 'touch')
                return;
            if (event.pointerType == 'mouse' && event.button != 0)
                return;
            this._pointerId = event.pointerId;
            let initialPosition = new Ui.Point(event.clientX, event.clientY);
            this.drawing.setPointerCapture(event.pointerId);
            this.startPos = this.pointFromWindow(initialPosition);
            let onPointerMove = (e) => {
                if (e.pointerId != this._pointerId)
                    return;
                e.stopImmediatePropagation();
                let current = this.pointFromWindow(new Ui.Point(e.clientX, e.clientY));
                if (this.rectangle == undefined) {
                    this.rectangle = new Ui.Rectangle({
                        width: 0, height: 0,
                        fill: 'rgba(0,0,0,0.1)'
                    });
                    this.append(this.rectangle);
                }
                else {
                    let movePos = current;
                    this.rectangle.arrange(Math.min(movePos.x, this.startPos.x), Math.min(movePos.y, this.startPos.y), Math.abs(movePos.x - this.startPos.x), Math.abs(movePos.y - this.startPos.y));
                }
            };
            let onPointerCancel = (e) => {
                if (e.pointerId != this._pointerId)
                    return;
                this.drawing.removeEventListener('pointermove', onPointerMove);
                this.drawing.removeEventListener('pointercancel', onPointerCancel);
                this.drawing.removeEventListener('pointerup', onPointerUp);
                this.drawing.releasePointerCapture(event.pointerId);
                this._pointerId = undefined;
                if (this.rectangle != undefined) {
                    this.remove(this.rectangle);
                    this.rectangle = undefined;
                }
                e.stopImmediatePropagation();
            };
            let onPointerUp = (e) => {
                if (e.pointerId != this._pointerId)
                    return;
                this.drawing.removeEventListener('pointermove', onPointerMove);
                this.drawing.removeEventListener('pointercancel', onPointerCancel);
                this.drawing.removeEventListener('pointerup', onPointerUp);
                this.drawing.releasePointerCapture(event.pointerId);
                this._pointerId = undefined;
                if (this.rectangle != undefined) {
                    let current = this.pointFromWindow(new Ui.Point(e.clientX, e.clientY));
                    let res = this.findAreaElements(this.startPos, current);
                    let selection = this.getParentSelectionHandler();
                    this.lastSelection = new Date();
                    if (selection) {
                        if (e.shiftKey)
                            selection.append(res);
                        else if (e.ctrlKey) {
                            let watchers = selection.watchers;
                            let res2 = new Array();
                            watchers.forEach(w => {
                                if (res.indexOf(w) == -1)
                                    res2.push(w);
                            });
                            res.forEach(w => {
                                if (watchers.indexOf(w) == -1)
                                    res2.push(w);
                            });
                            selection.watchers = res2;
                        }
                        else
                            selection.watchers = res;
                    }
                    this.remove(this.rectangle);
                    this.rectangle = undefined;
                }
                e.stopImmediatePropagation();
            };
            this.drawing.addEventListener('pointermove', onPointerMove);
            this.drawing.addEventListener('pointercancel', onPointerCancel);
            this.drawing.addEventListener('pointerup', onPointerUp);
            event.stopImmediatePropagation();
        }
        onMouseDown(event) {
            if (this._pointerId != undefined)
                return;
            if (this.isDisabled || this.lock || event.button != 0)
                return;
            let initialPosition = new Ui.Point(event.clientX, event.clientY);
            this.startPos = this.pointFromWindow(initialPosition);
            let onMouseMove = (e) => {
                e.stopImmediatePropagation();
                let current = this.pointFromWindow(new Ui.Point(e.clientX, e.clientY));
                if (this.rectangle == undefined) {
                    this.rectangle = new Ui.Rectangle({
                        width: 0, height: 0,
                        fill: 'rgba(0,0,0,0.1)'
                    });
                    this.append(this.rectangle);
                }
                else {
                    let movePos = current;
                    this.rectangle.arrange(Math.min(movePos.x, this.startPos.x), Math.min(movePos.y, this.startPos.y), Math.abs(movePos.x - this.startPos.x), Math.abs(movePos.y - this.startPos.y));
                }
            };
            let onMouseUp = (e) => {
                window.removeEventListener('mousemove', onMouseMove, true);
                window.removeEventListener('mouseup', onMouseUp, true);
                if (this.rectangle != undefined) {
                    let current = this.pointFromWindow(new Ui.Point(e.clientX, e.clientY));
                    let res = this.findAreaElements(this.startPos, current);
                    let selection = this.getParentSelectionHandler();
                    this.lastSelection = new Date();
                    if (selection) {
                        if (e.shiftKey)
                            selection.append(res);
                        else if (e.ctrlKey) {
                            let watchers = selection.watchers;
                            let res2 = new Array();
                            watchers.forEach(w => {
                                if (res.indexOf(w) == -1)
                                    res2.push(w);
                            });
                            res.forEach(w => {
                                if (watchers.indexOf(w) == -1)
                                    res2.push(w);
                            });
                            selection.watchers = res2;
                        }
                        else
                            selection.watchers = res;
                    }
                    this.remove(this.rectangle);
                    this.rectangle = undefined;
                }
                e.stopImmediatePropagation();
            };
            window.addEventListener('mousemove', onMouseMove, true);
            window.addEventListener('mouseup', onMouseUp, true);
            event.stopImmediatePropagation();
        }
        onKeyDown(event) {
            if ((event.which >= 37 && event.which <= 40) || event.which == 65 || event.which == 16 || event.which == 46) {
                let selection = this.getParentSelectionHandler();
                if (!selection)
                    return;
                let ours = new Array();
                ours = selection.watchers.filter((w) => w.element.getIsChildOf(this));
                if (ours.length == 0)
                    return;
                let focusElement;
                let focusWatcher = ours.find(w => w.element.hasFocus);
                if (!focusWatcher)
                    focusWatcher = ours[0];
                focusElement = focusWatcher.element;
                let found;
                if (event.which == 37) {
                    found = this.findLeftSelectionable(focusElement);
                }
                else if (event.which == 39) {
                    found = this.findRightSelectionable(focusElement);
                }
                else if (event.which == 38) {
                    found = this.findTopSelectionable(focusElement);
                }
                else if (event.which == 40) {
                    found = this.findBottomSelectionable(focusElement);
                }
                if (found) {
                    event.stopPropagation();
                    event.preventDefault();
                    let shiftStart = this.shiftStart || focusWatcher;
                    if (event.shiftKey)
                        selection.watchers = selection.findRangeElements(shiftStart, found);
                    else
                        selection.watchers = [found];
                    if (found.element.focusable)
                        found.element.focus();
                }
                if (event.which == 65 && event.ctrlKey)
                    selection.watchers = this.findSelectionableWatchers();
                if (event.which == 16)
                    this.shiftStart = focusWatcher;
                if (event.which == 46)
                    selection.executeDeleteAction();
            }
        }
    }
    Ui.SelectionArea = SelectionArea;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Combo extends Ui.Button {
        constructor(init) {
            super(init);
            this._position = -1;
            this._placeHolder = '';
            this.allowNone = false;
            this.changed = new Core.Events();
            this.text = this._placeHolder;
            this.arrowbottom = new Ui.Icon({ icon: 'arrowbottom', width: 16, height: 16 });
            this.marker = new Ui.VBox({
                verticalAlign: 'center', marginRight: 5,
                content: [this.arrowbottom]
            });
            if (init) {
                if (init.placeHolder !== undefined)
                    this.placeHolder = init.placeHolder;
                if (init.field !== undefined)
                    this.field = init.field;
                if (init.iconField !== undefined)
                    this.iconField = init.iconField;
                if (init.data !== undefined)
                    this.data = init.data;
                if (init.position !== undefined)
                    this.position = init.position;
                if (init.current !== undefined)
                    this.current = init.current;
                if (init.search !== undefined)
                    this.search = init.search;
                if (init.allowNone !== undefined)
                    this.allowNone = init.allowNone;
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        get placeHolder() {
            return this._placeHolder;
        }
        set placeHolder(placeHolder) {
            this._placeHolder = placeHolder;
            if (this._position === -1)
                this.text = this._placeHolder;
        }
        get field() {
            return this._field;
        }
        set field(field) {
            this._field = field;
            if (this._data !== undefined)
                this.data = this._data;
        }
        set iconField(field) {
            this._iconField = field;
            if (this._data !== undefined)
                this.data = this._data;
        }
        set data(data) {
            let oldPosition = this.position;
            this._data = data;
            this._position = -1;
            this._current = undefined;
            this.text = this._placeHolder;
            this.position = oldPosition;
        }
        get data() {
            return this._data;
        }
        get position() {
            return this._position;
        }
        set position(position) {
            if (this.position == position)
                return;
            if (position === -1) {
                this._position = -1;
                this._current = undefined;
                this.text = this._placeHolder;
                this.icon = undefined;
                this.changed.fire({ target: this, value: this._current, position: this._position });
            }
            else if ((position >= 0) && (position < this._data.length)) {
                this._current = this._data[position];
                this._position = position;
                this.text = this._current[this._field];
                if (this._iconField)
                    this.icon = this._current[this._iconField];
                this.changed.fire({ target: this, value: this._current, position: this._position });
            }
        }
        get current() {
            return this._current;
        }
        get value() {
            return this._current;
        }
        set current(current) {
            if (current == undefined)
                this.position = -1;
            let position = -1;
            for (let i = 0; i < this._data.length; i++) {
                if (this._data[i] == current) {
                    position = i;
                    break;
                }
            }
            if (position != -1)
                this.position = position;
        }
        onItemPress(popup, item, position) {
            this.position = position;
        }
        onPress() {
            let popup = new Ui.ComboPopup({
                field: this._field,
                iconField: this._iconField
            }).assign({
                data: this._data,
                search: this.search, allowNone: this.allowNone
            });
            if (this._position !== -1)
                popup.position = this._position;
            popup.item.connect(e => this.onItemPress(e.target, e.item, e.position));
            popup.openElement(this, 'bottom');
        }
        updateColors() {
            super.updateColors();
            this.arrowbottom.fill = this.getForegroundColor();
        }
        onDisable() {
            super.onDisable();
            this.arrowbottom.opacity = 0.1;
        }
        onEnable() {
            super.onEnable();
            this.arrowbottom.opacity = 1;
        }
    }
    Combo.style = {
        textTransform: 'none',
        textAlign: 'left'
    };
    Ui.Combo = Combo;
    class ComboPopup extends Ui.MenuPopup {
        constructor(init) {
            super(init);
            this.list = new Ui.VBox();
            this._allowNone = false;
            this.searchField = new Ui.TextField();
            this.emptyField = new ComboItem();
            this.item = new Core.Events();
            this.autoClose = true;
            this.content = new Ui.VBox().assign({
                content: [
                    this.searchField.assign({
                        textHolder: 'Recherche', margin: 5,
                        onchanged: (e) => this.onSearchChange(e.target, e.value)
                    }),
                    this.emptyField.assign({
                        text: '',
                        onpressed: () => {
                            this.item.fire({ target: this, item: this.emptyField, position: -1 });
                            this.close();
                        }
                    }),
                    this.list
                ]
            });
            this.searchField.hide(true);
            this.emptyField.hide(true);
            if (init) {
                if (init.search !== undefined)
                    this.search = init.search;
                if (init.allowNone !== undefined)
                    this.allowNone = init.allowNone;
                if (init.field !== undefined)
                    this.field = init.field;
                if (init.iconField !== undefined)
                    this.iconField = init.iconField;
                if (init.data !== undefined)
                    this.data = init.data;
                if (init.position !== undefined)
                    this.position = init.position;
            }
        }
        onSearchChange(field, value) {
            if (value == '' && this.allowNone)
                this.emptyField.show();
            else
                this.emptyField.hide(true);
            this.list.children.forEach((element) => {
                var _a;
                let item = element;
                if (value == '')
                    item.show();
                else {
                    let text = Core.Util.toNoDiacritics((_a = item.text) !== null && _a !== void 0 ? _a : '').toLocaleLowerCase();
                    let search = Core.Util.toNoDiacritics(value).toLowerCase().split(' ');
                    if (search.length == 0)
                        item.show();
                    else {
                        let match = true;
                        for (let i = 0; match && (i < search.length); i++) {
                            let word = search[i];
                            match = (text.indexOf(word) != -1);
                        }
                        if (match)
                            item.show();
                        else
                            item.hide(true);
                    }
                }
            });
        }
        set search(value) {
            if (value)
                this.searchField.show();
            else
                this.searchField.hide(true);
        }
        get allowNone() {
            return this._allowNone;
        }
        set allowNone(value) {
            this._allowNone = value;
            if (value)
                this.emptyField.show();
            else
                this.emptyField.hide(true);
        }
        get field() {
            return this._field;
        }
        set field(field) {
            this._field = field;
            if (this._data !== undefined)
                this.data = this._data;
        }
        get iconField() {
            return this._iconField;
        }
        set iconField(field) {
            this._iconField = field;
            if (this._data !== undefined)
                this.data = this._data;
        }
        set data(data) {
            this._data = data;
            if (this._field === undefined)
                return;
            for (let i = 0; i < data.length; i++) {
                let item = new ComboItem({
                    text: data[i][this._field],
                    onpressed: () => this.onItemPress(item)
                });
                if (this._iconField)
                    item.icon = data[i][this._iconField];
                this.list.append(item);
            }
        }
        set position(position) {
            this.list.children[position].isActive = true;
        }
        onItemPress(item) {
            let position = -1;
            for (let i = 0; i < this.list.children.length; i++) {
                if (this.list.children[i] == item) {
                    position = i;
                    break;
                }
            }
            this.item.fire({ target: this, item: item, position: position });
            this.close();
        }
    }
    Ui.ComboPopup = ComboPopup;
    class ComboItem extends Ui.Button {
    }
    ComboItem.style = {
        borderWidth: 0,
        textTransform: 'none',
        textAlign: 'left'
    };
    Ui.ComboItem = ComboItem;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class ListViewHeader extends Ui.Pressable {
        constructor(headerDef, listview) {
            super();
            this.headerDef = headerDef;
            this.listview = listview;
            this.background = new Ui.Rectangle();
            this.sortBox = new Ui.HBox();
            this.sortOrderLabel = new Ui.Label();
            this.sortArrow = new Ui.Icon();
            this._sortInvert = false;
            if (headerDef.title instanceof Ui.Element)
                this.ui = headerDef.title;
            else
                this.ui = new Ui.Label().assign({ text: headerDef.title, margin: 4, fontWeight: 'bold' });
            this.ui.resizable = true;
            this.content = [
                this.sortBox.assign({
                    isVisible: false,
                    horizontalAlign: 'right', verticalAlign: 'center',
                    content: [
                        this.sortOrderLabel.assign({ fontSize: 10, fontWeight: 'bold', text: '1' }),
                        this.sortArrow.assign({ icon: 'sortarrow', width: 16, height: 16 })
                    ]
                }),
                new Ui.VBox().assign({
                    content: [
                        new Ui.HBox().assign({
                            resizable: true,
                            content: [
                                this.ui,
                                new ListViewColBar(this, this.headerDef)
                            ]
                        }),
                        this.background.assign({ height: 4 })
                    ]
                })
            ];
            this.downed.connect(() => this.onListViewHeaderDown());
            this.upped.connect(() => this.onListViewHeaderUp());
        }
        set sort(value) {
            this._sortOrder = value.order;
            this._sortInvert = value.invert;
            this.sortBox.isVisible = (value.order != undefined);
            if (value.order == undefined)
                this.sortBox.hide();
            else {
                this.sortBox.show();
                this.sortOrderLabel.text = (value.order > 1) ? value.order.toFixed().toString() : '';
                if (value.invert)
                    this.sortArrow.transform = Ui.Matrix.createRotate(180);
                else
                    this.sortArrow.transform = undefined;
            }
        }
        get sort() {
            return { order: this._sortOrder, invert: this._sortInvert };
        }
        getColor() {
            return Ui.Color.create(this.getStyleProperty('color'));
        }
        getColorDown() {
            let yuv = Ui.Color.create(this.getStyleProperty('color')).getYuv();
            return Ui.Color.createFromYuv(yuv.y + 0.40, yuv.u, yuv.v);
        }
        onListViewHeaderDown() {
            this.background.fill = this.getColorDown();
        }
        onListViewHeaderUp() {
            this.background.fill = this.getColor();
        }
        onStyleChange() {
            this.background.fill = this.getStyleProperty('color');
        }
    }
    ListViewHeader.style = {
        color: '#444444'
    };
    Ui.ListViewHeader = ListViewHeader;
    class ListViewHeaderSortPopup extends Ui.Popup {
        constructor(headers) {
            super();
            this.headers = headers;
            this._changedLock = false;
            this.vbox = new Ui.VBox();
            this.fields = new Array();
            this.changed = new Core.Events();
            this.content = this.vbox.assign({
                padding: 10, spacing: 10,
                content: [
                    new Ui.Label().assign({ text: 'Ordre de tri', fontWeight: 'bold', horizontalAlign: 'left' })
                ]
            });
            for (let i = 0; i < 3; i++) {
                let sortBox = new Ui.HBox();
                if (i > 0)
                    sortBox.disable();
                let sortField = new Ui.Combo();
                let sortDir = new Ui.Combo();
                let field = { box: sortBox, field: sortField, dir: sortDir, position: i };
                sortBox.assign({
                    spacing: 10,
                    content: [
                        sortField.assign({
                            field: 'title', allowNone: true,
                            data: this.headers.filter(h => h.key != undefined),
                            onchanged: () => this.onChanged(field)
                        }),
                        sortDir.assign({
                            field: 'name',
                            data: [
                                { name: 'Asc', value: false },
                                { name: 'Desc', value: true }
                            ],
                            onchanged: () => this.onChanged(field)
                        })
                    ]
                });
                this.vbox.append(sortBox);
                this.fields.push(field);
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        onChanged(field) {
            if (this._changedLock)
                return;
            this._changedLock = true;
            try {
                this.updateFields();
            }
            catch (e) { }
            this._changedLock = false;
            this.changed.fire({ target: this, sortOrder: this.sortOrder });
        }
        updateFields() {
            let needClear = false;
            for (let i = 0; i < this.fields.length; i++) {
                if (needClear) {
                    this.fields[i].box.disable();
                    this.fields[i].dir.position = -1;
                    this.fields[i].field.position = -1;
                }
                else {
                    this.fields[i].box.enable();
                    if (this.fields[i].field.position == -1) {
                        this.fields[i].dir.position = -1;
                        needClear = true;
                    }
                    else {
                        if (this.fields[i].dir.position == -1)
                            this.fields[i].dir.position = 0;
                    }
                }
            }
        }
        set sortOrder(value) {
            this._changedLock = true;
            for (let i = 0; i < value.length && i < this.fields.length; i++) {
                let field = this.fields[i];
                field.field.position = field.field.data.findIndex(f => f.key == value[i].key);
                field.dir.position = value[i].invert ? 1 : 0;
            }
            this.updateFields();
            this._changedLock = false;
        }
        get sortOrder() {
            let order = new Array();
            for (let i = 0; i < this.fields.length; i++) {
                let item = this.fields[i];
                if (item.field.value)
                    order.push({ key: item.field.value.key, invert: item.dir.value ? item.dir.value.value : false });
            }
            return order;
        }
    }
    class ListViewHeadersBar extends Ui.Container {
        constructor(init, listview) {
            super();
            this.listview = listview;
            this.allowMultiSort = true;
            this._sortOrder = new Array();
            this.rowsHeight = 0;
            this.headersHeight = 0;
            this.sortchanged = new Core.Events();
            this.headers = init.headers;
            this.uis = [];
            for (let i = 0; i < init.headers.length; i++) {
                let headerDef = init.headers[i];
                let headerUi = new ListViewHeader(headerDef, listview).assign({
                    width: headerDef.width,
                    onpressed: e => {
                        if (headerDef.key !== undefined)
                            this.sortBy(headerDef.key, headerDef.key == this.sortColKey ? !headerUi.sort.invert : false);
                        this.sortchanged.fire({ target: this, sortOrder: this.sortOrder });
                    }
                });
                this.uis.push(headerUi);
                this.appendChild(headerUi);
            }
            new Ui.ContextMenuWatcher({
                element: this,
                press: (e) => {
                    var _a, _b;
                    if (this.allowMultiSort)
                        new ListViewHeaderSortPopup(this.headers).assign({
                            sortOrder: this._sortOrder,
                            onchanged: e => {
                                this.sortOrder = e.sortOrder;
                                this.sortchanged.fire({ target: this, sortOrder: this.sortOrder });
                            }
                        }).openAt((_a = e.x) !== null && _a !== void 0 ? _a : 0, (_b = e.y) !== null && _b !== void 0 ? _b : 0);
                }
            });
        }
        set onsortchanged(value) { this.sortchanged.connect(value); }
        get sortColKey() {
            return (this._sortOrder.length > 0) ? this._sortOrder[0].key : undefined;
        }
        get sortInvert() {
            return (this._sortOrder.length > 0) ? this._sortOrder[0].invert : false;
        }
        sortBy(key, invert) {
            this.sortOrder = [{ key: key, invert: invert }];
        }
        get sortOrder() {
            return this._sortOrder;
        }
        set sortOrder(value) {
            this._sortOrder = value;
            for (let ui of this.uis) {
                var pos = this._sortOrder.findIndex(s => s.key == ui.headerDef.key);
                if (pos == -1)
                    ui.sort = { order: undefined, invert: this.sortInvert };
                else
                    ui.sort = { order: pos + 1, invert: this._sortOrder[pos].invert };
            }
        }
        measureCore(width, height) {
            this.rowsHeight = 0;
            this.headersHeight = 0;
            let minHeight = 0;
            for (let col = 0; col < this.uis.length; col++) {
                let size = this.uis[col].measure(0, 0);
                if (size.height > minHeight)
                    minHeight = size.height;
            }
            this.headersHeight = minHeight;
            let minWidth = 0;
            for (let col = 0; col < this.uis.length; col++)
                minWidth += this.uis[col].measureWidth;
            return { width: minWidth, height: this.headersHeight };
        }
        arrangeCore(width, height) {
            let x = 0;
            let colWidth;
            let col;
            let availableWidth = width;
            for (col = 0; col < this.headers.length; col++) {
                let ui = this.uis[col];
                colWidth = ui.measureWidth;
                if (col == this.headers.length - 1)
                    colWidth = Math.max(colWidth, availableWidth);
                ui.arrange(x, 0, colWidth, this.headersHeight);
                x += colWidth;
                availableWidth -= colWidth;
            }
        }
    }
    Ui.ListViewHeadersBar = ListViewHeadersBar;
    class ListViewRow extends Ui.Container {
        constructor(init) {
            super();
            this.selected = new Core.Events();
            this.unselected = new Core.Events();
            this.drawing.style.boxSizing = 'border-box';
            this.drawing.style.borderBottomStyle = 'solid';
            this.drawing.style.borderBottomWidth = '1px';
            this.listView = init.listView;
            this.headers = this.listView.headers;
            this._data = init.data;
            if (typeof (this.listView.selectionActions) == 'function')
                this.selectionActions = this.listView.selectionActions(this._data);
            else
                this.selectionActions = this.listView.selectionActions;
            if (init.height)
                this.height = init.height;
            this.cells = [];
            for (let col = 0; col < this.headers.length; col++) {
                let key = this.headers[col].key;
                let cell;
                if (this.headers[col].ui !== undefined)
                    cell = new this.headers[col].ui();
                else
                    cell = new ListViewCellString();
                cell.setKey(key);
                cell.setRow(this);
                cell.setValue((key != undefined) ? this.getValueFrom(key, this._data) : this._data);
                this.cells.push(cell);
                this.appendChild(cell);
            }
            this.selectionWatcher = new Ui.SelectionableWatcher({
                element: this,
                selectionActions: this.selectionActions,
                onselected: () => {
                    this.selected.fire({ target: this });
                    this.onStyleChange();
                    if (this.listView)
                        this.listView.onRowSelectionChanged();
                },
                onunselected: () => {
                    this.unselected.fire({ target: this });
                    this.onStyleChange();
                    if (this.listView)
                        this.listView.onRowSelectionChanged();
                }
            });
        }
        set onselected(value) { this.selected.connect(value); }
        set onunselected(value) { this.unselected.connect(value); }
        getValueFrom(key, data) {
            if (key.indexOf('.') == -1 && key.indexOf('[') == -1)
                return data[key];
            let pathIndex = key.replace(/]/g, "").replace(/\[/g, ".");
            let result = pathIndex.split('.').reduce((o, i) => o != undefined && i in o ? o[i] : undefined, data);
            return result != undefined ? result : data;
        }
        get data() {
            return this._data;
        }
        set data(data) {
            this._data = data;
            for (let col = 0; col < this.headers.length; col++) {
                let key = this.headers[col].key;
                let cell = this.cells[col];
                cell.setValue((key != undefined) ? this.getValueFrom(key, this._data) : this._data);
            }
        }
        get isSelected() {
            return this.selectionWatcher.isSelected;
        }
        set isSelected(value) {
            this.selectionWatcher.isSelected = value;
        }
        measureCore(width, height) {
            let minHeight = 0;
            let minWidth = 0;
            for (let col = 0; col < this.headers.length; col++) {
                let child = this.cells[col];
                let size = child.measure(0, 0);
                if (size.height > minHeight)
                    minHeight = size.height;
                minWidth += this.listView.headersBar.uis[col].measureWidth;
            }
            return { width: minWidth, height: minHeight };
        }
        arrangeCore(width, height) {
            let x = 0;
            for (let col = 0; col < this.headers.length; col++) {
                let cell = this.cells[col];
                let colWidth = this.listView.headersBar.uis[col].layoutWidth;
                cell.arrange(x, 0, colWidth, height);
                x += colWidth;
            }
        }
        onStyleChange() {
            if (this.selectionWatcher.isSelected)
                this.drawing.style.background = Ui.Color.create(this.getStyleProperty('selectColor')).getCssRgba();
            else
                this.drawing.style.background = Ui.Color.create(this.getStyleProperty('color')).getCssRgba();
            this.drawing.style.borderColor = Ui.Color.create(this.getStyleProperty('sepColor')).getCssRgba();
        }
    }
    ListViewRow.style = {
        sepColor: 'rgba(0,0,0,0.1)',
        color: new Ui.Color(0.99, 0.99, 0.99, 0.1),
        selectColor: new Ui.Color(0.88, 0.88, 0.88)
    };
    Ui.ListViewRow = ListViewRow;
    class ListViewRowOdd extends ListViewRow {
        constructor(init) {
            super(init);
        }
    }
    ListViewRowOdd.style = {
        color: new Ui.Color(0.5, 0.5, 0.5, 0.05),
        selectColor: 'rgba(8,160,229,0.6)'
    };
    Ui.ListViewRowOdd = ListViewRowOdd;
    class ListViewRowEven extends ListViewRow {
        constructor(init) {
            super(init);
        }
    }
    ListViewRowEven.style = {
        color: new Ui.Color(0.5, 0.5, 0.5, 0.1),
        selectColor: 'rgba(8,160,229,0.8)'
    };
    Ui.ListViewRowEven = ListViewRowEven;
    class ListViewScrollLoader extends Ui.ScrollLoader {
        constructor(listView, data) {
            super();
            this.listView = listView;
            this.data = data;
        }
        signalChange() {
            this.changed.fire({ target: this });
        }
        getMin() {
            return 0;
        }
        getMax() {
            return this.data.length - 1;
        }
        getElementAt(position) {
            return this.listView.getElementAt(position);
        }
    }
    Ui.ListViewScrollLoader = ListViewScrollLoader;
    class ListView extends Ui.VBox {
        constructor(init) {
            super(init);
            this.rowsHeight = 0;
            this.headersHeight = 0;
            this.headersVisible = true;
            this._scrolled = true;
            this._scrollVertical = true;
            this._scrollHorizontal = true;
            this._selectionChangedLock = false;
            this.selectionchanged = new Core.Events();
            this.selected = new Core.Events();
            this.unselected = new Core.Events();
            this.activated = new Core.Events();
            this.sortchanged = new Core.Events();
            this.datachanged = new Core.Events();
            if (init && init.headers != undefined)
                this.headers = init.headers;
            else
                this.headers = [{ width: 100, type: 'string', title: 'Title', key: 'default' }];
            if (init && init.headerStoreKey !== undefined)
                this.headerStoreKey = init.headerStoreKey;
            this.selectionActions = {
                edit: {
                    "default": true,
                    text: 'Edit', icon: 'edit', multiple: false,
                    callback: (s) => this.onSelectionEdit(s)
                }
            };
            this.headersScroll = new Ui.ScrollingArea({
                scrollVertical: false, scrollHorizontal: true
            });
            this.headersScroll.setScrollbarHorizontal(new Ui.Movable());
            this.append(this.headersScroll);
            this.headersBar = new ListViewHeadersBar({ headers: this.headers }, this).assign({
                onsortchanged: (e) => this.sortOrder = e.sortOrder
            });
            this.headersScroll.content = this.headersBar;
            this._data = [];
            this.vboxScroll = new Ui.ScrollingArea();
            this.append(this.vboxScroll, true);
            this.vbox = new Ui.VBox();
            this.vboxScroll.content = this.vbox;
            let lastContentScroll = Date.now();
            let lastHeaderScroll = Date.now();
            this.vboxScroll.scrolled.connect((e) => {
                if (Date.now() - lastContentScroll > 150) {
                    lastHeaderScroll = Date.now();
                    this.headersScroll.setOffset(e.offsetX, undefined, true, true);
                }
            });
            this.headersScroll.scrolled.connect((e) => {
                if (Date.now() - lastHeaderScroll > 150) {
                    lastContentScroll = Date.now();
                    this.vboxScroll.setOffset(e.offsetX, undefined, true, true);
                }
            });
            if (init) {
                if (init.scrolled !== undefined)
                    this.scrolled = init.scrolled;
                if (init.scrollVertical !== undefined)
                    this.scrollVertical = init.scrollVertical;
                if (init.scrollHorizontal !== undefined)
                    this.scrollHorizontal = init.scrollHorizontal;
                if (init.selectionActions !== undefined)
                    this.selectionActions = init.selectionActions;
                if (init.onselected)
                    this.selected.connect(init.onselected);
                if (init.onunselected)
                    this.unselected.connect(init.onunselected);
                if (init.onactivated)
                    this.activated.connect(init.onactivated);
                if (init.onsortchanged)
                    this.sortchanged.connect(init.onsortchanged);
                if (init.onselectionchanged)
                    this.selectionchanged.connect(init.onselectionchanged);
                if (init.allowMultiSort != undefined)
                    this.allowMultiSort = init.allowMultiSort;
            }
        }
        set onselectionchanged(value) { this.selectionchanged.connect(value); }
        set onselected(value) { this.selected.connect(value); }
        set onunselected(value) { this.unselected.connect(value); }
        set onactivated(value) { this.activated.connect(value); }
        set onsortchanged(value) { this.sortchanged.connect(value); }
        set ondatachanged(value) { this.datachanged.connect(value); }
        get headerStoreKey() {
            return this._headerStoreKey;
        }
        set headerStoreKey(key) {
            if (this._headerStoreKey != key) {
                this._headerStoreKey = key;
                this.loadStoredWidth();
            }
        }
        loadStoredWidth() {
            if (localStorage && this.headerStoreKey) {
                for (let header of this.headers) {
                    if (!header.key)
                        continue;
                    let value = localStorage.getItem(`${this.headerStoreKey}.header.${header.key}`);
                    if (value)
                        header.width = parseInt(value);
                }
            }
        }
        set scrolled(scrolled) {
            this.scrollVertical = scrolled;
            this.scrollHorizontal = scrolled;
        }
        set scrollVertical(value) {
            if (this._scrollVertical !== value) {
                this._scrollVertical = value;
                this.vboxScroll.scrollVertical = value;
            }
        }
        set scrollHorizontal(value) {
            if (this._scrollHorizontal !== value) {
                this.headersScroll.scrollHorizontal = value;
                this._scrollHorizontal = value;
                this.vboxScroll.scrollHorizontal = value;
            }
        }
        get allowMultiSort() {
            return this.headersBar.allowMultiSort;
        }
        set allowMultiSort(value) {
            this.headersBar.allowMultiSort = value;
        }
        showHeaders() {
            if (!this.headersVisible) {
                this.headersVisible = true;
                this.headersBar.show();
            }
        }
        hideHeaders() {
            if (this.headersVisible) {
                this.headersVisible = false;
                this.headersBar.hide(true);
            }
        }
        getSelectionActions() {
            return this.selectionActions;
        }
        setSelectionActions(value) {
            this.selectionActions = value;
        }
        getElementAt(position) {
            if ((position % 2) === 0)
                return new ListViewRowOdd({
                    listView: this, data: this._data[position]
                });
            else
                return new ListViewRowEven({
                    listView: this, data: this._data[position]
                });
        }
        appendData(data) {
            this._data.push(data);
            this.sortData();
            this.vbox.append(this.getElementAt(this._data.length - 1));
            this.datachanged.fire({ target: this });
        }
        updateData() {
            this.sortData();
            this.vbox.clear();
            for (let i = 0; i < this._data.length; i++) {
                this.vbox.append(this.getElementAt(i));
            }
            this.datachanged.fire({ target: this });
        }
        removeData(data) {
            let row = this.findDataRow(data);
            if (row != -1)
                this.removeDataAt(row);
        }
        removeDataAt(position) {
            if (position < this._data.length) {
                this._data.splice(position, 1);
                this.vbox.clear();
                for (let i = 0; i < this._data.length; i++)
                    this.vbox.append(this.getElementAt(i));
            }
            this.datachanged.fire({ target: this });
        }
        clearData() {
            this._data = [];
            this.vbox.clear();
            this.datachanged.fire({ target: this });
        }
        get data() {
            return this._data;
        }
        set data(data) {
            this._data = data;
            this.sortData();
            this.vbox.clear();
            for (let i = 0; i < this._data.length; i++) {
                this.vbox.append(this.getElementAt(i));
            }
            this.datachanged.fire({ target: this });
        }
        sortData() {
            let sortOrder = this.sortOrder;
            if (this.sortFunc)
                return this.sortFunc(this._data, sortOrder);
            let cmp = function (a, b) {
                return (a < b) ? -1 : (a > b) ? 1 : 0;
            };
            this._data.sort(function (a, b) {
                let res = 0;
                for (let i = 0; i < sortOrder.length && res == 0; i++) {
                    res = cmp(a[sortOrder[i].key], b[sortOrder[i].key]);
                    res = sortOrder[i].invert ? -res : res;
                }
                return res;
            });
        }
        sortBy(key, invert) {
            this.sortOrder = [{ key: key, invert: invert }];
        }
        get sortOrder() {
            return this.headersBar.sortOrder;
        }
        set sortOrder(value) {
            this.headersBar.sortOrder = value;
            this.sortData();
            this.vbox.clear();
            for (let i = 0; i < this._data.length; i++) {
                this.vbox.append(this.getElementAt(i));
            }
            this.sortchanged.fire({ target: this, sortOrder: this.sortOrder });
        }
        get sortColKey() {
            return this.headersBar.sortColKey;
        }
        get sortInvert() {
            return this.headersBar.sortInvert;
        }
        findDataRow(data) {
            for (let row = 0; row < this._data.length; row++) {
                if (data == this._data[row])
                    return row;
            }
            return -1;
        }
        onSelectionEdit(selection) {
            let data = selection.elements[0].data;
            this.activated.fire({ target: this, position: this.findDataRow(data), value: data });
        }
        onChildInvalidateArrange(child) {
            super.onChildInvalidateArrange(child);
            if (child === this.headersScroll) {
                for (let item of this.vbox.children)
                    item.invalidateMeasure();
            }
        }
        onRowSelectionChanged() {
            if (!this._selectionChangedLock)
                this.selectionchanged.fire({ target: this });
        }
        get rows() {
            return this.vbox.children;
        }
        get selectedRows() {
            return this.rows.filter((value) => value.isSelected);
        }
        selectAll() {
            let rows = this.rows;
            if (rows.length > 0) {
                let selection = Ui.Selectionable.getParentSelectionHandler(this);
                if (selection) {
                    this._selectionChangedLock = true;
                    selection.elements = rows;
                    this._selectionChangedLock = false;
                    this.onRowSelectionChanged();
                }
            }
        }
        unselectAll() {
            let rows = this.selectedRows;
            if (rows.length > 0) {
                let selection = Ui.Selectionable.getParentSelectionHandler(this);
                if (selection) {
                    this._selectionChangedLock = true;
                    selection.elements = selection.elements.filter((v) => !(v instanceof ListViewRow) || (rows.indexOf(v) == -1));
                    this._selectionChangedLock = false;
                    this.onRowSelectionChanged();
                }
            }
        }
    }
    Ui.ListView = ListView;
    class ListViewCell extends Ui.LBox {
        constructor() {
            super();
            this.clipToBounds = true;
            this.ui = this.generateUi();
            this.append(this.ui);
        }
        getKey() {
            return this.key;
        }
        setKey(key) {
            this.key = key;
        }
        setRow(row) {
            this.row = row;
        }
        getValue() {
            return this.value;
        }
        setValue(value) {
            this.value = value;
            this.onValueChange(value);
        }
        generateUi() {
            return new Ui.Label({ margin: 8, horizontalAlign: 'left' });
        }
        onValueChange(value) {
            this.ui.text = value;
        }
        onStyleChange() {
            let spacing = this.getStyleProperty('spacing');
            this.ui.margin = spacing + 2;
        }
    }
    ListViewCell.style = {
        spacing: 5
    };
    Ui.ListViewCell = ListViewCell;
    class ListViewCellString extends ListViewCell {
        constructor() {
            super();
        }
        generateUi() {
            return new Ui.Label({ margin: 8, horizontalAlign: 'left' });
        }
        onValueChange(value) {
            this.ui.text = value === undefined ? '' : (value === null ? 'null' : value.toString());
        }
    }
    Ui.ListViewCellString = ListViewCellString;
    class ListViewCellNumber extends ListViewCell {
        constructor() {
            super();
        }
        generateUi() {
            return new Ui.Label({ margin: 8, horizontalAlign: 'right' });
        }
        onValueChange(value) {
            this.ui.text = value.toString();
        }
    }
    Ui.ListViewCellNumber = ListViewCellNumber;
    class ListViewColBar extends Ui.Container {
        constructor(header, headerDef) {
            super();
            this.gripR1 = new Ui.Rectangle();
            this.gripR2 = new Ui.Rectangle();
            this.header = header;
            this.headerDef = headerDef;
            this.grip = new Ui.Movable().assign({
                moveVertical: false,
                content: new Ui.LBox().assign({
                    content: [
                        this.gripR1.assign({ width: 1, opacity: 0.2, fill: 'black', marginLeft: 7, marginRight: 8 + 2, marginTop: 6, marginBottom: 6 }),
                        this.gripR2.assign({ width: 1, opacity: 0.2, fill: 'black', marginLeft: 12, marginRight: 3 + 2, marginTop: 6, marginBottom: 6 })
                    ]
                }),
                onmoved: () => this.onMove(),
                onupped: () => this.onUp()
            });
            this.appendChild(this.grip);
            if (headerDef.resizable === false)
                this.grip.hide(true);
            this.separator = new Ui.Rectangle().assign({ width: 1, fill: 'black', opacity: 0.3 });
            this.appendChild(this.separator);
        }
        setHeader(header) {
            this.header = header;
        }
        onMove() {
            this.separator.transform = Ui.Matrix.createTranslate(this.grip.positionX, 0);
        }
        onUp() {
            let delta = this.grip.positionX;
            this.header.width = Math.max(this.measureWidth, this.header.measureWidth + delta);
            if (this.header.listview.headerStoreKey && localStorage && this.headerDef.key) {
                localStorage.setItem(`${this.header.listview.headerStoreKey}.header.${this.headerDef.key}`, this.header.width.toString());
            }
            this.invalidateArrange();
        }
        measureCore(width, height) {
            let size = this.grip.measure(width, height);
            this.separator.measure(width, height);
            return { width: Math.max(size.width, 1), height: 0 };
        }
        arrangeCore(width, height) {
            this.grip.setPosition(0, 0);
            this.separator.transform = Ui.Matrix.createTranslate(0, 0);
            this.grip.arrange(0, 0, width, height);
            this.separator.arrange(width - 1, 0, 1, height);
        }
        onDisable() {
            super.onDisable();
            if (this.headerDef.resizable !== false)
                this.grip.hide();
        }
        onEnable() {
            super.onEnable();
            if (this.headerDef.resizable !== false)
                this.grip.show();
        }
        onStyleChange() {
            super.onStyleChange();
            let color = this.getStyleProperty('color');
            this.gripR1.fill = color;
            this.gripR2.fill = color;
            this.separator.fill = color;
        }
    }
    Ui.ListViewColBar = ListViewColBar;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Uploadable extends Ui.Pressable {
        constructor(init) {
            super(init);
            this.file = new Core.Events();
            this.drawing.style.cursor = 'pointer';
            this.focusable = true;
            this.role = 'button';
            this.input = new UploadableFileWrapper();
            this.append(this.input);
            this.input.file.connect((e) => this.onFile(e.target, e.file));
        }
        set onfile(value) { this.file.connect(value); }
        setDirectoryMode(active) {
            this.input.setDirectoryMode(active);
        }
        set directoryMode(active) {
            this.input.directoryMode = active;
        }
        set multiple(active) {
            this.input.multiple = active;
        }
        set accept(value) {
            this.input.accept = value;
        }
        set capture(value) {
            this.input.capture = value;
        }
        onFile(fileWrapper, file) {
            this.file.fire({ target: this, file: file });
        }
        onPress() {
            if (this.input instanceof UploadableFileWrapper)
                this.input.select();
        }
        set content(content) {
            if (this._content !== content) {
                if (this._content !== undefined)
                    this.remove(this._content);
                if (content !== undefined)
                    this.append(content);
                this._content = content;
            }
        }
    }
    Ui.Uploadable = Uploadable;
    class UploadableFileWrapper extends Ui.Element {
        constructor() {
            super();
            this._directoryMode = false;
            this._multiple = false;
            this.file = new Core.Events();
            this.onChange = (event) => {
                event.preventDefault();
                event.stopPropagation();
                for (let i = 0; this.inputDrawing && this.inputDrawing.files && i < this.inputDrawing.files.length; i++)
                    this.file.fire({ target: this, file: this.inputDrawing.files[i] });
            };
            this.opacity = 0;
            this.clipToBounds = true;
        }
        select() {
            this.inputDrawing.click();
        }
        set multiple(active) {
            this._multiple = active;
            if (this.inputDrawing !== undefined) {
                if (active)
                    this.inputDrawing.setAttribute('multiple', '');
                else
                    this.inputDrawing.removeAttribute('multiple');
            }
        }
        setDirectoryMode(active) {
            this.directoryMode = active;
        }
        set directoryMode(active) {
            this._directoryMode = active;
            if (this.inputDrawing !== undefined) {
                if (this._directoryMode)
                    this.inputDrawing.setAttribute('webkitdirectory', '');
                else
                    this.inputDrawing.removeAttribute('webkitdirectory');
            }
        }
        set accept(value) {
            this._accept = value;
            if (this.inputDrawing !== undefined) {
                if (value)
                    this.inputDrawing.setAttribute('accept', value);
                else
                    this.inputDrawing.removeAttribute('accept');
            }
        }
        set capture(value) {
            this._capture = value;
            if (this.inputDrawing !== undefined) {
                if (value)
                    this.inputDrawing.setAttribute('capture', value);
                else
                    this.inputDrawing.removeAttribute('capture');
            }
        }
        createInput() {
            this.formDrawing = document.createElement('form');
            this.formDrawing.addEventListener('click', (e) => e.stopPropagation());
            this.formDrawing.addEventListener('touchstart', (e) => e.stopPropagation());
            this.formDrawing.method = 'POST';
            this.formDrawing.enctype = 'multipart/form-data';
            this.formDrawing.encoding = 'multipart/form-data';
            this.formDrawing.style.position = 'absolute';
            this.inputDrawing = document.createElement('input');
            this.inputDrawing.type = 'file';
            this.inputDrawing.setAttribute('name', 'file');
            if (this._directoryMode)
                this.inputDrawing.setAttribute('webkitdirectory', '');
            if (this._multiple)
                this.inputDrawing.setAttribute('multiple', '');
            if (this._accept)
                this.inputDrawing.setAttribute('accept', this._accept);
            if (this._capture)
                this.inputDrawing.setAttribute('capture', this._capture);
            this.inputDrawing.style.position = 'absolute';
            this.inputDrawing.tabIndex = -1;
            this.inputDrawing.addEventListener('change', this.onChange);
            this.formDrawing.appendChild(this.inputDrawing);
            while (this.drawing.childNodes.length > 0)
                this.drawing.removeChild(this.drawing.childNodes[0]);
            this.drawing.appendChild(this.formDrawing);
            this.arrange(this.layoutX, this.layoutY, this.layoutWidth, this.layoutHeight);
        }
        onLoad() {
            super.onLoad();
            this.createInput();
        }
        onUnload() {
            this.inputDrawing.removeEventListener('change', this.onChange);
            if (this.iframeDrawing !== undefined)
                document.body.removeChild(this.iframeDrawing);
            super.onUnload();
        }
        arrangeCore(w, h) {
            super.arrangeCore(w, h);
            if (this.formDrawing !== undefined) {
                this.formDrawing.style.top = '0px';
                this.formDrawing.style.left = '0px';
                this.formDrawing.style.width = Math.round(w) + 'px';
                this.formDrawing.style.height = Math.round(h) + 'px';
            }
            if (this.inputDrawing !== undefined) {
                this.inputDrawing.style.top = '0px';
                this.inputDrawing.style.left = '0px';
                this.inputDrawing.style.width = Math.round(w) + 'px';
                this.inputDrawing.style.height = Math.round(h) + 'px';
            }
        }
    }
    Ui.UploadableFileWrapper = UploadableFileWrapper;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class UploadButton extends Ui.Button {
        constructor(init) {
            super(init);
            this.filechanged = new Core.Events();
            this.input = new Ui.UploadableFileWrapper();
            this.prepend(this.input);
            this.input.file.connect((e) => this.onFile(e.target, e.file));
            this.pressed.connect(() => this.onUploadButtonPress());
            new Ui.DropableWatcher({
                element: this,
                ondroppedfile: (w, f) => {
                    if (this.testAccept(f))
                        this.onFile(undefined, f);
                    else
                        Ui.Toast.sendError('Format de fichier non accepté');
                    return true;
                },
                types: [{ type: 'files', effects: 'copy' }]
            });
            if (init) {
                if (init.directoryMode !== undefined)
                    this.directoryMode = init.directoryMode;
                if (init.onfilechanged)
                    this.filechanged.connect(init.onfilechanged);
                if (init.multiple)
                    this.multiple = init.multiple;
                if (init.accept)
                    this.accept = init.accept;
                if (init.capture)
                    this.capture = init.capture;
            }
        }
        set onfilechanged(value) { this.filechanged.connect(value); }
        set directoryMode(active) {
            this.input.setDirectoryMode(active);
        }
        set multiple(active) {
            this.input.multiple = active;
        }
        get accept() {
            return this._accept;
        }
        set accept(value) {
            this._accept = value;
            this.input.accept = value;
        }
        set capture(value) {
            this.input.capture = value;
        }
        onUploadButtonPress() {
            this.input.select();
        }
        onFile(wrapper, file) {
            this.filechanged.fire({ target: this, file: file });
        }
        testAccept(file) {
            if (this._accept) {
                let tab = this._accept.split(',');
                if (tab.indexOf(file.type) == -1)
                    return false;
            }
            return true;
        }
    }
    Ui.UploadButton = UploadButton;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Transition extends Core.Object {
        constructor() {
            super();
        }
        run(current, next, progress) {
            throw ('transition classes MUST override run method');
        }
        static register(transitionName, classType) {
            this.transitions[transitionName] = classType;
        }
        static parse(transition) {
            return new this.transitions[transition]();
        }
        static create(transition) {
            if (transition instanceof Transition)
                return transition;
            return new this.transitions[transition]();
        }
    }
    Transition.transitions = {};
    Ui.Transition = Transition;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Fade extends Ui.Transition {
        run(current, next, progress) {
            if (current !== undefined) {
                if (progress == 1) {
                    current.hide();
                    current.opacity = 1;
                }
                else
                    current.opacity = Math.min(1, Math.max(0, 1 - progress * 3));
            }
            if (next !== undefined)
                next.opacity = progress;
        }
    }
    Ui.Fade = Fade;
})(Ui || (Ui = {}));
Ui.Transition.register('fade', Ui.Fade);
var Ui;
(function (Ui) {
    class Slide extends Ui.Transition {
        constructor(init) {
            super();
            this._direction = 'right';
            if (init) {
                if (init.direction !== undefined)
                    this.direction = init.direction;
            }
        }
        set direction(direction) {
            this._direction = direction;
        }
        run(current, next, progress) {
            if (current !== undefined) {
                if (progress === 1) {
                    current.hide();
                    current.setTransformOrigin(0, 0);
                    current.transform = undefined;
                }
                else {
                    current.setTransformOrigin(0, 0);
                    if (this._direction == 'right')
                        current.transform = Ui.Matrix.createTranslate(-current.layoutWidth * progress, 0);
                    else if (this._direction == 'left')
                        current.transform = Ui.Matrix.createTranslate(current.layoutWidth * progress, 0);
                    else if (this._direction == 'top')
                        current.transform = Ui.Matrix.createTranslate(0, current.layoutHeight * progress);
                    else
                        current.transform = Ui.Matrix.createTranslate(0, -current.layoutHeight * progress);
                }
            }
            if (next !== undefined) {
                if (progress === 1) {
                    next.setTransformOrigin(0, 0);
                    next.transform = undefined;
                }
                else {
                    next.setTransformOrigin(0, 0);
                    if (this._direction == 'right')
                        next.transform = Ui.Matrix.createTranslate(next.layoutWidth * (1 - progress), 0);
                    else if (this._direction == 'left')
                        next.transform = Ui.Matrix.createTranslate(-next.layoutWidth * (1 - progress), 0);
                    else if (this._direction == 'top')
                        next.transform = Ui.Matrix.createTranslate(0, -next.layoutHeight * (1 - progress));
                    else
                        next.transform = Ui.Matrix.createTranslate(0, next.layoutHeight * (1 - progress));
                }
            }
        }
    }
    Ui.Slide = Slide;
})(Ui || (Ui = {}));
Ui.Transition.register('slide', Ui.Slide);
var Ui;
(function (Ui) {
    class Flip extends Ui.Transition {
        constructor(init) {
            super();
            this.orientation = 'horizontal';
            if (init) {
                if (init.orientation !== undefined)
                    this.orientation = init.orientation;
            }
        }
        run(current, next, progress) {
            if (progress < 0.5) {
                if (current !== undefined) {
                    current.setTransformOrigin(0.5, 0.5);
                    if (this.orientation == 'horizontal')
                        current.transform = Ui.Matrix.createScale((1 - progress * 2), 1);
                    else
                        current.transform = Ui.Matrix.createScale(1, (1 - progress * 2));
                }
                if (next !== undefined)
                    next.hide();
            }
            else {
                if (current !== undefined) {
                    current.hide();
                    current.setTransformOrigin(0, 0);
                    current.transform = undefined;
                }
                if (next !== undefined) {
                    if (progress == 1) {
                        next.show();
                        next.setTransformOrigin(0, 0);
                        next.transform = undefined;
                    }
                    else {
                        next.show();
                        next.setTransformOrigin(0.5, 0.5);
                        if (this.orientation == 'horizontal')
                            next.transform = Ui.Matrix.createScale((progress - 0.5) * 2, 1);
                        else
                            next.transform = Ui.Matrix.createScale(1, (progress - 0.5) * 2);
                    }
                }
            }
        }
    }
    Ui.Flip = Flip;
})(Ui || (Ui = {}));
Ui.Transition.register('flip', Ui.Flip);
var Ui;
(function (Ui) {
    class TransitionBox extends Ui.LBox {
        constructor(init) {
            super(init);
            this._duration = 0.5;
            this._position = -1;
            this.replaceMode = false;
            this.changed = new Core.Events();
            this.onTransitionComplete = () => {
                let i;
                this.transitionClock = undefined;
                let current = this.next;
                if (this._current !== undefined)
                    this._current.hide();
                this.next = undefined;
                if (this.replaceMode) {
                    this.replaceMode = false;
                    let removeList = [];
                    for (i = 0; i < this.children.length; i++) {
                        let item = this.children[i];
                        if (item !== current) {
                            let firstChild = item.firstChild;
                            if (firstChild)
                                removeList.push(firstChild);
                        }
                    }
                    for (i = 0; i < removeList.length; i++)
                        this.remove(removeList[i]);
                }
                this.changed.fire({ target: this, position: this._position });
            };
            this.clipToBounds = true;
            this.transition = 'fade';
            if (init) {
                if (init.duration !== undefined)
                    this.duration = init.duration;
                if (init.ease !== undefined)
                    this.ease = init.ease;
                if (init.transition !== undefined)
                    this.transition = init.transition;
                if (init.position !== undefined)
                    this.position = init.position;
                if (init.current !== undefined)
                    this.current = init.current;
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        get position() {
            return this._position;
        }
        set position(position) {
            this.setCurrentAt(position);
        }
        set duration(duration) {
            this._duration = duration;
        }
        set ease(ease) {
            this._ease = Anim.EasingFunction.create(ease);
        }
        set transition(transition) {
            this._transition = Ui.Transition.create(transition);
        }
        get current() {
            if (this._position == -1)
                return undefined;
            else
                return this.children[this._position].children[0];
        }
        set current(child) {
            let pos = child ? this.getChildPosition(child) : -1;
            if (pos != -1)
                this.setCurrentAt(pos);
        }
        setCurrentAt(position) {
            if (this._position != position) {
                if (this.next !== undefined) {
                    if (this._current !== undefined) {
                        this._current.hide();
                        this._current = this.next;
                        this._current.show();
                        this.next = undefined;
                    }
                }
                if (this.transitionClock !== undefined) {
                    this.transitionClock.completed.disconnect(this.onTransitionComplete);
                    this.transitionClock.stop();
                    this.transitionClock = undefined;
                }
                if (this._position != -1)
                    this._current = this.children[this._position];
                else
                    this._current = undefined;
                this.next = this.children[position];
                this.next.show();
                this._transition.run(this._current, this.next, 0);
                this.transitionClock = new Anim.Clock({ duration: this._duration, ease: this._ease });
                this.transitionClock.timeupdate.connect((e) => this.onTransitionTick(e.target, e.progress));
                this.transitionClock.completed.connect(this.onTransitionComplete);
                this.transitionClock.begin();
                this._position = position;
            }
        }
        replaceContent(content) {
            this.replaceMode = true;
            this.append(content);
            this.current = content;
        }
        onLoad() {
            super.onLoad();
            this.onTransitionBoxLoad();
        }
        onTransitionBoxLoad() {
        }
        onUnload() {
            super.onUnload();
            this.onTransitionBoxUnload();
        }
        onTransitionBoxUnload() {
            if (this.transitionClock !== undefined) {
                this.transitionClock.stop();
                this.transitionClock = undefined;
            }
        }
        onTransitionTick(clock, progress) {
            this.progress = progress;
            this._transition.run(this._current, this.next, progress);
        }
        arrangeCore(width, height) {
            super.arrangeCore(width, height);
            if (this.transitionClock !== undefined)
                this._transition.run(this._current, this.next, this.transitionClock.progress);
        }
        append(child) {
            if (this.getChildPosition(child) != -1)
                return;
            let content = new TransitionBoxContent();
            content.append(child);
            content.hide();
            super.append(content);
        }
        prepend(child) {
            if (this.getChildPosition(child) != -1)
                return;
            if (this._position !== -1)
                this._position++;
            let content = new TransitionBoxContent();
            content.append(child);
            content.hide();
            super.prepend(child);
        }
        remove(child) {
            for (let i = 0; i < this.children.length; i++) {
                if (this.children[i].firstChild == child) {
                    if (i < this._position)
                        this._position--;
                    else if (i == this._position)
                        this._position = -1;
                    this.children[i].remove(child);
                    super.remove(this.children[i]);
                    break;
                }
            }
        }
        getChildPosition(child) {
            for (let i = 0; i < this.children.length; i++) {
                if (this.children[i].children[0] == child)
                    return i;
            }
            return -1;
        }
    }
    Ui.TransitionBox = TransitionBox;
    class TransitionBoxContent extends Ui.LBox {
    }
    Ui.TransitionBoxContent = TransitionBoxContent;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Fold extends Ui.Container {
        constructor(init) {
            super(init);
            this._offset = 0;
            this._position = 'bottom';
            this._isFolded = true;
            this._over = true;
            this._mode = 'extend';
            this.contentSize = 0;
            this._animDuration = 0.5;
            this.folded = new Core.Events();
            this.unfolded = new Core.Events();
            this.positionchanged = new Core.Events();
            this.progress = new Core.Events();
            this.headerBox = new Ui.LBox();
            this.appendChild(this.headerBox);
            this.contentBox = new Ui.LBox();
            this.appendChild(this.contentBox);
            this.contentBox.hide();
            if (init) {
                if (init.isFolded !== undefined)
                    this.isFolded = init.isFolded;
                if (init.over !== undefined)
                    this.over = init.over;
                if (init.mode !== undefined)
                    this.mode = init.mode;
                if (init.header !== undefined)
                    this.header = init.header;
                if (init.content !== undefined)
                    this.content = init.content;
                if (init.background !== undefined)
                    this.background = init.background;
                if (init.position !== undefined)
                    this.position = init.position;
                if (init.animDuration !== undefined)
                    this.animDuration = init.animDuration;
                if (init.onfolded)
                    this.folded.connect(init.onfolded);
                if (init.onunfolded)
                    this.unfolded.connect(init.onunfolded);
                if (init.onpositionchanged)
                    this.positionchanged.connect(init.onpositionchanged);
                if (init.onprogress)
                    this.progress.connect(init.onprogress);
            }
        }
        set onfolded(value) { this.folded.connect(value); }
        set onunfolded(value) { this.unfolded.connect(value); }
        set onpositionchanged(value) { this.positionchanged.connect(value); }
        set onprogress(value) { this.progress.connect(value); }
        get isFolded() {
            return this._isFolded;
        }
        set isFolded(isFolded) {
            if (this._isFolded != isFolded) {
                this._isFolded = isFolded;
                if (this._isFolded) {
                    this.offset = 0;
                    this.contentBox.hide();
                    this.folded.fire({ target: this });
                }
                else {
                    this.offset = 1;
                    this.contentBox.show();
                    this.unfolded.fire({ target: this });
                }
            }
        }
        fold() {
            if (!this._isFolded) {
                this._isFolded = true;
                this.startAnimation();
                this.folded.fire({ target: this });
            }
        }
        unfold() {
            if (this._isFolded) {
                this._isFolded = false;
                this.startAnimation();
                this.unfolded.fire({ target: this });
            }
        }
        get over() {
            return this._over;
        }
        set over(over) {
            if (this._over != over) {
                this._over = over;
                this.stopAnimation();
                this.transform = Ui.Matrix.createTranslate(0, 0);
                this.invalidateMeasure();
            }
        }
        get mode() {
            return this._mode;
        }
        set mode(mode) {
            if (this._mode != mode) {
                this._mode = mode;
                this.stopAnimation();
                this.invalidateMeasure();
            }
        }
        get header() {
            return this._header;
        }
        set header(header) {
            if (header !== this._header) {
                this._header = header;
                this.headerBox.content = this._header;
            }
        }
        get content() {
            return this._content;
        }
        set content(content) {
            if (this._content !== content) {
                this._content = content;
                this.contentBox.content = this._content;
            }
        }
        get background() {
            return this._background;
        }
        set background(background) {
            if (this._background !== background) {
                if (this._background !== undefined)
                    this.removeChild(this._background);
                this._background = background;
                if (this._background !== undefined)
                    this.prependChild(this._background);
            }
        }
        get position() {
            return this._position;
        }
        set position(position) {
            if (this._position != position) {
                this._position = position;
                this.positionchanged.fire({ target: this, position: position });
                this.invalidateMeasure();
            }
        }
        invert() {
            if (this._isFolded)
                this.unfold();
            else
                this.fold();
        }
        get animDuration() {
            return this._animDuration;
        }
        set animDuration(duration) {
            this._animDuration = duration;
        }
        get offset() {
            return this._offset;
        }
        set offset(offset) {
            if (this._offset === offset)
                return;
            this._offset = offset;
            if (!this._over)
                this.invalidateMeasure();
            else {
                if (this._position === 'right') {
                    if (this._mode === 'slide')
                        this.transform = Ui.Matrix.createTranslate(-this._offset * this.contentSize, 0);
                    else
                        this.transform = Ui.Matrix.createTranslate(0, 0);
                    this.contentBox.setClipRectangle(0, 0, Math.round(this.contentSize * this._offset), this.layoutHeight);
                    if (this._background !== undefined)
                        this._background.arrange(0, 0, Math.round(this.headerBox.measureWidth + this.contentSize * this._offset), Math.round(this.layoutHeight));
                }
                else if (this._position === 'left') {
                    if (this._mode === 'slide')
                        this.transform = Ui.Matrix.createTranslate(-this.contentSize + (this._offset * this.contentSize), 0);
                    else
                        this.transform = Ui.Matrix.createTranslate(-this.contentSize, 0);
                    this.contentBox.setClipRectangle(Math.round(this.contentSize * (1 - this._offset)), 0, this.contentSize, this.layoutHeight);
                    if (this._background !== undefined)
                        this._background.arrange(Math.round(this.contentSize * (1 - this._offset)), 0, Math.round(this.headerBox.measureWidth + this.contentSize * this._offset), Math.round(this.layoutHeight));
                }
                else if (this._position === 'top') {
                    if (this._mode === 'slide')
                        this.transform = Ui.Matrix.createTranslate(0, -this.contentSize + (this._offset * this.contentSize));
                    else
                        this.transform = Ui.Matrix.createTranslate(0, -this.contentSize);
                    this.contentBox.setClipRectangle(0, Math.round(this.contentSize * (1 - this._offset)), this.layoutWidth, Math.round(this.contentSize * this._offset));
                    if (this._background !== undefined)
                        this._background.arrange(0, Math.round(this.contentSize * (1 - this._offset)), this.layoutWidth, Math.round(this.headerBox.measureHeight + this.contentSize * this._offset));
                }
                else {
                    if (this._mode === 'slide')
                        this.transform = Ui.Matrix.createTranslate(0, -this._offset * this.contentSize);
                    else
                        this.transform = Ui.Matrix.createTranslate(0, 0);
                    this.contentBox.setClipRectangle(0, 0, this.layoutWidth, Math.round(this.contentSize * this._offset));
                    if (this._background !== undefined)
                        this._background.arrange(0, 0, this.layoutWidth, Math.round(this.headerBox.measureHeight + this.contentSize * this._offset));
                }
            }
        }
        startAnimation() {
            if (this.clock !== undefined)
                this.clock.stop();
            if (!this._isFolded)
                this.contentBox.show();
            this.clock = new Anim.Clock({ duration: this._animDuration, target: this });
            this.clock.timeupdate.connect((e) => this.onClockTick(e.target, e.progress));
            this.clock.begin();
        }
        stopAnimation() {
            if (this.clock !== undefined) {
                this.clock.stop();
                this.clock = undefined;
            }
        }
        onClockTick(clock, progress) {
            if (this.content === undefined) {
                if (this.clock !== undefined) {
                    this.clock.stop();
                    this.clock = undefined;
                }
                return;
            }
            let offset = this.offset;
            if (offset > 1)
                this.offset = 1;
            else {
                let destOffset;
                if (this._isFolded)
                    destOffset = 0;
                else
                    destOffset = 1;
                this.offset = destOffset - ((destOffset - offset) * (1 - progress));
            }
            this.progress.fire({ target: this, offset: this.offset });
            if ((progress == 1) && this._isFolded) {
                this.contentBox.hide();
            }
        }
        measureCore(width, height) {
            if (this._background !== undefined)
                this._background.measure(width, height);
            let size = this.headerBox.measure(width, height);
            let contentSize = { width: 0, height: 0 };
            if ((this._position == 'left') || (this._position == 'right')) {
                contentSize = this.contentBox.measure(width - size.width, height);
                if (contentSize.height > size.height)
                    size.height = contentSize.height;
                if (!this._over)
                    size.width += contentSize.width * this._offset;
                this.contentSize = contentSize.width;
            }
            else {
                contentSize = this.contentBox.measure(width, height - size.height);
                if (contentSize.width > size.width)
                    size.width = contentSize.width;
                if (!this._over)
                    size.height += contentSize.height * this._offset;
                this.contentSize = contentSize.height;
            }
            return size;
        }
        arrangeCore(width, height) {
            if (this._position == 'left') {
                if (!this._over)
                    this.transform = Ui.Matrix.createTranslate(-this.contentSize + (this._offset * this.contentSize), 0);
                this.contentBox.arrange(0, 0, this.contentBox.measureWidth, height);
                this.headerBox.arrange(this.contentBox.measureWidth, 0, this.headerBox.measureWidth, height);
                if (this._background !== undefined)
                    this._background.arrange(Math.round(this.contentSize * (1 - this._offset)), 0, Math.round(this.headerBox.measureWidth + this.contentSize * this._offset), Math.round(height));
                this.contentBox.setClipRectangle(Math.round(this.contentSize * (1 - this._offset)), 0, Math.round(this.contentSize * this._offset), Math.round(height));
            }
            else if (this._position == 'right') {
                this.headerBox.arrange(0, 0, this.headerBox.measureWidth, height);
                this.contentBox.arrange(this.headerBox.measureWidth, 0, this.contentBox.measureWidth, height);
                if (this._background !== undefined)
                    this._background.arrange(0, 0, Math.round(this.headerBox.measureWidth + this.contentSize * this._offset), Math.round(height));
                this.contentBox.setClipRectangle(0, 0, Math.round(this.contentSize * this._offset), Math.round(height));
            }
            else if (this._position == 'top') {
                if (!this._over)
                    this.transform = Ui.Matrix.createTranslate(0, -this.contentSize + (this._offset * this.contentSize));
                this.contentBox.arrange(0, 0, width, this.contentBox.measureHeight);
                this.headerBox.arrange(0, this.contentBox.measureHeight, width, this.headerBox.measureHeight);
                if (this._background !== undefined)
                    this._background.arrange(0, Math.round(this.contentSize * (1 - this._offset)), width, Math.round(this.headerBox.measureHeight + this.contentSize * this._offset));
                this.contentBox.setClipRectangle(0, Math.round(this.contentSize * (1 - this._offset)), Math.round(width), Math.round(this.contentSize * this._offset));
            }
            else {
                this.headerBox.arrange(0, 0, width, this.headerBox.measureHeight);
                this.contentBox.arrange(0, this.headerBox.measureHeight, width, this.contentBox.measureHeight);
                if (this._background !== undefined)
                    this._background.arrange(0, 0, width, Math.round(this.headerBox.measureHeight + this.contentSize * this._offset));
                this.contentBox.setClipRectangle(0, 0, Math.round(width), Math.round(this.contentSize * this._offset));
            }
            this.offset = this._offset;
        }
    }
    Ui.Fold = Fold;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Switch extends Ui.Container {
        constructor(init) {
            super(init);
            this._value = false;
            this.pos = 0;
            this.speed = 0;
            this.animNext = 0;
            this.animStart = 0;
            this.changed = new Core.Events();
            this.role = 'checkbox';
            this.drawing.setAttribute('aria-checked', 'false');
            this.focusable = true;
            this.drawing.style.cursor = 'pointer';
            this.graphic = new Ui.SimpleButtonBackground();
            this.appendChild(this.graphic);
            this.barBackground = new Ui.Rectangle({ width: 4, height: 14, radius: 7 });
            this.appendChild(this.barBackground);
            this.bar = new Ui.Rectangle({ width: 4, height: 14, radius: 7 });
            this.appendChild(this.bar);
            this.pressWatcher = new Ui.PressWatcher({
                element: this,
                ondowned: () => this.onDown(),
                onupped: () => this.onUp(),
                onpressed: () => this.value = !this.value
            });
            this.focused.connect(() => this.updateColors());
            this.blurred.connect(() => this.updateColors());
            this.button = new Ui.Rectangle({ radius: 10, width: 20, height: 20, margin: 10 });
            this.button.drawing.style.boxShadow = '0px 0px 2px rgba(0,0,0,0.5)';
            this.appendChild(this.button);
            this.ease = new Anim.PowerEase({ mode: 'out' });
            if (init) {
                if (init.value !== undefined)
                    this.value = init.value;
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        get value() {
            return this._value;
        }
        set value(value) {
            if (this._value !== value) {
                this._value = value;
                this.updateColors();
                if (this.isLoaded) {
                    if (this._value)
                        this.startAnimation(4);
                    else
                        this.startAnimation(-4);
                }
                else
                    this.pos = this._value ? 1 : 0;
                this.drawing.setAttribute('aria-checked', this.value.toString());
                this.changed.fire({ target: this, value: this._value });
            }
        }
        set title(title) {
            this.drawing.setAttribute('title', title);
        }
        get title() {
            return this.drawing.getAttribute('title');
        }
        updatePos() {
            let width = this.layoutWidth;
            let height = this.layoutHeight;
            let max = width - (this.button.layoutWidth + this.button.marginLeft + this.button.marginRight);
            this.button.arrange(max * this.pos, 0, this.button.measureWidth, this.button.measureHeight);
            this.bar.arrange(this.button.marginLeft + (this.button.layoutWidth / 2), (height - this.bar.measureHeight) / 2, max * this.pos, this.bar.measureHeight);
        }
        getForeground() {
            return Ui.Color.create(this.value ? this.getStyleProperty('activeForeground') : this.getStyleProperty('foreground'));
        }
        getBarBackground() {
            let yuv = Ui.Color.create(this.getStyleProperty('barBackground')).getYuv();
            let deltaY = 0;
            if (this.pressWatcher.isDown)
                deltaY = -0.30;
            return Ui.Color.createFromYuv(yuv.y + deltaY, yuv.u, yuv.v);
        }
        getBorder() {
            if (this.hasFocus && !this.isMouseFocus)
                return Ui.Color.create(this.getStyleProperty('focusBackgroundBorder'));
            else
                return Ui.Color.create(this.getStyleProperty('backgroundBorder'));
        }
        getBackground() {
            return Ui.Color.create(this.getStyleProperty('background'));
        }
        updateColors() {
            this.bar.fill = this.getForeground().addA(-0.6);
            this.barBackground.fill = this.getBarBackground();
            this.button.fill = this.getForeground();
            this.graphic.border = this.getBorder();
            this.graphic.background = this.getBackground();
        }
        onDown() {
            this.stopAnimation();
            this.updateColors();
        }
        onUp() {
            this.updateColors();
        }
        startAnimation(speed) {
            this.stopAnimation();
            this.speed = speed;
            this.animStart = this.pos;
            if (this.speed > 0)
                this.animNext = 1;
            else
                this.animNext = 0;
            if (this.animStart !== this.animNext) {
                this.alignClock = new Anim.Clock({ duration: 'forever', target: this });
                this.alignClock.timeupdate.connect((e) => this.onAlignTick(e.target, e.progress, e.deltaTick));
                this.alignClock.begin();
            }
            else {
                if (this._value !== (this.animNext === 1)) {
                    this._value = (this.animNext === 1);
                    this.button.fill = this.getForeground();
                    this.changed.fire({ target: this, value: this._value });
                }
            }
        }
        stopAnimation() {
            if (this.alignClock !== undefined) {
                this.alignClock.stop();
                this.alignClock = undefined;
            }
        }
        onAlignTick(clock, progress, delta) {
            if (delta === 0)
                return;
            let relprogress = (clock.time * this.speed) / (this.animNext - this.animStart);
            if (relprogress >= 1) {
                if (this.alignClock)
                    this.alignClock.stop();
                this.alignClock = undefined;
                relprogress = 1;
                if (this._value != (this.animNext === 1)) {
                    this._value = (this.animNext === 1);
                    this.button.fill = this.getForeground();
                    this.changed.fire({ target: this, value: this._value });
                }
            }
            relprogress = this.ease.ease(relprogress);
            this.pos = (this.animStart + relprogress * (this.animNext - this.animStart));
            this.updatePos();
        }
        measureCore(width, height) {
            let buttonSize = this.button.measure(0, 0);
            let size = buttonSize;
            let res = this.barBackground.measure(buttonSize.width * 1.75, 0);
            if (res.width > size.width)
                size.width = res.width;
            if (res.height > size.height)
                size.height = res.height;
            res = this.bar.measure(buttonSize.width * 1.75, 0);
            if (res.width > size.width)
                size.width = res.width;
            if (res.height > size.height)
                size.height = res.height;
            if (buttonSize.width * 1.75 > size.width)
                size.width = buttonSize.width * 1.75;
            return size;
        }
        arrangeCore(width, height) {
            this.button.arrange(0, (height - this.button.measureHeight) / 2, this.button.measureWidth, this.button.measureHeight);
            this.barBackground.arrange(this.button.marginLeft + (this.button.layoutWidth / 2), (height - this.barBackground.measureHeight) / 2, width - (this.button.layoutWidth + this.button.marginLeft + this.button.marginRight), this.barBackground.measureHeight);
            this.graphic.arrange(0, 0, width, height);
            this.updatePos();
        }
        onStyleChange() {
            this.updateColors();
            this.graphic.borderWidth = parseInt(this.getStyleProperty('borderWidth'));
            this.graphic.radius = parseInt(this.getStyleProperty('borderRadius'));
        }
        onDisable() {
            super.onDisable();
            this.button.opacity = 0.2;
            this.drawing.style.cursor = 'inherit';
        }
        onEnable() {
            super.onEnable();
            this.button.opacity = 1;
            this.drawing.style.cursor = 'pointer';
        }
    }
    Switch.style = {
        radius: 0,
        borderWidth: 1,
        background: 'rgba(250,250,250,0)',
        barBackground: '#e1e1e1',
        backgroundBorder: 'rgba(250,250,250,0)',
        foreground: '#757575',
        activeForeground: '#07a0e5',
        focusBackgroundBorder: '#21d3ff',
        borderRadius: 4
    };
    Ui.Switch = Switch;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Accordeonable extends Ui.Container {
        constructor(init) {
            super(init);
            this.current = -1;
            this.headersSize = 0;
            this.contentSize = 0;
            this._orientation = 'horizontal';
            this.changed = new Core.Events();
            this.onPageSelect = (e) => {
                this.currentPage = e.target;
            };
            this.onPageClose = (e) => {
                this.removePage(e.target);
            };
            this.clipToBounds = true;
        }
        set onchanged(value) { this.changed.connect(value); }
        get orientation() {
            return this._orientation;
        }
        set orientation(orientation) {
            if (this._orientation != orientation) {
                this._orientation = orientation;
                for (let i = 0; i < this.pages.length; i++)
                    this.pages[i].setOrientation(orientation);
                this.invalidateMeasure();
            }
        }
        get pages() {
            return this.children;
        }
        get currentPage() {
            return this._currentPage;
        }
        set currentPage(page) {
            for (let i = 0; i < this.pages.length; i++) {
                if (this.pages[i] == page) {
                    this.currentPosition = i;
                    return;
                }
            }
        }
        get currentPosition() {
            return this.current;
        }
        set currentPosition(pos) {
            if (this.pages.length === 0) {
                if (this._currentPage !== undefined)
                    this._currentPage.unselect();
                this._currentPage = undefined;
                this.current = -1;
            }
            else {
                this.current = pos;
                let newPage = this.pages[this.current];
                if (newPage !== this._currentPage) {
                    if (this._currentPage !== undefined)
                        this._currentPage.unselect();
                    this._currentPage = newPage;
                    this.changed.fire({ target: this, page: this._currentPage, position: this.current });
                    this._currentPage.selected.disconnect(this.onPageSelect);
                    this._currentPage.select();
                    this._currentPage.selected.connect(this.onPageSelect);
                }
                if (this.clock !== undefined)
                    this.clock.stop();
                this.clock = new Anim.Clock({ duration: 2, target: this });
                this.clock.timeupdate.connect(e => this.onClockTick(e.target, e.progress));
                this.clock.begin();
            }
        }
        appendPage(page, autoSelect = true) {
            this.appendChild(page);
            page.setOffset(1);
            page.setOrientation(this._orientation);
            page.selected.connect(this.onPageSelect);
            page.closed.connect(this.onPageClose);
            if (autoSelect)
                page.select();
        }
        removePage(page) {
            let pos = -1;
            for (let i = 0; i < this.pages.length; i++) {
                if (this.pages[i] == page) {
                    pos = i;
                    break;
                }
            }
            if (pos !== -1) {
                page.selected.disconnect(this.onPageSelect);
                page.closed.disconnect(this.onPageClose);
                this.removeChild(page);
                if ((this.current === pos) && (this.current === 0))
                    this.currentPosition = 0;
                else if (this.current >= pos)
                    this.currentPosition = this.current - 1;
                else
                    this.currentPosition = this.current;
            }
        }
        onClockTick(clock, progress) {
            for (let i = 0; i < this.pages.length; i++) {
                let child = this.pages[i];
                if (i == this.current)
                    child.showContent();
                let offset = child.getOffset();
                if (offset > 1)
                    child.setOffset(1);
                else {
                    let destOffset;
                    if (i <= this.current)
                        destOffset = 0;
                    else
                        destOffset = 1;
                    child.setOffset(destOffset - ((destOffset - offset) * (1 - progress)));
                }
                if ((progress == 1) && (i != this.current))
                    child.hideContent();
            }
        }
        measureHorizontal(width, height) {
            let i;
            let size;
            let child;
            let content;
            let minHeaders = 0;
            let minContent = 0;
            let minHeight = 0;
            for (i = 0; i < this.children.length; i++) {
                child = this.children[i];
                size = child.measure(width, height);
                minHeaders += child.getHeader().measureWidth;
                if (child.getHeader().measureHeight > minHeight)
                    minHeight = child.getHeader().measureHeight;
            }
            for (i = 0; i < this.children.length; i++) {
                child = this.children[i];
                size = child.measure((width - minHeaders) + child.getHeader().measureWidth, height);
                content = child.getContent();
                if ((content !== undefined) && (content.measureWidth > minContent)) {
                    minContent = content.measureWidth;
                    if (content.measureHeight > minHeight)
                        minHeight = content.measureHeight;
                }
            }
            this.headersSize = minHeaders;
            return { width: minHeaders + minContent, height: minHeight };
        }
        measureVertical(width, height) {
            let i;
            let child;
            let size;
            let content;
            let minHeaders = 0;
            let minContent = 0;
            let minWidth = 0;
            for (i = 0; i < this.children.length; i++) {
                child = this.children[i];
                size = child.measure(width, height);
                minHeaders += child.getHeader().measureHeight;
                if (child.getHeader().measureWidth > minWidth)
                    minWidth = child.getHeader().measureWidth;
            }
            for (i = 0; i < this.children.length; i++) {
                child = this.children[i];
                size = child.measure(width, (height - minHeaders) + child.getHeader().measureHeight);
                content = child.getContent();
                if ((content !== undefined) && (content.measureHeight > minContent)) {
                    minContent = content.measureHeight;
                    if (content.measureWidth > minWidth)
                        minWidth = content.measureWidth;
                }
            }
            this.headersSize = minHeaders;
            return { width: minWidth, height: minHeaders + minContent };
        }
        measureCore(width, height) {
            if (this._orientation == 'horizontal')
                return this.measureHorizontal(width, height);
            else
                return this.measureVertical(width, height);
        }
        arrangeCore(width, height) {
            let i;
            let child;
            let x;
            let y;
            if (this._orientation == 'horizontal') {
                x = 0;
                this.contentSize = width - this.headersSize;
                for (i = 0; i < this.children.length; i++) {
                    child = this.children[i];
                    child.arrange(x, 0, this.contentSize + child.getHeader().measureWidth, height);
                    x += child.getHeader().measureWidth;
                }
            }
            else {
                y = 0;
                this.contentSize = height - this.headersSize;
                for (i = 0; i < this.children.length; i++) {
                    child = this.children[i];
                    child.arrange(0, y, width, this.contentSize + child.getHeader().measureHeight);
                    y += child.getHeader().measureHeight;
                }
            }
        }
    }
    Ui.Accordeonable = Accordeonable;
    class AccordeonPage extends Ui.Container {
        constructor(init) {
            super(init);
            this.offset = 0;
            this.orientation = 'horizontal';
            this.isSelected = false;
            this.selected = new Core.Events();
            this.unselected = new Core.Events();
            this.closed = new Core.Events();
            this.orientationchanged = new Core.Events();
            this.headerBox = new Ui.Pressable();
            this.appendChild(this.headerBox);
            this.headerBox.pressed.connect(e => this.onHeaderPress());
        }
        set onselected(value) { this.selected.connect(value); }
        set onunselected(value) { this.unselected.connect(value); }
        set onclosed(value) { this.closed.connect(value); }
        set onorientationchanged(value) { this.orientationchanged.connect(value); }
        close() {
            this.closed.fire({ target: this });
        }
        select() {
            if (!this.isSelected) {
                this.isSelected = true;
                this.selected.fire({ target: this });
            }
        }
        getIsSelected() {
            return this.isSelected;
        }
        getHeader() {
            return this.header;
        }
        setHeader(header) {
            if (header !== this.header) {
                if (this.header !== undefined)
                    this.headerBox.removeChild(this.header);
                this.header = header;
                if (this.header !== undefined)
                    this.headerBox.appendChild(this.header);
            }
        }
        getContent() {
            return this.content;
        }
        setContent(content) {
            if (this.content !== content) {
                if (this.content !== undefined)
                    this.removeChild(this.content);
                this.content = content;
                if (this.content !== undefined)
                    this.appendChild(this.content);
            }
        }
        getOrientation() {
            return this.orientation;
        }
        setOrientation(orientation) {
            if (this.orientation != orientation) {
                this.orientation = orientation;
                this.orientationchanged.fire({ target: this, orientation: orientation });
                this.invalidateMeasure();
            }
        }
        unselect() {
            if (this.isSelected) {
                this.isSelected = false;
                this.unselected.fire({ target: this });
            }
        }
        showContent() {
            if (this.content !== undefined) {
                this.content.show();
            }
        }
        hideContent() {
            if (this.content !== undefined) {
                this.content.hide();
            }
        }
        getOffset() {
            return this.offset;
        }
        setOffset(offset) {
            this.offset = offset;
            if (this.orientation == 'horizontal')
                this.transform = Ui.Matrix.createTranslate(this.offset * (this.layoutWidth - this.headerBox.measureWidth), 0);
            else
                this.transform = Ui.Matrix.createTranslate(0, this.offset * (this.layoutHeight - this.headerBox.measureHeight));
        }
        onHeaderPress() {
            this.select();
        }
        measureCore(width, height) {
            let size = this.headerBox.measure(width, height);
            let contentSize = { width: 0, height: 0 };
            if (this.content !== undefined) {
                if (this.orientation == 'horizontal') {
                    contentSize = this.content.measure(width - size.width, height);
                    if (contentSize.height > size.height)
                        size.height = contentSize.height;
                    size.width += contentSize.width;
                }
                else {
                    contentSize = this.content.measure(width, height - size.height);
                    if (contentSize.width > size.width)
                        size.width = contentSize.width;
                    size.height += contentSize.height;
                }
            }
            return size;
        }
        arrangeCore(width, height) {
            if (this.orientation == 'horizontal') {
                this.headerBox.arrange(0, 0, this.headerBox.measureWidth, height);
                if (this.content !== undefined)
                    this.content.arrange(this.headerBox.measureWidth, 0, width - this.headerBox.measureWidth, height);
            }
            else {
                this.headerBox.arrange(0, 0, width, this.headerBox.measureHeight);
                if (this.content !== undefined)
                    this.content.arrange(0, this.headerBox.measureHeight, width, height - this.headerBox.measureHeight);
            }
            this.setOffset(this.offset);
        }
    }
    Ui.AccordeonPage = AccordeonPage;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Accordeon extends Ui.Accordeonable {
    }
    Ui.Accordeon = Accordeon;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class DropAtBox extends Ui.LBox {
        constructor(container, init) {
            super(init);
            this.watchers = [];
            this.drageffect = new Core.Events();
            this.dragentered = new Core.Events();
            this.dragleaved = new Core.Events();
            this.droppedat = new Core.Events();
            this.droppedfileat = new Core.Events();
            this.fixed = new Ui.Fixed();
            super.append(this.fixed);
            this.container = container;
            super.append(this.container);
            this.dragover.connect((e) => this.onDragOver(e));
            if (init) {
                if (init.ondroppedat)
                    this.droppedat.connect(init.ondroppedat);
                if (init.ondroppedfileat)
                    this.droppedfileat.connect(init.ondroppedfileat);
            }
        }
        set ondrageffect(value) { this.drageffect.connect(value); }
        set ondragentered(value) { this.dragentered.connect(value); }
        set ondragleaved(value) { this.dragleaved.connect(value); }
        set ondroppedat(value) { this.droppedat.connect(value); }
        set ondroppedfileat(value) { this.droppedfileat.connect(value); }
        addType(type, effects) {
            if (typeof (type) === 'string')
                type = type.toLowerCase();
            if (this.allowedTypes == undefined)
                this.allowedTypes = [];
            if (typeof (effects) === 'string')
                effects = [effects];
            if (typeof (effects) !== 'function') {
                for (let i = 0; i < effects.length; i++) {
                    let effect = effects[i];
                    if (typeof (effect) === 'string')
                        effect = { action: effect };
                    if (!('text' in effect)) {
                        if (effect.action === 'copy')
                            effect.text = 'Copier';
                        else if (effect.action === 'move')
                            effect.text = 'Déplacer';
                        else if (effect.action === 'link')
                            effect.text = 'Lier';
                        else
                            effect.text = effect.action;
                    }
                    if (!('dragicon' in effect))
                        effect.dragicon = 'drag' + effect.action;
                    effects[i] = effect;
                }
                this.allowedTypes.push({ type: type, effect: effects });
            }
            else
                this.allowedTypes.push({ type: type, effect: effects });
        }
        setMarkerOrientation(orientation) {
            this.markerOrientation = orientation;
        }
        setMarkerPos(marker, pos) {
            marker.show();
            let spacing = 0;
            if ('spacing' in this.container)
                spacing = this.container.spacing;
            if (pos < this.container.children.length) {
                let child = this.container.children[pos];
                if (this.markerOrientation === 'horizontal') {
                    let x = child.layoutX - child.marginLeft -
                        (marker.layoutWidth + marker.marginLeft + marker.marginRight + spacing) / 2;
                    let y = child.layoutY;
                    let height = child.layoutHeight;
                    marker.height = height;
                    this.fixed.setPosition(marker, x, y);
                }
                else {
                    let x = child.layoutX;
                    let y = child.layoutY - child.marginTop - (marker.layoutHeight + marker.marginTop + marker.marginBottom) / 2 - spacing / 2;
                    marker.width = child.layoutWidth;
                    this.fixed.setPosition(marker, x, y);
                }
            }
            else if (this.container.children.length > 0) {
                let child = this.container.children[this.container.children.length - 1];
                if (this.markerOrientation === 'horizontal') {
                    let x = child.layoutX + child.layoutWidth - (marker.layoutWidth - spacing) / 2;
                    let y = child.layoutY;
                    let height = child.layoutHeight;
                    marker.height = height;
                    this.fixed.setPosition(marker, x, y);
                }
                else {
                    let x = child.layoutX;
                    let y = child.layoutY + child.layoutHeight - marker.layoutHeight / 2;
                    marker.width = child.layoutWidth;
                    this.fixed.setPosition(marker, x, y);
                }
            }
        }
        findPosition(point) {
            if (this.markerOrientation === 'horizontal')
                return this.findPositionHorizontal(point);
            else
                return this.findPositionVertical(point);
        }
        findPositionHorizontal(point) {
            let line = [];
            let childs = this.container.children;
            for (let i = 0; i < childs.length; i++) {
                if ((point.y >= childs[i].layoutY) && (point.y < childs[i].layoutY + childs[i].layoutHeight))
                    line.push(childs[i]);
            }
            let element = undefined;
            let dist = Number.MAX_VALUE;
            for (let i = 0; i < line.length; i++) {
                let cx = line[i].layoutX + ((line[i].layoutWidth) / 2);
                let d = Math.abs(point.x - cx);
                if (d < dist) {
                    dist = d;
                    element = line[i];
                }
            }
            if ((element === undefined) && (line.length > 0))
                element = line[line.length - 1];
            let insertPos = childs.length;
            if (element !== undefined) {
                let elPos = -1;
                for (let i = 0; (elPos == -1) && (i < childs.length); i++) {
                    if (childs[i] == element)
                        elPos = i;
                }
                if (point.x < element.layoutX + element.layoutWidth / 2)
                    insertPos = elPos;
                else
                    insertPos = elPos + 1;
            }
            return insertPos;
        }
        findPositionVertical(point) {
            let childs = this.container.children;
            let element = undefined;
            let dist = Number.MAX_VALUE;
            for (let i = 0; i < childs.length; i++) {
                let cy = childs[i].layoutY + ((childs[i].layoutHeight) / 2);
                let d = Math.abs(point.y - cy);
                if (d < dist) {
                    dist = d;
                    element = childs[i];
                }
            }
            if ((element === undefined) && (childs.length > 0))
                element = childs[childs.length - 1];
            let insertPos = childs.length;
            if (element !== undefined) {
                let elPos = -1;
                for (let i = 0; (elPos === -1) && (i < childs.length); i++) {
                    if (childs[i] === element)
                        elPos = i;
                }
                if (point.y < element.layoutY + element.layoutHeight / 2)
                    insertPos = elPos;
                else
                    insertPos = elPos + 1;
            }
            return insertPos;
        }
        insertAt(element, pos) {
            this.container.insertAt(element, pos);
        }
        insertBefore(element, child) {
            this.container.insertBefore(element, child);
        }
        moveAt(element, pos) {
            this.container.moveAt(element, pos);
        }
        get logicalChildren() {
            return this.container.children;
        }
        set content(content) {
            this.container.content = content;
        }
        clear() {
            this.container.clear();
        }
        append(item) {
            this.container.append(item);
        }
        remove(item) {
            this.container.remove(item);
        }
        getChildPosition(child) {
            return this.container.getChildPosition(child);
        }
        hasChild(child) {
            return this.container.hasChild(child);
        }
        onStyleChange() {
            let color = this.getStyleProperty('markerColor');
            for (let i = 0; i < this.watchers.length; i++) {
                let marker = (this.watchers[i])["Ui.DropAtBox.marker"];
                marker.fill = color;
            }
        }
        getAllowedTypesEffect(dataTransfer) {
            if (this.allowedTypes !== undefined) {
                let data = dataTransfer.getData();
                let effect = undefined;
                for (let i = 0; (effect === undefined) && (i < this.allowedTypes.length); i++) {
                    let type = this.allowedTypes[i];
                    if (typeof (type.type) === 'string') {
                        if (type.type === 'all')
                            effect = type.effect;
                        else if (data instanceof Ui.DragNativeData) {
                            if ((type.type === 'files') && data.hasFiles())
                                effect = type.effect;
                            else if (((type.type === 'text') || (type.type === 'text/plain')) && data.hasTypes('text/plain', 'text'))
                                effect = type.effect;
                            else if (data.hasType(type.type))
                                effect = type.effect;
                        }
                    }
                    else if (data instanceof type.type)
                        effect = type.effect;
                }
                if (typeof (effect) === 'function') {
                    let effects = this.onDragEffectFunction(dataTransfer, effect);
                    for (let i = 0; i < effects.length; i++) {
                        let effect = effects[i];
                        if (typeof (effect) === 'string')
                            effect = { action: effect };
                        if (!('text' in effect)) {
                            if (effect.action === 'copy')
                                effect.text = 'Copier';
                            else if (effect.action === 'move')
                                effect.text = 'Déplacer';
                            else if (effect.action === 'link')
                                effect.text = 'Lier';
                            else if (effect.action === 'run')
                                effect.text = 'Exécuter';
                            else if (effect.action === 'play')
                                effect.text = 'Jouer';
                            else
                                effect.text = effect.action;
                        }
                        if (!('dragicon' in effect))
                            effect.dragicon = 'drag' + effect.action;
                        effects[i] = effect;
                    }
                    effect = effects;
                }
                if (effect === undefined)
                    effect = [];
                return effect;
            }
            else
                return [];
        }
        onDragEffect(dataTransfer) {
            let dragEvent = new Ui.DragEvent();
            dragEvent.setType('drageffect');
            dragEvent.setBubbles(false);
            dragEvent.dataTransfer = dataTransfer;
            dragEvent.dispatchEvent(this);
            let effectAllowed = dragEvent.effectAllowed;
            if (effectAllowed !== undefined)
                return dragEvent.effectAllowed;
            else
                return this.getAllowedTypesEffect(dataTransfer);
        }
        onDragOver(event) {
            if (!event.dataTransfer)
                return;
            let foundWatcher = undefined;
            for (let i = 0; (foundWatcher === undefined) && (i < this.watchers.length); i++)
                if (this.watchers[i].getDataTransfer() === event.dataTransfer)
                    foundWatcher = this.watchers[i];
            let effect = this.onDragEffect(event.dataTransfer);
            if (foundWatcher !== undefined && effect) {
                let equal = effect.length === foundWatcher.getEffectAllowed();
                for (let i = 0; equal && (i < effect.length); i++) {
                    equal = effect[i] === foundWatcher.getEffectAllowed()[i];
                }
                if (!equal) {
                    foundWatcher.release();
                    foundWatcher = undefined;
                }
            }
            if ((effect !== undefined) && (effect.length > 0) && (foundWatcher === undefined)) {
                let watcher = event.dataTransfer.capture(this, effect);
                this.watchers.push(watcher);
                watcher.moved.connect(() => this.onWatcherMove(watcher));
                watcher.dropped.connect((e) => this.onWatcherDrop(e.target, e.effect, e.x, e.y));
                watcher.leaved.connect(() => this.onWatcherLeave(watcher));
                event.stopImmediatePropagation();
                this.onWatcherEnter(watcher);
            }
            else if (foundWatcher !== undefined)
                event.stopImmediatePropagation();
        }
        onDragEffectFunction(dataTransfer, func) {
            let position = this.findPosition(this.pointFromWindow(dataTransfer.getPosition()));
            return func(dataTransfer.getData(), position);
        }
        onWatcherEnter(watcher) {
            let marker = new Ui.Rectangle({ margin: 0, width: 6, height: 6 });
            marker.fill = this.getStyleProperty('markerColor');
            marker.hide();
            this.fixed.append(marker, 0, 0);
            watcher["Ui.DropAtBox.marker"] = marker;
        }
        onWatcherMove(watcher) {
            this.onDragEnter(watcher.getDataTransfer());
            let marker = watcher["Ui.DropAtBox.marker"];
            let position = this.findPosition(this.pointFromWindow(watcher.getPosition()));
            this.setMarkerPos(marker, position);
        }
        onWatcherLeave(watcher) {
            let found = false;
            let i = 0;
            for (; !found && (i < this.watchers.length); i++) {
                found = (this.watchers[i] === watcher);
            }
            i--;
            if (found)
                this.watchers.splice(i, 1);
            if (this.watchers.length === 0)
                this.onDragLeave();
            let marker = watcher["Ui.DropAtBox.marker"];
            this.fixed.remove(marker);
        }
        onWatcherDrop(watcher, effect, x, y) {
            let point = this.pointFromWindow(new Ui.Point(x, y));
            this.onDrop(watcher.getDataTransfer(), effect, point.getX(), point.getY());
        }
        onDragEnter(dataTransfer) {
            this.dragentered.fire({ target: this, data: dataTransfer.getData() });
        }
        onDragLeave() {
            this.dragleaved.fire({ target: this });
        }
        onDrop(dataTransfer, dropEffect, x, y) {
            let done = false;
            let point = new Ui.Point(x, y);
            let position = this.findPosition(point);
            this.droppedat.fire({
                target: this,
                data: dataTransfer.getData(),
                effect: dropEffect,
                position: position,
                x: x, y: y
            });
            let data = dataTransfer.getData();
            if (data instanceof Ui.DragNativeData && data.hasFiles()) {
                let files = data.getFiles();
                for (let i = 0; i < files.length; i++)
                    this.droppedfileat.fire({
                        target: this, file: files[i], effect: dropEffect,
                        position: position, x: x, y: y
                    });
            }
        }
    }
    DropAtBox.style = {
        markerColor: '#ff0076'
    };
    Ui.DropAtBox = DropAtBox;
    class FlowDropBox extends DropAtBox {
        constructor(init) {
            super(new Ui.Flow().assign({ spacing: 10 }), init);
            this.setMarkerOrientation('horizontal');
            if (init) {
                if (init.uniform !== undefined)
                    this.uniform = init.uniform;
                if (init.spacing !== undefined)
                    this.spacing = init.spacing;
            }
        }
        set uniform(uniform) {
            this.container.uniform = uniform;
        }
        set spacing(spacing) {
            this.container.spacing = spacing;
        }
    }
    Ui.FlowDropBox = FlowDropBox;
    class SFlowDropBox extends DropAtBox {
        constructor(init) {
            super(new Ui.SFlow(), init);
            this.setMarkerOrientation('horizontal');
            if (init) {
                if (init.stretchMaxRatio !== undefined)
                    this.stretchMaxRatio = init.stretchMaxRatio;
                if (init.uniform !== undefined)
                    this.uniform = init.uniform;
                if (init.uniformRatio !== undefined)
                    this.uniformRatio = init.uniformRatio;
                if (init.itemAlign !== undefined)
                    this.itemAlign = init.itemAlign;
                if (init.spacing !== undefined)
                    this.spacing = init.spacing;
            }
        }
        set stretchMaxRatio(ratio) {
            this.container.stretchMaxRatio = ratio;
        }
        set uniform(uniform) {
            this.container.uniform = uniform;
        }
        set uniformRatio(uniformRatio) {
            this.container.uniformRatio = uniformRatio;
        }
        set itemAlign(align) {
            this.container.itemAlign = align;
        }
        set spacing(spacing) {
            this.container.spacing = spacing;
        }
    }
    Ui.SFlowDropBox = SFlowDropBox;
    class VDropBox extends DropAtBox {
        constructor(init) {
            super(new Ui.VBox().assign({ spacing: init && init.spacing ? init.spacing : 0 }), init);
            this.setMarkerOrientation('vertical');
        }
        set uniform(uniform) {
            this.container.uniform = uniform;
        }
        set spacing(spacing) {
            this.container.spacing = spacing;
        }
    }
    Ui.VDropBox = VDropBox;
    class HDropBox extends DropAtBox {
        constructor(init) {
            super(new Ui.HBox(), init);
            this.setMarkerOrientation('horizontal');
        }
        set uniform(uniform) {
            this.container.uniform = uniform;
        }
        set spacing(spacing) {
            this.container.spacing = spacing;
        }
    }
    Ui.HDropBox = HDropBox;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class SegmentBar extends Ui.LBox {
        constructor(init) {
            super(init);
            this._field = 'text';
            this._iconField = 'icon';
            this._orientation = 'horizontal';
            this.changed = new Core.Events();
            this.onSegmentSelect = (event) => {
                this._current = event.target;
                this.onStyleChange();
                this.changed.fire({ target: this, value: event.target.data });
            };
            this.focusable = true;
            this.border = new Ui.Frame();
            this.append(this.border);
            this.box = new Ui.Box({ uniform: true, margin: 1, spacing: 1, orientation: this._orientation });
            this.append(this.box);
            this.focused.connect(() => this.onStyleChange());
            this.blurred.connect(() => this.onStyleChange());
            this.drawing.addEventListener('keydown', (e) => this.onKeyDown(e));
            if (init) {
                if (init.orientation !== undefined)
                    this.orientation = init.orientation;
                if (init.field !== undefined)
                    this.field = init.field;
                if (init.iconField !== undefined)
                    this.iconField = init.iconField;
                if (init.data !== undefined)
                    this.data = init.data;
                if (init.currentPosition !== undefined)
                    this.currentPosition = init.currentPosition;
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        set orientation(orientation) {
            this._orientation = orientation;
            this.box.orientation = orientation;
        }
        set field(field) {
            this._field = field;
        }
        set iconField(iconField) {
            this._iconField = iconField;
        }
        set data(data) {
            let pos = this.currentPosition;
            while (this.box.firstChild !== undefined) {
                this.box.firstChild.pressed.disconnect(this.onSegmentSelect);
                this.box.remove(this.box.firstChild);
            }
            this._data = data;
            for (let i = 0; i < data.length; i++) {
                let mode;
                if (this._orientation === 'horizontal')
                    mode = (i === 0) ? 'left' : (i === data.length - 1) ? 'right' : 'middle';
                else
                    mode = (i === 0) ? 'top' : (i === data.length - 1) ? 'bottom' : 'middle';
                let segment = new Ui.SegmentButton({ data: data[i], text: data[i][this._field], iconText: data[i][this._iconField], mode: mode });
                this.box.append(segment, true);
                segment.pressed.connect(this.onSegmentSelect);
            }
            this.currentPosition = Math.max(0, Math.min(pos, this.box.children.length - 1));
        }
        get data() {
            let data = [];
            for (let i = 0; i < this.logicalChildren.length; i++) {
                data.push(this.logicalChildren[i].data);
            }
            return data;
        }
        set currentPosition(position) {
            if ((position >= 0) && (position < this.box.children.length)) {
                this._current = this.box.children[position];
                this.onSegmentSelect({ target: this._current });
            }
        }
        get currentPosition() {
            for (let i = 0; i < this.box.children.length; i++) {
                if (this.box.children[i] === this._current)
                    return i;
            }
            return -1;
        }
        get logicalChildren() {
            return this.box.children;
        }
        get current() {
            return this._current;
        }
        next() {
            for (let i = 0; i < this.box.children.length; i++) {
                if (this.box.children[i] === this._current) {
                    this.currentPosition = i + 1;
                    break;
                }
            }
        }
        previous() {
            for (let i = 0; i < this.box.children.length; i++) {
                if (this.box.children[i] === this._current) {
                    this.currentPosition = i - 1;
                    break;
                }
            }
        }
        onKeyDown(event) {
            if (this.isDisabled)
                return;
            let key = event.which;
            if ((key == 37) || (key == 39)) {
                event.stopPropagation();
                event.preventDefault();
            }
            if (key == 37)
                this.previous();
            else if (key == 39)
                this.next();
        }
        onStyleChange() {
            let spacing = this.getStyleProperty('spacing');
            let padding = this.getStyleProperty('padding');
            let radius = this.getStyleProperty('radius');
            let borderWidth = this.getStyleProperty('borderWidth');
            this.border.radius = radius;
            this.border.frameWidth = borderWidth;
            let background = this.getStyleProperty('background');
            let backgroundBorder = this.getStyleProperty('backgroundBorder');
            let backgroundMode = this.getStyleProperty('backgroundMode');
            let backgroundSize = this.getStyleProperty('backgroundSize');
            let foreground = this.getStyleProperty('foreground');
            if (this.hasFocus && !this.getIsMouseFocus()) {
                background = this.getStyleProperty('focusBackground');
                backgroundBorder = this.getStyleProperty('focusBackgroundBorder');
                foreground = this.getStyleProperty('focusForeground');
            }
            let activeBackground = this.getStyleProperty('activeBackground');
            let activeForeground = this.getStyleProperty('activeForeground');
            let textHeight = this.getStyleProperty('textHeight');
            let textTransform = this.getStyleProperty('textTransform');
            this.box.spacing = spacing;
            this.box.margin = borderWidth;
            this.border.fill = backgroundBorder;
            for (let i = 0; i < this.box.children.length; i++) {
                let child = this.box.children[i];
                child.radius = Math.max(0, radius - borderWidth);
                child.spacing = padding - borderWidth;
                child.boxHeight = textHeight;
                child.textTransform = textTransform;
                if (this._current === child) {
                    child.background = activeBackground;
                    child.foreground = activeForeground;
                }
                else {
                    child.background = background;
                    child.foreground = foreground;
                }
                child.backgroundMode = backgroundMode;
                if (backgroundSize != undefined) {
                    if (backgroundMode == 'top' || backgroundMode == 'bottom')
                        child.backgroundHeight = backgroundSize;
                    if (backgroundMode == 'left' || backgroundMode == 'right')
                        child.backgroundWidth = backgroundSize;
                }
            }
        }
    }
    SegmentBar.style = {
        borderWidth: 1,
        background: 'rgba(240,240,240,1)',
        backgroundBorder: 'rgba(102,102,102,1)',
        backgroundMode: 'stretch',
        backgroundSize: 5,
        foreground: '#444444',
        focusBackground: 'rgba(240,240,240,1)',
        focusBackgroundBorder: '#07a0e5',
        focusForeground: '#07a0e5',
        activeBackground: '#07a0e5',
        activeForeground: 'rgba(250,250,250,1)',
        radius: 3,
        textHeight: 26,
        spacing: 0,
        padding: 7,
        textTransform: 'uppercase'
    };
    Ui.SegmentBar = SegmentBar;
    class SegmentButton extends Ui.Pressable {
        constructor(init) {
            super(init);
            this._radius = 3;
            this.focusable = false;
            this.bg = new Ui.Rectangle();
            this.append(this.bg);
            this.box = new Ui.HBox({ spacing: 8, horizontalAlign: 'center' });
            this.append(this.box);
            this.icon = new Ui.Icon({ width: 24, height: 24, verticalAlign: 'center', horizontalAlign: 'center' });
            this.icon.hide(true);
            this.label = new Ui.CompactLabel({ whiteSpace: 'nowrap', verticalAlign: 'center' });
            this.label.hide(true);
            this.box.append(this.icon);
            this.box.append(this.label);
            if (init) {
                if (init.textTransform !== undefined)
                    this.textTransform = init.textTransform;
                if (init.foreground !== undefined)
                    this.foreground = init.foreground;
                if (init.data !== undefined)
                    this.data = init.data;
                if (init.text !== undefined)
                    this.text = init.text;
                if (init.iconText !== undefined)
                    this.iconText = init.iconText;
                if (init.boxHeight !== undefined)
                    this.boxHeight = init.boxHeight;
                if (init.mode !== undefined)
                    this.mode = init.mode;
                if (init.radius !== undefined)
                    this.radius = init.radius;
                if (init.spacing !== undefined)
                    this.spacing = init.spacing;
                if (init.background !== undefined)
                    this.background = init.background;
            }
        }
        set textTransform(textTransform) {
            this.label.textTransform = textTransform;
        }
        set foreground(color) {
            this.label.color = Ui.Color.create(color);
            this.icon.fill = Ui.Color.create(color);
        }
        get data() {
            return this._data;
        }
        set data(data) {
            this._data = data;
        }
        set text(text) {
            this.label.text = text;
            this.label.show();
        }
        set iconText(icon) {
            this.icon.icon = icon;
            this.icon.show();
        }
        set boxHeight(height) {
            this.box.height = height;
        }
        set mode(mode) {
            this._mode = mode;
            if (mode == 'left') {
                this.bg.radiusTopLeft = this._radius;
                this.bg.radiusBottomLeft = this._radius;
                this.bg.radiusTopRight = 0;
                this.bg.radiusBottomRight = 0;
            }
            else if (mode == 'right') {
                this.bg.radiusTopLeft = 0;
                this.bg.radiusBottomLeft = 0;
                this.bg.radiusTopRight = this._radius;
                this.bg.radiusBottomRight = this._radius;
            }
            else if (mode == 'top') {
                this.bg.radiusTopLeft = this._radius;
                this.bg.radiusBottomLeft = 0;
                this.bg.radiusTopRight = this._radius;
                this.bg.radiusBottomRight = 0;
            }
            else if (mode == 'bottom') {
                this.bg.radiusTopLeft = 0;
                this.bg.radiusBottomLeft = this._radius;
                this.bg.radiusTopRight = 0;
                this.bg.radiusBottomRight = this._radius;
            }
            else {
                this.bg.radiusTopLeft = 0;
                this.bg.radiusBottomLeft = 0;
                this.bg.radiusTopRight = 0;
                this.bg.radiusBottomRight = 0;
            }
        }
        set radius(radius) {
            this._radius = radius;
            this.mode = this._mode;
        }
        set spacing(spacing) {
            this.box.margin = spacing;
        }
        set background(color) {
            this.bg.fill = color;
        }
        set backgroundMode(mode) {
            if (mode == 'top' || mode == 'bottom') {
                this.bg.horizontalAlign = 'stretch';
                this.bg.verticalAlign = mode;
            }
            else if (mode == 'left' || mode == 'right') {
                this.bg.horizontalAlign = mode;
                this.bg.verticalAlign = 'stretch';
            }
            else {
                this.bg.horizontalAlign = 'stretch';
                this.bg.verticalAlign = 'stretch';
            }
        }
        set backgroundWidth(width) {
            this.bg.width = width;
        }
        set backgroundHeight(height) {
            this.bg.height = height;
        }
        get isTextVisible() {
            return ((this.label.text !== undefined) && (this.getStyleProperty('showText')));
        }
        onStyleChange() {
            super.onStyleChange();
            if (this.isTextVisible) {
                this.label.show();
                this.title = '';
            }
            else {
                this.label.hide(true);
                this.title = this.label.text;
            }
        }
        onDisable() {
            super.onDisable();
            this.bg.opacity = 0.2;
        }
        onEnable() {
            super.onEnable();
            this.bg.opacity = 1;
        }
    }
    SegmentButton.style = {
        showText: true,
    };
    Ui.SegmentButton = SegmentButton;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Locator extends Ui.Container {
        constructor(init) {
            super(init);
            this._path = '';
            this.changed = new Core.Events();
            this.path = '';
            this.focused.connect(() => this.updateColors());
            this.blurred.connect(() => this.updateColors());
            if (init) {
                if (init.path !== undefined)
                    this.path = init.path;
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        set path(path) {
            let spacing = this.getStyleProperty('spacing');
            let radius = this.getStyleProperty('radius');
            let padding = this.getStyleProperty('padding');
            this._path = path;
            while (this.children.length > 0)
                this.removeChild(this.children[0]);
            this.border = new Ui.Rectangle({ fill: '#888888', radius: radius });
            this.appendChild(this.border);
            this.backgrounds = [];
            this.foregrounds = [];
            if (path == '/') {
                let bg = new Ui.Rectangle({ radius: radius - 1 });
                this.backgrounds.push(bg);
                this.appendChild(bg);
                let fg = new Ui.Pressable({
                    padding: padding,
                    onpressed: e => this.onPathPress(fg),
                    ondowned: e => this.onPathDown(fg),
                    onupped: e => this.onPathUp(fg),
                    onfocused: e => this.onPathFocus(fg),
                    onblurred: e => this.onPathBlur(fg)
                });
                fg.locatorPath = '/';
                fg.locatorPos = 0;
                let home = new Ui.Icon({
                    icon: 'home', width: 24, height: 24,
                    verticalAlign: 'center', horizontalAlign: 'center'
                });
                fg.appendChild(home);
                this.foregrounds.push(fg);
                this.appendChild(fg);
            }
            else {
                let paths = path.split('/');
                let cleanPaths = new Array();
                for (let i = 0; i < paths.length; i++) {
                    if (paths[i] !== '')
                        cleanPaths.push(paths[i]);
                }
                paths = cleanPaths;
                let bg = new LocatorRightArrow({ arrowLength: spacing, radius: radius - 1 });
                this.backgrounds.push(bg);
                this.appendChild(bg);
                for (let i = 0; i < paths.length; i++) {
                    let bg;
                    if (i == paths.length - 1)
                        bg = new LocatorLeftArrow({ arrowLength: spacing, radius: radius - 1 });
                    else
                        bg = new LocatorLeftRightArrow({ arrowLength: spacing });
                    this.backgrounds.push(bg);
                    this.appendChild(bg);
                }
                let currentPath = '/';
                let fg = new Ui.Pressable({
                    padding: padding,
                    onpressed: e => this.onPathPress(fg),
                    ondowned: e => this.onPathDown(fg),
                    onupped: e => this.onPathUp(fg),
                    onfocused: e => this.onPathFocus(fg),
                    onblurred: e => this.onPathBlur(fg)
                });
                let home = new Ui.Icon({ icon: 'home', width: 24, height: 24 });
                home.verticalAlign = 'center';
                home.horizontalAlign = 'center';
                fg.locatorPos = 0;
                fg.locatorPath = '/';
                fg.appendChild(home);
                this.foregrounds.push(fg);
                this.appendChild(fg);
                for (let i = 0; i < paths.length; i++) {
                    currentPath += paths[i];
                    let fg = new Ui.Pressable({
                        padding: padding,
                        onpressed: e => this.onPathPress(fg),
                        ondowned: e => this.onPathDown(fg),
                        onupped: e => this.onPathUp(fg),
                        onfocused: e => this.onPathFocus(fg),
                        onblurred: e => this.onPathBlur(fg)
                    });
                    fg.locatorPos = i + 1;
                    fg.locatorPath = currentPath;
                    fg.appendChild(new Ui.Label({ text: paths[i], verticalAlign: 'center' }));
                    this.foregrounds.push(fg);
                    this.appendChild(fg);
                    currentPath += '/';
                }
            }
            this.updateColors();
        }
        get path() {
            return this._path;
        }
        getBackground() {
            return Ui.Color.create(this.getStyleProperty('background'));
        }
        getLightColor() {
            let yuv = this.getBackground().getYuv();
            let deltaY = 0;
            if (yuv.y < 0.4)
                return Ui.Color.createFromYuv(yuv.y - 0.15 + deltaY, yuv.u, yuv.v);
            else
                return Ui.Color.createFromYuv(yuv.y + 0.15 + deltaY, yuv.u, yuv.v);
        }
        getBackgroundBorder() {
            let color;
            if ((this.focusedPart !== undefined) && !this.focusedPart.getIsMouseFocus())
                color = Ui.Color.create(this.getStyleProperty('focusBackgroundBorder'));
            else
                color = Ui.Color.create(this.getStyleProperty('backgroundBorder'));
            let yuv = color.getYuva();
            let deltaY = 0;
            return Ui.Color.createFromYuv(yuv.y + deltaY, yuv.u, yuv.v, yuv.a);
        }
        getDownColor() {
            let yuv = this.getBackground().getYuv();
            let deltaY = -0.20;
            if (yuv.y < 0.4)
                return Ui.Color.createFromYuv(yuv.y - 0.15 + deltaY, yuv.u, yuv.v);
            else
                return Ui.Color.createFromYuv(yuv.y + 0.15 + deltaY, yuv.u, yuv.v);
        }
        onPathPress(pathItem) {
            this.changed.fire({ target: this, path: pathItem.locatorPath, position: pathItem.locatorPos });
        }
        onPathDown(pathItem) {
            this.backgrounds[pathItem.locatorPos].fill = this.getDownColor();
        }
        onPathUp(pathItem) {
            this.backgrounds[pathItem.locatorPos].fill = this.getLightColor();
        }
        onPathFocus(pressable) {
            this.focusedPart = pressable;
            this.updateColors();
        }
        onPathBlur(pressable) {
            this.focusedPart = undefined;
            this.updateColors();
        }
        updateColors() {
            let backgroundColor = this.getBackground();
            let focusBackgroundColor = Ui.Color.create(this.getStyleProperty('focusBackground'));
            this.border.fill = this.getBackgroundBorder();
            let focusPos = -1;
            if (this.focusedPart !== undefined) {
                for (let i = 0; (focusPos === -1) && (i < this.foregrounds.length); i++)
                    if (this.foregrounds[i] === this.focusedPart)
                        focusPos = i;
            }
            for (let i = 0; i < this.backgrounds.length; i++) {
                if (i === focusPos)
                    this.backgrounds[i].fill = focusBackgroundColor;
                else
                    this.backgrounds[i].fill = backgroundColor;
            }
        }
        measureCore(width, height) {
            console.log('locator.measureCore ');
            console.log(this.foregrounds);
            if (this.foregrounds.length === 0)
                return { width: 0, height: 0 };
            let i;
            for (i = 0; i < this.foregrounds.length; i++)
                this.foregrounds[i].measure(0, 0);
            for (i = 0; i < this.backgrounds.length; i++)
                this.backgrounds[i].measure(0, 0);
            this.border.measure(0, 0);
            if (this.foregrounds.length == 1)
                return { width: this.foregrounds[0].measureWidth + 2, height: this.foregrounds[0].measureHeight + 2 };
            else {
                let minWidth = 0;
                let minHeight = 0;
                for (i = 0; i < this.foregrounds.length; i++) {
                    let child = this.foregrounds[i];
                    if (child.measureHeight > minHeight)
                        minHeight = child.measureHeight;
                    minWidth += child.measureWidth;
                }
                let spacing = this.getStyleProperty('spacing');
                let borderWidth = this.getStyleProperty('borderWidth');
                minWidth += (this.foregrounds.length - 1) * (spacing + borderWidth);
                return { width: minWidth + (2 * borderWidth), height: minHeight + (2 * borderWidth) };
            }
        }
        arrangeCore(width, height) {
            let borderWidth = this.getStyleProperty('borderWidth');
            if (this.foregrounds.length == 1) {
                this.foregrounds[0].arrange(borderWidth, borderWidth, width - 2 * borderWidth, height - 2 * borderWidth);
                this.backgrounds[0].arrange(borderWidth, borderWidth, width - 2 * borderWidth, height - 2 * borderWidth);
                this.border.arrange(0, 0, width, height);
                return;
            }
            let spacing = this.getStyleProperty('spacing');
            let x = borderWidth;
            for (let i = 0; i < this.foregrounds.length; i++) {
                let bg = this.backgrounds[i];
                let fg = this.foregrounds[i];
                let fgWidth = fg.measureWidth;
                fg.arrange(x + 1, 0 + borderWidth, fgWidth, height - 2 * borderWidth);
                if (i === 0)
                    bg.arrange(x, 0 + borderWidth, fgWidth + spacing, height - 2 * borderWidth);
                else if (i == this.foregrounds.length - 1)
                    bg.arrange(x - spacing, 0 + borderWidth, fgWidth + spacing, height - 2 * borderWidth);
                else
                    bg.arrange(x - spacing, 0 + borderWidth, fgWidth + spacing * 2, height - 2 * borderWidth);
                x += fgWidth + spacing + borderWidth;
            }
            this.border.arrange(0, 0, width, height);
        }
        onStyleChange() {
            let spacing = this.getStyleProperty('spacing');
            let padding = this.getStyleProperty('padding');
            let radius = this.getStyleProperty('radius');
            let borderWidth = this.getStyleProperty('borderWidth');
            for (let i = 0; i < this.backgrounds.length; i++) {
                let bg = this.backgrounds[i];
                if ('arrowLength' in bg)
                    bg.arrowLength = spacing;
                bg.radius = radius - borderWidth;
            }
            for (let i = 0; i < this.foregrounds.length; i++)
                this.foregrounds[i].padding = padding;
            this.border.radius = radius;
            this.updateColors();
        }
        onDisable() {
            super.onDisable();
            for (let i = 0; i < this.foregrounds.length; i++)
                this.foregrounds[i].opacity = 0.4;
        }
        onEnable() {
            super.onEnable();
            for (let i = 0; i < this.foregrounds.length; i++)
                this.foregrounds[i].opacity = 1;
        }
    }
    Locator.style = {
        background: 'rgba(250,250,250,1)',
        backgroundBorder: 'rgba(140,140,140,1)',
        focusBackground: '#07a0e5',
        focusBackgroundBorder: Ui.Color.createFromRgb(0.04, 0.43, 0.5),
        focusActiveBackgroundBorder: Ui.Color.createFromRgb(0.04, 0.43, 0.5),
        radius: 3,
        spacing: 10,
        padding: 8,
        borderWidth: 1
    };
    Ui.Locator = Locator;
    class LocatorRightArrow extends Ui.CanvasElement {
        constructor(config) {
            super();
            this._radius = 8;
            this._length = 10;
            this._fill = new Ui.Color();
        }
        set radius(radius) {
            this._radius = radius;
            this.invalidateArrange();
        }
        set arrowLength(length) {
            this._length = length;
            this.invalidateArrange();
        }
        set fill(color) {
            this._fill = Ui.Color.create(color);
            this.invalidateDraw();
        }
        updateCanvas(ctx) {
            let width = this.layoutWidth;
            let height = this.layoutHeight;
            let v1 = width - this._length;
            let v2 = height / 2;
            let v3 = height - this._radius;
            ctx.svgPath('M' + this._radius + ',0 L' + v1 + ',0 L' + width + ',' + v2 + ' L' + v1 + ',' + height + ' L' + this._radius + ',' + height + ' Q0,' + height + ' 0,' + v3 + ' L0,' + this._radius + ' Q0,0 ' + this._radius + ',0 z');
            ctx.fillStyle = this._fill.getCssRgba();
            ctx.fill();
        }
    }
    Ui.LocatorRightArrow = LocatorRightArrow;
    class LocatorLeftArrow extends Ui.Shape {
        constructor(init) {
            super(init);
            this._radius = 8;
            this._length = 10;
            if (init) {
                if (init.radius !== undefined)
                    this.radius = init.radius;
                if (init.arrowLength !== undefined)
                    this.arrowLength = init.arrowLength;
            }
        }
        set radius(radius) {
            this._radius = radius;
        }
        set arrowLength(length) {
            this._length = length;
            this.invalidateDraw();
        }
        arrangeCore(width, height) {
            super.arrangeCore(width, height);
            let v2 = width - this._radius;
            let v3 = height - this._radius;
            let v4 = height / 2;
            this.path = 'M0,0 L' + v2 + ',0 Q' + width + ',0 ' + width + ',' + this._radius + ' L' + width + ',' + v3 + ' Q' + width + ',' + height + ' ' + v2 + ',' + height + ' L0,' + height + ' L' + this._length + ',' + v4 + ' z';
        }
    }
    Ui.LocatorLeftArrow = LocatorLeftArrow;
    class LocatorLeftRightArrow extends Ui.Shape {
        constructor(init) {
            super(init);
            this._length = 10;
            if (init) {
                if (init.radius !== undefined)
                    this.radius = init.radius;
                if (init.arrowLength !== undefined)
                    this.arrowLength = init.arrowLength;
            }
        }
        set radius(radius) {
        }
        set arrowLength(length) {
            this._length = length;
            this.invalidateDraw();
        }
        arrangeCore(width, height) {
            super.arrangeCore(width, height);
            let v1 = width - this._length;
            let v2 = height / 2;
            this.path = 'M0,0 L' + v1 + ',0 L' + width + ',' + v2 + ' L' + v1 + ',' + height + ' L0,' + height + ' L' + this._length + ',' + v2 + ' z';
        }
    }
    Ui.LocatorLeftRightArrow = LocatorLeftRightArrow;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Carouselable extends Ui.MovableBase {
        constructor(init) {
            super(init);
            this.pos = 0;
            this.speed = 1;
            this._bufferingSize = 1;
            this.changed = new Core.Events();
            this.clipToBounds = true;
            this.focusable = true;
            this.moveVertical = false;
            this.items = [];
            this.activeItems = [];
            this._ease = new Anim.PowerEase({ mode: 'out' });
            this.downed.connect(e => this.onCarouselableDown());
            this.upped.connect(e => this.onCarouselableUp(e.target, e.speedX, e.speedY, e.deltaX, e.deltaY, e.cumulMove, e.abort));
            this.drawing.addEventListener('keydown', e => this.onKeyDown(e));
            new Ui.WheelWatcher({
                element: this,
                onchanged: (e) => this.onWheel(e)
            });
            if (init) {
                if (init.autoPlay)
                    this.autoPlay = init.autoPlay;
                if (init.bufferingSize)
                    this.bufferingSize = init.bufferingSize;
                if (init.content)
                    this.content = init.content;
                if (init.ease)
                    this.ease = init.ease;
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        set autoPlay(delay) {
            if (this.autoPlayDelay !== delay) {
                if (this.autoPlayTask !== undefined)
                    this.autoPlayTask.abort();
                this.autoPlayTask = undefined;
                this.autoPlayDelay = delay;
                this.startAutoPlay();
            }
        }
        stopAutoPlay() {
            if (this.autoPlayTask !== undefined) {
                this.autoPlayTask.abort();
                this.autoPlayTask = undefined;
            }
        }
        startAutoPlay() {
            if (this.autoPlayDelay !== undefined) {
                this.autoPlayTask = new Core.DelayedTask(this.autoPlayDelay, () => this.onAutoPlayTimeout());
            }
        }
        onAutoPlayTimeout() {
            if (this.currentPosition >= this.items.length - 1)
                this.setCurrentAt(0);
            else
                this.next();
            this.startAutoPlay();
        }
        get bufferingSize() {
            return this._bufferingSize;
        }
        set bufferingSize(size) {
            if (this._bufferingSize != size) {
                this._bufferingSize = size;
                this.updateItems();
            }
        }
        get logicalChildren() {
            return this.items;
        }
        get currentPosition() {
            if (this.alignClock !== undefined)
                return this.animNext;
            else
                return this.pos;
        }
        get current() {
            return this.items[this.currentPosition];
        }
        set current(value) {
            this.setCurrent(value);
        }
        setCurrentAt(position, noAnimation = false) {
            position = Math.min(2 * (this.items.length - 1), Math.max(0, position));
            if (noAnimation) {
                this.pos = position;
                this.setPosition(-this.pos * this.layoutWidth, undefined);
                this.onChange();
            }
            else
                this.startAnimation(2 * (this.pos - position), position);
        }
        setCurrent(current, noAnimation = false) {
            for (let i = 0; i < this.items.length; i++) {
                if (this.items[i] == current) {
                    this.setCurrentAt(i, noAnimation);
                    break;
                }
            }
        }
        next() {
            if (this.alignClock === undefined) {
                if (this.pos < this.items.length - 1)
                    this.startAnimation(-2, this.pos + 1);
            }
            else {
                if (this.animNext > this.pos)
                    this.startAnimation(-2 * (this.animNext + 1 - Math.floor(this.pos)), Math.min(this.animNext + 1, this.items.length - 1));
                else
                    this.startAnimation(-2, Math.min(Math.ceil(this.pos), this.items.length - 1));
            }
        }
        previous() {
            if (this.alignClock === undefined) {
                if (this.pos > 0)
                    this.startAnimation(2, this.pos - 1);
            }
            else {
                if (this.animNext < this.pos)
                    this.startAnimation(2 * (Math.floor(this.pos) - (this.animNext - 1)), Math.max(this.animNext - 1, 0));
                else
                    this.startAnimation(2, Math.floor(this.pos));
            }
        }
        get ease() {
            return this._ease;
        }
        set ease(ease) {
            this._ease = Anim.EasingFunction.create(ease);
        }
        set content(value) {
            while (this.logicalChildren.length > 0)
                this.remove(this.logicalChildren[0]);
            for (let el of value)
                this.append(el);
        }
        append(child) {
            this.items.push(child);
            this.onChange();
        }
        remove(child) {
            let i = 0;
            while ((i < this.items.length) && (this.items[i] !== child)) {
                i++;
            }
            if (i < this.items.length) {
                this.items.splice(i, 1);
                if ((this.pos < 0) || (this.pos > this.items.length - 1))
                    this.pos = Math.max(0, Math.min(this.pos, this.items.length - 1));
                if (this.alignClock !== undefined)
                    this.animNext = Math.max(0, Math.min(this.animNext, this.items.length - 1));
                this.setPosition(-this.pos * this.layoutWidth, undefined, true);
                this.onChange();
            }
        }
        insertAt(child, position) {
            if (position < 0)
                position = this.items.length + position;
            if (position < 0)
                position = 0;
            if (position >= this.items.length)
                position = this.items.length;
            this.items.splice(position, 0, child);
            this.onChange();
        }
        moveAt(child, position) {
            if (position < 0)
                position = this.items.length + position;
            if (position < 0)
                position = 0;
            if (position >= this.items.length)
                position = this.items.length;
            let i = 0;
            while ((i < this.items.length) && (this.items[i] != child)) {
                i++;
            }
            if (i < this.items.length) {
                this.items.splice(i, 1);
                this.items.splice(position, 0, child);
            }
            this.onChange();
        }
        onKeyDown(event) {
            if (this.isDisabled)
                return;
            let key = event.which;
            if ((key == 37) || (key == 39)) {
                event.stopPropagation();
                event.preventDefault();
                if (key == 37)
                    this.previous();
                else if (key == 39)
                    this.next();
            }
        }
        onWheel(event) {
            if (this.isDisabled)
                return;
            if (event.deltaX !== 0) {
                event.stopPropagation();
                if (event.deltaX < 0)
                    this.previous();
                else
                    this.next();
            }
        }
        onCarouselableDown() {
            this.stopAutoPlay();
            this.stopAnimation();
        }
        onCarouselableUp(el, speedX, speedY, deltaX, deltaY, cumulMove, abort) {
            let mod;
            if (abort === true) {
                mod = this.pos % 1;
                if (mod > 0.5)
                    speedX = -400;
                else
                    speedX = 400;
            }
            else {
                if (Math.abs(speedX) < 50) {
                    if ((deltaX > 0.2 * this.layoutWidth) || (Math.abs(deltaX) > 100)) {
                        if (deltaX < 0)
                            speedX = -400;
                        else
                            speedX = 400;
                    }
                    else {
                        mod = this.pos % 1;
                        if (mod > 0.5)
                            speedX = -400;
                        else
                            speedX = 400;
                    }
                }
            }
            if (Math.abs(speedX) < 800) {
                if (speedX < 0)
                    speedX = -800;
                else
                    speedX = 800;
            }
            if (speedX !== 0)
                this.startAnimation(speedX / this.layoutWidth);
            this.startAutoPlay();
        }
        onChange() {
            this.loadItems();
            this.updateItems();
            let current = this.current;
            if (current !== undefined)
                current.enable();
            let currentPosition = this.currentPosition;
            if ((this.lastPosition === undefined) || (this.lastPosition !== currentPosition)) {
                if ((this.lastPosition !== undefined) && (this.items[this.lastPosition] !== undefined))
                    this.items[this.lastPosition].disable();
                this.lastPosition = currentPosition;
                this.changed.fire({ target: this, position: currentPosition });
            }
        }
        onAlignTick(clock, progress, delta) {
            if (delta === 0)
                return;
            let relprogress = -(clock.time * this.speed) / (this.animNext - this.animStart);
            if (relprogress >= 1) {
                this.alignClock.stop();
                this.alignClock = undefined;
                relprogress = 1;
            }
            relprogress = this._ease.ease(relprogress);
            this.pos = (this.animStart + relprogress * (this.animNext - this.animStart));
            this.setPosition(-this.pos * this.layoutWidth, undefined);
            if (this.alignClock === undefined)
                this.onChange();
        }
        startAnimation(speed, next) {
            this.stopAnimation();
            this.speed = speed;
            this.animStart = this.pos;
            if (next === undefined) {
                if (this.speed < 0)
                    this.animNext = Math.ceil(this.animStart);
                else
                    this.animNext = Math.floor(this.animStart);
            }
            else
                this.animNext = next;
            if (this.animStart !== this.animNext) {
                this.alignClock = new Anim.Clock({
                    duration: 'forever', target: this,
                    ontimeupdate: e => this.onAlignTick(e.target, e.progress, e.deltaTick)
                });
                this.alignClock.begin();
            }
        }
        stopAnimation() {
            if (this.alignClock !== undefined) {
                this.alignClock.stop();
                this.alignClock = undefined;
            }
        }
        loadItems() {
            if (!this.isLoaded)
                return;
            let i;
            for (i = 0; i < this.activeItems.length; i++)
                this.activeItems[i].carouselableSeen = undefined;
            let newItems = [];
            for (i = Math.max(0, Math.floor(this.pos - this._bufferingSize)); i < Math.min(this.items.length, Math.floor(this.pos + 1 + this._bufferingSize)); i++) {
                let item = this.items[i];
                let active = false;
                for (let i2 = 0; !active && (i2 < this.activeItems.length); i2++) {
                    if (this.activeItems[i2] === item) {
                        active = true;
                        this.activeItems[i2].carouselableSeen = true;
                    }
                }
                newItems.push(item);
                if (!active) {
                    item.disable();
                    this.appendChild(item);
                }
            }
            for (i = 0; i < this.activeItems.length; i++) {
                if (!this.activeItems[i].carouselableSeen)
                    this.removeChild(this.activeItems[i]);
            }
            this.activeItems = newItems;
        }
        updateItems() {
            if (!this.isLoaded)
                return;
            let w = this.layoutWidth;
            let h = this.layoutHeight;
            for (let i = 0; i < this.activeItems.length; i++) {
                let item = this.activeItems[i];
                let ipos = -1;
                for (ipos = 0; (ipos < this.items.length) && (this.items[ipos] !== item); ipos++) { }
                if (ipos < this.items.length) {
                    item.measure(w, h);
                    item.arrange(0, 0, w, h);
                    item.transform = Ui.Matrix.createTranslate((ipos - this.pos) * w, 0);
                }
            }
        }
        onLoad() {
            super.onLoad();
            this.loadItems();
            this.updateItems();
            this.onChange();
        }
        onMove(x, y) {
            if (this.layoutWidth <= 0)
                return;
            this.pos = -x / this.layoutWidth;
            if ((this.pos < 0) || (this.pos > this.items.length - 1)) {
                this.pos = Math.max(0, Math.min(this.pos, this.items.length - 1));
                this.setPosition(-this.pos * this.layoutWidth);
            }
            this.updateItems();
        }
        measureCore(width, height) {
            let current = this.current;
            return current.measure(width, height);
        }
        arrangeCore(width, height) {
            this.setPosition(-this.pos * width, undefined);
        }
    }
    Ui.Carouselable = Carouselable;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Carousel extends Ui.Container {
        constructor(init) {
            super(init);
            this.showNext = false;
            this.showPrevious = false;
            this._alwaysShowArrows = false;
            this.changed = new Core.Events();
            this.focusable = true;
            new Ui.OverWatcher({
                element: this,
                onentered: () => this.onMouseEnter(),
                onleaved: () => this.onMouseLeave()
            });
            this.carouselable = new Ui.Carouselable();
            this.appendChild(this.carouselable);
            this.focused.connect(() => this.onCarouselableFocus());
            this.blurred.connect(() => this.onCarouselableBlur());
            this.carouselable.changed.connect(e => this.onCarouselableChange(e.target, e.position));
            this.buttonPrevious = new Ui.Pressable({
                horizontalAlign: 'left', verticalAlign: 'center', opacity: 0, focusable: false,
                onpressed: () => this.onPreviousPress()
            });
            this.buttonPrevious.drawing.style.backgroundColor = 'rgba(255,255,255,0.6)';
            this.buttonPreviousIcon = new Ui.Icon({ icon: 'arrowleft', width: 48, height: 48 });
            this.buttonPrevious.append(this.buttonPreviousIcon);
            this.appendChild(this.buttonPrevious);
            this.buttonNext = new Ui.Pressable({
                horizontalAlign: 'right', verticalAlign: 'center', opacity: 0, focusable: false,
                onpressed: () => this.onNextPress()
            });
            this.buttonNext.drawing.style.backgroundColor = 'rgba(255,255,255,0.6)';
            this.buttonNextIcon = new Ui.Icon({ icon: 'arrowright', width: 48, height: 48 });
            this.buttonNext.append(this.buttonNextIcon);
            this.appendChild(this.buttonNext);
            this.drawing.addEventListener('keydown', e => this.onKeyDown(e));
            if (init) {
                if (init.autoPlay)
                    this.autoPlay = init.autoPlay;
                if (init.bufferingSize)
                    this.bufferingSize = init.bufferingSize;
                if (init.content)
                    this.content = init.content;
                if (init.alwaysShowArrows)
                    this.alwaysShowArrows = init.alwaysShowArrows;
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        set autoPlay(delay) {
            this.carouselable.autoPlay = delay;
        }
        get alwaysShowArrows() {
            return this._alwaysShowArrows;
        }
        set alwaysShowArrows(value) {
            this._alwaysShowArrows = value;
            if (value)
                this.showArrows();
            else
                this.hideArrows();
        }
        next() {
            this.carouselable.next();
        }
        previous() {
            this.carouselable.previous();
        }
        get logicalChildren() {
            return this.carouselable.logicalChildren;
        }
        get currentPosition() {
            return this.carouselable.currentPosition;
        }
        get current() {
            return this.carouselable.current;
        }
        set current(value) {
            this.setCurrent(value);
        }
        setCurrentAt(position, noAnimation = false) {
            this.carouselable.setCurrentAt(position, noAnimation);
        }
        setCurrent(current, noAnimation = false) {
            this.carouselable.setCurrent(current, noAnimation);
        }
        get bufferingSize() {
            return this.carouselable.bufferingSize;
        }
        set bufferingSize(size) {
            this.carouselable.bufferingSize = size;
        }
        append(child) {
            this.carouselable.append(child);
        }
        remove(child) {
            this.carouselable.remove(child);
        }
        insertAt(child, pos) {
            this.carouselable.insertAt(child, pos);
        }
        moveAt(child, pos) {
            this.carouselable.moveAt(child, pos);
        }
        set content(content) {
            this.carouselable.content = content;
        }
        onCarouselableChange(carouselable, position) {
            this.showArrows();
            this.changed.fire({ target: this, position: position });
        }
        onCarouselableFocus() {
            this.showArrows();
        }
        onCarouselableBlur() {
            this.hideArrows();
        }
        onPreviousPress() {
            this.focus();
            this.previous();
        }
        onNextPress() {
            this.focus();
            this.next();
        }
        onMouseEnter() {
            this.showArrows();
            this.carouselable.stopAutoPlay();
        }
        onMouseOverMove() {
            this.showArrows();
        }
        onMouseLeave() {
            this.hideArrows();
            this.carouselable.startAutoPlay();
        }
        showArrows() {
            var pos = this.carouselable.currentPosition;
            var children = this.carouselable.logicalChildren;
            if (children.length > 0) {
                this.showPrevious = (pos > 0);
                this.showNext = (pos < children.length - 1);
            }
            else {
                this.showPrevious = false;
                this.showNext = false;
            }
            if (this.showClock === undefined) {
                this.showClock = new Anim.Clock({
                    duration: 'forever', target: this,
                    ontimeupdate: e => this.onShowTick(e.target, e.progress, e.deltaTick)
                });
                this.showClock.begin();
            }
        }
        hideArrows() {
            if (this.hideTimeout !== undefined) {
                this.hideTimeout.abort();
                this.hideTimeout = undefined;
            }
            if (this._alwaysShowArrows)
                return;
            this.showPrevious = false;
            this.showNext = false;
            if (this.showClock === undefined) {
                this.showClock = new Anim.Clock({
                    duration: 'forever', target: this,
                    ontimeupdate: e => this.onShowTick(e.target, e.progress, e.deltaTick)
                });
                this.showClock.begin();
            }
        }
        onShowTick(clock, progress, delta) {
            if (delta === 0)
                return;
            var opacity;
            var previousDone = false;
            if (this.showPrevious) {
                opacity = this.buttonPrevious.opacity;
                opacity = Math.min(opacity + delta, 1);
                this.buttonPrevious.opacity = opacity;
                if (opacity == 1)
                    previousDone = true;
            }
            else {
                opacity = this.buttonPrevious.opacity;
                opacity = Math.max(opacity - (delta * 2), 0);
                this.buttonPrevious.opacity = opacity;
                if (opacity === 0)
                    previousDone = true;
            }
            var nextDone = false;
            if (this.showNext) {
                opacity = this.buttonNext.opacity;
                opacity = Math.min(opacity + delta, 1);
                this.buttonNext.opacity = opacity;
                if (opacity == 1)
                    nextDone = true;
            }
            else {
                opacity = this.buttonNext.opacity;
                opacity = Math.max(opacity - (delta * 2), 0);
                this.buttonNext.opacity = opacity;
                if (opacity === 0)
                    nextDone = true;
            }
            if (previousDone && nextDone && this.showClock) {
                this.showClock.stop();
                this.showClock = undefined;
            }
        }
        onKeyDown(event) {
            if (this.hasFocus) {
                if (event.which == 39)
                    this.next();
                else if (event.which == 37)
                    this.previous();
            }
        }
        measureCore(width, height) {
            let minWidth = 0;
            let minHeight = 0;
            for (let i = 0; i < this.children.length; i++) {
                let child = this.children[i];
                let size = child.measure(width, height);
                if (size.width > minWidth)
                    minWidth = size.width;
                if (size.height > minHeight)
                    minHeight = size.height;
            }
            return { width: minWidth, height: minHeight };
        }
        arrangeCore(width, height) {
            for (let i = 0; i < this.children.length; i++)
                this.children[i].arrange(0, 0, width, height);
        }
        onStyleChange() {
            var color = this.getStyleProperty('focusColor');
            this.buttonPreviousIcon.fill = color;
            this.buttonNextIcon.fill = color;
        }
    }
    Carousel.style = {
        focusColor: '#21d3ff'
    };
    Ui.Carousel = Carousel;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class RichTextButton extends Ui.FlatButton {
    }
    RichTextButton.style = {
        borderWidth: 0,
        background: 'rgba(255,255,255,0)',
        activeBackground: 'rgba(255,255,255,0)'
    };
    Ui.RichTextButton = RichTextButton;
    class RichTextEditor extends Ui.LBox {
        constructor() {
            super();
            this._autoHideControls = false;
            this.controlsBox = new Ui.LBox();
            this._textHolder = new Ui.Text();
            this.bg = new Ui.TextBgGraphic();
            this.boldButton = new RichTextButton();
            this.italicButton = new RichTextButton();
            this.underlineButton = new RichTextButton();
            this.alignLeftButton = new RichTextButton();
            this.alignCenterButton = new RichTextButton();
            this.alignRightButton = new RichTextButton();
            this.insertOrderedListButton = new RichTextButton();
            this.insertUnorderedListButton = new RichTextButton();
            this.insertURLButton = new Ui.Button();
            this.quoteButton = new RichTextButton();
            this.changed = new Core.Events();
            this.link = new Core.Events();
            this.focusable = true;
            this.boldButton.assign({
                icon: 'format-bold', focusable: false, title: 'Mettre en gras',
                onpressed: () => {
                    document.execCommand('bold', false, undefined);
                    this.onAnchorChanged();
                }
            });
            this.italicButton.assign({
                icon: 'format-italic', focusable: false, title: 'Mettre en italique',
                onpressed: () => {
                    document.execCommand('italic', false, undefined);
                    this.onAnchorChanged();
                }
            });
            this.underlineButton.assign({
                icon: 'format-underline', focusable: false, title: 'Souligner',
                onpressed: () => {
                    document.execCommand('underline', false, undefined);
                    this.onAnchorChanged();
                }
            });
            this.alignLeftButton.assign({
                icon: 'format-align-left', focusable: false, title: 'Aligner à gauche',
                onpressed: () => {
                    document.execCommand('justifyLeft', false, undefined);
                    this.onAnchorChanged();
                }
            });
            this.alignCenterButton.assign({
                icon: 'format-align-center', focusable: false, title: 'Centrer',
                onpressed: () => {
                    document.execCommand('justifyCenter', false, undefined);
                    this.onAnchorChanged();
                }
            });
            this.alignRightButton.assign({
                icon: 'format-align-right', focusable: false, title: 'Aligner à droite',
                onpressed: () => {
                    document.execCommand('justifyRight', false, undefined);
                    this.onAnchorChanged();
                }
            });
            this.insertOrderedListButton.assign({
                icon: 'format-insert-ordered-list', focusable: false, title: 'Insérer une numérotation',
                onpressed: () => {
                    document.execCommand('insertOrderedList', false, undefined);
                    this.onAnchorChanged();
                }
            });
            this.insertUnorderedListButton.assign({
                icon: 'format-insert-unordered-list', focusable: false, title: 'Insérer des puces',
                onpressed: () => {
                    document.execCommand('insertUnorderedList', false, undefined);
                    this.onAnchorChanged();
                }
            });
            this.insertURLButton.assign({
                icon: 'format-insert-url', focusable: false,
                title: 'Insérer une URL',
                style: {
                    borderWidth: 0,
                    background: 'rgba(255,255,255,0)',
                    activeBackground: 'rgba(255,255,255,0)'
                },
                onpressed: () => {
                    const url = window.prompt("URL à insérer :");
                    if (url) {
                        document.execCommand('createLink', false, url);
                    }
                }
            });
            this.quoteButton.assign({
                icon: 'format-quote', focusable: false,
                title: 'Insérer une citation',
                style: {
                    borderWidth: 0,
                    background: 'rgba(255,255,255,0)',
                    activeBackground: 'rgba(255,255,255,0)'
                },
                onpressed: () => {
                    if (this.quoteButton.isActive) {
                        let sel = window.getSelection();
                        if (sel && sel.anchorNode)
                            Ui.ContentEditable.unwrapNode(sel.anchorNode);
                    }
                    else
                        document.execCommand('formatBlock', false, '<blockquote>');
                    this.onAnchorChanged();
                }
            });
            let controls = new Ui.HBox().assign({
                uniform: true, isDisabled: false,
                content: [
                    this.boldButton,
                    this.italicButton,
                    this.underlineButton,
                    this.insertOrderedListButton,
                    this.insertUnorderedListButton,
                    this.insertURLButton
                ]
            });
            let allowedTags = ['B', 'I', 'U', 'A', '#text', 'BR', 'OL', 'UL', 'LI', 'BLOCKQUOTE'];
            this._contentEditable = new Ui.ContentEditable().assign({
                margin: 10, interLine: 1.2, fontSize: 16,
                html: '', resizable: true,
                onfocused: () => this.bg.hasFocus = true,
                onblurred: () => this.bg.hasFocus = false,
                onanchorchanged: () => this.onAnchorChanged(),
                onselectionentered: () => {
                    controls.enable();
                    if (!this.isDisabled)
                        this.controlsBox.show();
                },
                onselectionleaved: () => {
                },
                onchanged: (e) => {
                    Ui.ContentEditable.filterHtmlContent(e.element, allowedTags);
                    this.changed.fire({ target: this });
                },
                onlink: (e) => this.link.fire({ target: this, ref: e.ref }),
                selectable: true
            });
            this._contentEditable.drawing.addEventListener('keydown', (e) => {
                if (e.ctrlKey) {
                    if (e.which == 66) {
                        document.execCommand('bold', false);
                        e.stopPropagation();
                        e.preventDefault();
                    }
                    else if (e.which == 73) {
                        document.execCommand('italic', false);
                        e.stopPropagation();
                        e.preventDefault();
                    }
                    else if (e.which == 85) {
                        document.execCommand('underline', false);
                        e.stopPropagation();
                        e.preventDefault();
                    }
                }
            }, { capture: true });
            this.focusInWatcher = new Ui.FocusInWatcher({
                element: this,
                onfocusin: () => {
                    controls.enable();
                    if (!this.isDisabled)
                        this.controlsBox.show();
                    this._textHolder.hide();
                    document.execCommand('defaultParagraphSeparator', false, 'br');
                },
                onfocusout: () => {
                    controls.disable();
                    if (this.autoHideControls)
                        this.controlsBox.hide(true);
                    this.showHideTextHolder();
                }
            });
            this.content = [
                this.bg,
                new Ui.VBox().assign({
                    margin: 1,
                    content: [
                        this.controlsBox.assign({
                            content: [
                                new Ui.Rectangle().assign({ fill: 'white', opacity: 0.2 }),
                                controls
                            ]
                        }),
                        new Ui.LBox().assign({
                            resizable: true,
                            content: [
                                this._textHolder.assign({
                                    textAlign: 'center',
                                    verticalAlign: 'center',
                                    opacity: 0.6
                                }),
                                this._contentEditable
                            ]
                        })
                    ]
                })
            ];
        }
        set onchanged(value) { this.changed.connect(value); }
        set onlink(value) { this.link.connect(value); }
        showHideTextHolder() {
            if (this.textHolder && this.textHolder != '' && (this.html == '' || this.html == '<br>') && !this.focusInWatcher.isFocusIn)
                this._textHolder.show();
            else
                this._textHolder.hide();
        }
        get html() {
            return this._contentEditable.html;
        }
        set html(html) {
            this._contentEditable.html = html;
            this.showHideTextHolder();
        }
        get text() {
            return this._contentEditable.text;
        }
        set text(text) {
            this._contentEditable.text = text;
            this.showHideTextHolder();
        }
        get textAlign() {
            return this._contentEditable.textAlign;
        }
        set textAlign(textAlign) {
            this._contentEditable.textAlign = textAlign;
        }
        get fontSize() {
            return this._contentEditable.fontSize;
        }
        set fontSize(fontSize) {
            this._contentEditable.fontSize = fontSize;
        }
        get fontFamily() {
            return this._contentEditable.fontFamily;
        }
        set fontFamily(fontFamily) {
            this._contentEditable.fontFamily = fontFamily;
        }
        get fontWeight() {
            return this._contentEditable.fontWeight;
        }
        set fontWeight(fontWeight) {
            this._contentEditable.fontWeight = fontWeight;
        }
        get interLine() {
            return this._contentEditable.interLine;
        }
        set interLine(interLine) {
            this._contentEditable.interLine = interLine;
        }
        get wordWrap() {
            return this._contentEditable.wordWrap;
        }
        set wordWrap(wordWrap) {
            this._contentEditable.wordWrap = wordWrap;
        }
        get whiteSpace() {
            return this._contentEditable.whiteSpace;
        }
        set whiteSpace(whiteSpace) {
            this._contentEditable.whiteSpace = whiteSpace;
        }
        get color() {
            return this._contentEditable.color;
        }
        set color(color) {
            this._contentEditable.color = color;
        }
        get textHolder() {
            return this._textHolder.text;
        }
        set textHolder(value) {
            this._textHolder.text = value;
            this.showHideTextHolder();
        }
        get isBackgroundVisible() {
            return this.bg.isVisible;
        }
        set isBackgroundVisible(value) {
            this.bg.isVisible = value;
        }
        get autoHideControls() {
            return this._autoHideControls;
        }
        set autoHideControls(value) {
            if (this._autoHideControls != value) {
                this._autoHideControls = value;
                if (!this.focusInWatcher.isFocusIn && value)
                    this.controlsBox.hide(true);
                else if (!value)
                    this.controlsBox.show();
            }
        }
        onAnchorChanged() {
            this.boldButton.isActive = document.queryCommandState('bold');
            this.italicButton.isActive = document.queryCommandState('italic');
            this.underlineButton.isActive = document.queryCommandState('underline');
            this.alignLeftButton.isActive = document.queryCommandState('justifyLeft');
            this.alignCenterButton.isActive = document.queryCommandState('justifyCenter');
            this.alignRightButton.isActive = document.queryCommandState('justifyRight');
            this.quoteButton.isActive = this._contentEditable.findTag('BLOCKQUOTE') != undefined;
            this.insertOrderedListButton.isActive = this._contentEditable.findTag('OL') != undefined;
            this.insertUnorderedListButton.isActive = this._contentEditable.findTag('UL') != undefined;
        }
    }
    Ui.RichTextEditor = RichTextEditor;
})(Ui || (Ui = {}));
Ui.Icon.register('format-bold', "M31.2 21.58c1.93-1.35 3.3-3.53 3.3-5.58 0-4.51-3.49-8-8-8h-12.5v28h14.08c4.19 0 7.42-3.4 7.42-7.58 0-3.04-1.73-5.63-4.3-6.84zm-11.2-8.58h6c1.66 0 3 1.34 3 3s-1.34 3-3 3h-6v-6zm7 18h-7v-6h7c1.66 0 3 1.34 3 3s-1.34 3-3 3z");
Ui.Icon.register('format-italic', "M20 8v6h4.43l-6.86 16h-5.57v6h16v-6h-4.43l6.86-16h5.57v-6z");
Ui.Icon.register('format-underline', "M24 34c6.63 0 12-5.37 12-12v-16h-5v16c0 3.87-3.13 7-7 7s-7-3.13-7-7v-16h-5v16c0 6.63 5.37 12 12 12zm-14 4v4h28v-4h-28z");
Ui.Icon.register('format-align-left', "M30 30h-24v4h24v-4zm0-16h-24v4h24v-4zm-24 12h36v-4h-36v4zm0 16h36v-4h-36v4zm0-36v4h36v-4h-36z");
Ui.Icon.register('format-align-right', "M6 42h36v-4h-36v4zm12-8h24v-4h-24v4zm-12-8h36v-4h-36v4zm12-8h24v-4h-24v4zm-12-12v4h36v-4h-36z");
Ui.Icon.register('format-align-center', "M14 30v4h20v-4h-20zm-8 12h36v-4h-36v4zm0-16h36v-4h-36v4zm8-12v4h20v-4h-20zm-8-8v4h36v-4h-36z");
Ui.Icon.register('format-insert-ordered-list', "M4 34h4v1h-2v2h2v1h-4v2h6v-8h-6v2zm2-18h2v-8h-4v2h2v6zm-2 6h3.6l-3.6 4.2v1.8h6v-2h-3.6l3.6-4.2v-1.8h-6v2zm10-12v4h28v-4h-28zm0 28h28v-4h-28v4zm0-12h28v-4h-28v4z");
Ui.Icon.register('format-insert-unordered-list', "M8 21c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zm0-12c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zm0 24.33c-1.47 0-2.67 1.19-2.67 2.67s1.2 2.67 2.67 2.67 2.67-1.19 2.67-2.67-1.2-2.67-2.67-2.67zm6 4.67h28v-4h-28v4zm0-12h28v-4h-28v4zm0-16v4h28v-4h-28z");
Ui.Icon.register('format-insert-image', "M42 38v-28c0-2.21-1.79-4-4-4h-28c-2.21 0-4 1.79-4 4v28c0 2.21 1.79 4 4 4h28c2.21 0 4-1.79 4-4zm-25-11l5 6.01 7-9.01 9 12h-28l7-9z");
Ui.Icon.register('format-insert-url', "M7.8 24c0-3.42 2.78-6.2 6.2-6.2h8v-3.8h-8c-5.52 0-10 4.48-10 10s4.48 10 10 10h8v-3.8h-8c-3.42 0-6.2-2.78-6.2-6.2zm8.2 2h16v-4h-16v4zm18-12h-8v3.8h8c3.42 0 6.2 2.78 6.2 6.2s-2.78 6.2-6.2 6.2h-8v3.8h8c5.52 0 10-4.48 10-10s-4.48-10-10-10z");
Ui.Icon.register('format-quote', "M12 34h6l4-8v-12h-12v12h6zm16 0h6l4-8v-12h-12v12h6z");
var Ui;
(function (Ui) {
    class RadioBoxGraphic extends Ui.CanvasElement {
        constructor() {
            super();
            this._isDown = false;
            this._isChecked = false;
            this._borderWidth = 2;
        }
        get isDown() {
            return this._isDown;
        }
        set isDown(isDown) {
            if (this.isDown != isDown) {
                this._isDown = isDown;
                this.invalidateDraw();
            }
        }
        get isChecked() {
            return this._isChecked;
        }
        set isChecked(isChecked) {
            if (this.isChecked != isChecked) {
                this._isChecked = isChecked;
                this.invalidateDraw();
            }
        }
        get color() {
            if (this._color)
                return this._color;
            return Ui.Color.create(this.getStyleProperty('color'));
        }
        set color(color) {
            if (this.color !== color) {
                this._color = Ui.Color.create(color);
                this.invalidateDraw();
            }
        }
        set borderWidth(borderWidth) {
            if (this._borderWidth !== borderWidth) {
                this._borderWidth = borderWidth;
                this.invalidateDraw();
            }
        }
        get borderWidth() { return this._borderWidth; }
        set activeColor(color) {
            if (this.activeColor !== color) {
                this._activeColor = Ui.Color.create(color);
                this.invalidateDraw();
            }
        }
        get activeColor() {
            let color = this._activeColor ? this._activeColor : Ui.Color.create(this.getStyleProperty('activeColor'));
            let deltaY = 0;
            if (this.isDown)
                deltaY = 0.20;
            let yuv = color.getYuv();
            return Ui.Color.createFromYuv(yuv.y + deltaY, yuv.u, yuv.v);
        }
        updateCanvas(ctx) {
            let w = this.layoutWidth;
            let h = this.layoutHeight;
            let cx = w / 2;
            let cy = h / 2;
            let radius = Math.min(cx - 5, cy - 5);
            radius = Math.min(radius, 10);
            radius -= 1;
            if (this.isDown)
                ctx.globalAlpha = 0.8;
            if (this.isDisabled)
                ctx.globalAlpha = 0.4;
            ctx.strokeStyle = this.color.getCssRgba();
            ctx.lineWidth = this.borderWidth;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI, false);
            ctx.closePath();
            ctx.stroke();
            if (this.isChecked) {
                ctx.fillStyle = this.color.getCssRgba();
                ctx.beginPath();
                ctx.arc(cx, cy, radius / 2, 0, 2 * Math.PI, false);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }
        measureCore(width, height) {
            return { width: 30, height: 30 };
        }
        onDisable() {
            this.invalidateDraw();
        }
        onEnable() {
            this.invalidateDraw();
        }
        onStyleChange() {
            this.invalidateDraw();
        }
    }
    RadioBoxGraphic.style = {
        color: 'rgba(120,120,120,0.2)',
        activeColor: 'rgba(33,211,255,0.4)'
    };
    Ui.RadioBoxGraphic = RadioBoxGraphic;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class RadioBox extends Ui.Pressable {
        constructor(init) {
            super(init);
            this.bg = new Ui.SimpleButtonBackground();
            this._isToggled = false;
            this.changed = new Core.Events();
            this.toggled = new Core.Events();
            this.untoggled = new Core.Events();
            this.role = 'radio';
            this.drawing.setAttribute('aria-checked', 'false');
            this.append(this.bg.assign({
                radius: 0
            }));
            this.hbox = new Ui.HBox().assign({ margin: 2 });
            this.append(this.hbox);
            this.graphic = new Ui.RadioBoxGraphic();
            this.hbox.append(this.graphic);
            this.downed.connect(() => this.onRadioDown());
            this.upped.connect(() => this.onRadioUp());
            this.focused.connect(() => this.onRadioFocus());
            this.blurred.connect(() => this.onRadioBlur());
            this.pressed.connect(() => this.onRadioPress());
            if (init) {
                if (init.value !== undefined)
                    this.value = init.value;
                if (init.text !== undefined)
                    this.text = init.text;
                if (init.content !== undefined)
                    this.content = init.content;
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
                if (init.ontoggled)
                    this.toggled.connect(init.ontoggled);
                if (init.onuntoggled)
                    this.untoggled.connect(init.onuntoggled);
                if (init.group)
                    this.group = init.group;
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        set ontoggled(value) { this.toggled.connect(value); }
        set onuntoggled(value) { this.untoggled.connect(value); }
        get isToggled() {
            return this._isToggled;
        }
        get value() {
            return this.isToggled;
        }
        set value(value) {
            if (value)
                this.toggle();
            else
                this.untoggle();
        }
        get text() {
            return this._text;
        }
        set text(text) {
            if (text === undefined) {
                if (this.contentBox !== undefined) {
                    this.hbox.remove(this.contentBox);
                    this.contentBox = undefined;
                }
                this._text = undefined;
                this._content = undefined;
            }
            else {
                if (this._text !== undefined) {
                    this._text = text;
                    this.contentBox.text = this._text;
                }
                else {
                    if (this._content !== undefined) {
                        this.hbox.remove(this.contentBox);
                        this._content = undefined;
                    }
                    this._text = text;
                    this.contentBox = new Ui.Text({ margin: 8, text: this._text, verticalAlign: 'center' });
                    this.hbox.append(this.contentBox, true);
                }
            }
        }
        get content() {
            return this._content;
        }
        set content(content) {
            if (content === undefined) {
                if (this.contentBox !== undefined) {
                    this.hbox.remove(this.contentBox);
                    this.contentBox = undefined;
                }
                this._text = undefined;
                this._content = undefined;
            }
            else {
                if (this._text !== undefined) {
                    this.hbox.remove(this.contentBox);
                    this._text = undefined;
                }
                if (this._content !== undefined)
                    this.contentBox.remove(this._content);
                else {
                    this.contentBox = new Ui.LBox({ padding: 8, verticalAlign: 'center' });
                    this.hbox.append(this.contentBox);
                }
                this._content = content;
                this.contentBox.append(this._content);
            }
        }
        get group() {
            return this._group;
        }
        set group(group) {
            if (this.group != group) {
                if (this.group)
                    this.group.remove(this);
                this._group = group;
                group.add(this);
            }
        }
        toggle() {
            this.onToggle();
        }
        untoggle() {
            this.onUntoggle();
        }
        onRadioPress() {
            if (!this._isToggled)
                this.onToggle();
        }
        onToggle() {
            if (!this._isToggled) {
                this._isToggled = true;
                this.drawing.setAttribute('aria-checked', 'true');
                this.toggled.fire({ target: this });
                this.graphic.isChecked = true;
                this.graphic.color = this.getStyleProperty('activeColor');
                this.changed.fire({ target: this, value: true });
            }
        }
        onUntoggle() {
            if (this._isToggled) {
                this._isToggled = false;
                this.drawing.setAttribute('aria-checked', 'false');
                this.untoggled.fire({ target: this });
                this.graphic.isChecked = false;
                this.graphic.color = this.getStyleProperty('color');
                this.changed.fire({ target: this, value: false });
            }
        }
        onRadioFocus() {
            if (!this.getIsMouseFocus()) {
                this.graphic.color = this.getStyleProperty('focusColor');
                this.bg.border = this.getStyleProperty('focusBackgroundBorder');
            }
        }
        onRadioBlur() {
            if (this._isToggled)
                this.graphic.color = this.getStyleProperty('activeColor');
            else
                this.graphic.color = this.getStyleProperty('color');
            this.bg.border = this.getStyleProperty('backgroundBorder');
        }
        onRadioDown() {
            this.graphic.isDown = true;
        }
        onRadioUp() {
            this.graphic.isDown = false;
        }
        onStyleChange() {
            if (this.hasFocus) {
                this.graphic.color = this.getStyleProperty('focusColor');
                this.bg.border = this.getStyleProperty('focusBackgroundBorder');
            }
            else {
                this.bg.border = this.getStyleProperty('backgroundBorder');
                if (this._isToggled)
                    this.graphic.color = this.getStyleProperty('activeColor');
                else
                    this.graphic.color = this.getStyleProperty('color');
            }
            this.graphic.activeColor = this.getStyleProperty('activeColor');
            this.graphic.borderWidth = this.getStyleProperty('radioWidth');
            this.bg.borderWidth = parseInt(this.getStyleProperty('borderWidth'));
            this.bg.background = this.getStyleProperty('background');
        }
    }
    RadioBox.style = {
        borderWidth: 0,
        radioWidth: 2,
        color: '#444444',
        activeColor: '#07a0e5',
        focusColor: '#21d3ff',
        checkColor: '#ffffff',
        background: 'rgba(250,250,250,0)',
        backgroundBorder: 'rgba(250,250,250,0)',
        focusBackgroundBorder: '#21d3ff'
    };
    Ui.RadioBox = RadioBox;
    class RadioGroup extends Core.Object {
        constructor() {
            super(...arguments);
            this.content = {};
            this.changed = new Core.Events();
        }
        set onchanged(value) { this.changed.connect(value); }
        get current() {
            return this._current;
        }
        set current(radio) {
            if (this.current == radio)
                return;
            if (radio && !radio.isToggled)
                radio.toggle();
            if (radio == undefined && this.current && this.current.isToggled)
                this.current.untoggle();
            this._current = radio;
            this.changed.fire({ target: this });
        }
        get children() {
            return Object.keys(this.content).map(prop => this.content[prop]);
        }
        add(radio) {
            if (Object.keys(this.content).map(prop => this.content[prop]).indexOf(radio) !== -1)
                return;
            let handler = radio.toggled.connect(e => this.onRadioSelected(e));
            this.content[handler] = radio;
        }
        remove(radio) {
            if (radio == undefined)
                return;
            let index = Object.keys(this.content).map(prop => this.content[prop]).indexOf(radio);
            if (index === -1)
                return;
            let realIndex = Number(Object.keys(this.content)[index]);
            radio.toggled.disconnect(realIndex);
            if (this.content[realIndex].isToggled)
                this.current = undefined;
            delete (this.content[realIndex]);
        }
        onRadioSelected(event) {
            if (this.current && this.current.isToggled)
                this.current.untoggle();
            this.current = event.target;
        }
    }
    Ui.RadioGroup = RadioGroup;
})(Ui || (Ui = {}));
var Ui;
(function (Ui) {
    class Embed extends Ui.Container {
        constructor(parent) {
            super();
            this.htmlParent = parent;
            this.drawing.style.position = 'relative';
            parent.appendChild(this.drawing);
            this.obs = new ResizeObserver(() => {
                this.updateLayout(parent.offsetWidth, parent.offsetHeight);
            });
            this.obs.observe(parent);
            this.isLoaded = true;
            this.updateLayout(parent.offsetWidth, parent.offsetHeight);
        }
        invalidateMeasure() {
            this.invalidateLayout();
        }
        invalidateArrange() {
            this.invalidateLayout();
            this.updateLayout(this.htmlParent.offsetWidth, this.htmlParent.offsetHeight);
        }
        updateLayout(width, height) {
            let size = this.measure(this.htmlParent.offsetWidth, this.htmlParent.offsetHeight);
            let layoutWidth = Math.max(size.width, this.htmlParent.offsetWidth);
            let layoutHeight = Math.max(size.height, this.htmlParent.offsetHeight);
            this.arrange(0, 0, layoutWidth, layoutHeight);
        }
        set content(element) {
            this.appendChild(element);
        }
        getInverseLayoutTransform() {
            let matrix = super.getInverseLayoutTransform();
            let current = this.htmlParent;
            while (current != null) {
                let elMatrix = Ui.Matrix.createTranslate(current.offsetLeft - current.scrollLeft, current.offsetTop - current.scrollTop);
                matrix = matrix.multiply(elMatrix);
                current = current.offsetParent;
            }
            matrix = matrix.multiply(Ui.Matrix.createTranslate(-document.documentElement.scrollLeft, -document.documentElement.scrollTop));
            return matrix;
        }
        measureCore(width, height) {
            let minWidth = 0;
            let minHeight = 0;
            for (let child of this.children) {
                let size = child.measure(width, height);
                if (size.width > minWidth)
                    minWidth = size.width;
                if (size.height > minHeight)
                    minHeight = size.height;
            }
            return { width: minWidth, height: minHeight };
        }
        arrangeCore(width, height) {
            for (let child of this.children)
                child.arrange(0, 0, width, height);
        }
    }
    Ui.Embed = Embed;
})(Ui || (Ui = {}));
var Form;
(function (Form) {
    class Field extends Ui.VBox {
        constructor(init) {
            super(init);
            this._required = false;
            this.flow = new Ui.Flow();
            this.changed = new Core.Events();
            this.validchanged = new Core.Events();
            this.margin = 5;
            this.spacing = 5;
            this.flow = new Ui.Flow();
            this.flow.hide(true);
            this.append(this.flow);
            this._title = new Ui.Text();
            this.flow.append(this._title);
            this._requiredText = new Ui.Html({
                color: 'red', html: '<label title="champs obligatoire">*</label>'
            });
            this._requiredText.hide(true);
            this.flow.append(this._requiredText);
            this.field = this.generateUi();
            if ('changed' in this.field && this.field['changed'] instanceof Core.Events)
                this.field['changed'].connect(() => {
                    this.onChange();
                    let value;
                    if ('value' in this.field)
                        value = this.field.value;
                    this.changed.fire({ target: this, value: value });
                });
            this.field.marginLeft = 10;
            this.append(this.field);
            this._desc = new Ui.Text({ fontSize: 12, marginLeft: 10 });
            this._desc.hide(true);
            this.append(this._desc);
            if (init) {
                if (init.title !== undefined)
                    this.title = init.title;
                if (init.desc !== undefined)
                    this.desc = init.desc;
                if (init.required !== undefined)
                    this.required = init.required;
                if (init.validate !== undefined)
                    this.validate = init.validate;
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
                if (init.onvalidchanged)
                    this.validchanged.connect(init.onvalidchanged);
            }
            this._lastIsValid = this.isValid;
        }
        set onchanged(value) { this.changed.connect(value); }
        ;
        set onvalidchanged(value) { this.validchanged.connect(value); }
        ;
        get isValid() {
            return this._errorMsg == undefined && (!this.required || this.isDefined);
        }
        set title(title) {
            this._title.text = title;
            this.flow.show();
        }
        set desc(value) {
            this._desc.text = value;
            this._descString = value;
            if (value != undefined)
                this._desc.show();
            else
                this._desc.hide(true);
        }
        get required() {
            return this._required;
        }
        set required(value) {
            if (this._required != value) {
                this._required = value;
                if (this._required && !this.isDisabled)
                    this._requiredText.show();
                else
                    this._requiredText.hide(true);
                this.checkIsValid();
            }
        }
        checkIsValid() {
            this.onChange();
        }
        async onValidate() {
            return (this.validate) ? await this.validate() : undefined;
        }
        async onChange() {
            let newErrorMsg;
            if (!this.isDefined) {
                newErrorMsg = undefined;
            }
            else {
                let validateTask = this.onValidate();
                this._validateTask = validateTask;
                newErrorMsg = await validateTask;
                if (this._validateTask != validateTask) {
                    return;
                }
            }
            this._validateTask = undefined;
            if (newErrorMsg) {
                this._desc.text = newErrorMsg;
                this._desc.color = 'red';
                this._desc.show();
            }
            else if (this._errorMsg != undefined) {
                this._desc.text = this._descString ? this._descString : '';
                this._desc.color = 'rgba(0,0,0,0.6)';
                if (!this._descString)
                    this._desc.hide(true);
            }
            this._errorMsg = newErrorMsg;
            let isValid = this.isValid;
            if (this._lastIsValid != isValid) {
                this._lastIsValid = isValid;
                this.validchanged.fire({ target: this, value: isValid });
            }
        }
        onDisable() {
            super.onDisable();
            this._requiredText.hide(true);
        }
        onEnable() {
            super.onEnable();
            if (this._required)
                this._requiredText.show();
        }
    }
    Form.Field = Field;
    class TextField extends Field {
        constructor(init) {
            super(init);
            if (init) {
                if (init.placeholder != undefined)
                    this.placeholder = init.placeholder;
                if (init.value != undefined)
                    this.value = init.value;
            }
        }
        generateUi() {
            return new Ui.TextField();
        }
        get isDefined() {
            return this.field.value != '';
        }
        get value() {
            return this.field.value;
        }
        set value(value) {
            this.field.value = value;
        }
        set placeholder(value) {
            this.field.textHolder = value;
        }
    }
    Form.TextField = TextField;
    class TextButtonField extends Field {
        constructor() {
            super();
            this.pressed = new Core.Events();
            this.field.buttonpressed.connect((e) => this.pressed.fire({ target: this }));
        }
        set onpressed(value) { this.pressed.connect(value); }
        generateUi() {
            return new Ui.TextButtonField();
        }
        get isDefined() {
            return this.field.value != '';
        }
        get value() {
            return this.field.value;
        }
        set value(value) {
            this.field.value = value;
        }
        set placeholder(value) {
            this.field.textHolder = value;
        }
        set icon(value) {
            this.field.buttonIcon = value;
        }
    }
    Form.TextButtonField = TextButtonField;
    class TextAreaField extends Field {
        constructor(init) {
            super(init);
            if (init) {
                if (init.placeholder != undefined)
                    this.placeholder = init.placeholder;
            }
        }
        generateUi() {
            return new Ui.TextAreaField();
        }
        get isDefined() {
            return this.field.value != '';
        }
        get value() {
            return this.field.value;
        }
        set value(value) {
            this.field.value = value;
        }
        set placeholder(value) {
            this.field.textHolder = value;
        }
    }
    Form.TextAreaField = TextAreaField;
    class DateField extends Field {
        constructor(init) {
            super(init);
            if (init) {
                if (init.placeholder !== undefined)
                    this.placeholder = init.placeholder;
                else
                    this.placeholder = 'jj/mm/aaaa';
                if (init.value)
                    this.value = init.value;
            }
        }
        generateUi() {
            return new Ui.DatePicker();
        }
        get isDefined() {
            return this.field.selectedDate != undefined;
        }
        get value() {
            return this.field.selectedDate;
        }
        set value(value) {
            this.field.selectedDate = value;
        }
        set placeholder(value) {
            this.field.textHolder = value;
        }
    }
    Form.DateField = DateField;
    class TimeField extends Field {
        constructor(init) {
            super(init);
            this.placeholder = 'hh:mm';
            this.validate = async () => {
                if (this.value != "" && !this.value.match(/^\d{1,2}:\d{1,2}$/))
                    return "Format attendu hh:mm";
                let parts = this.value.split(':');
                let hours = parseInt(parts[0]);
                let minutes = parseInt(parts[1]);
                if (hours < 0 || hours > 23)
                    return "Heure invalide";
                if (minutes < 0 || minutes > 59)
                    return "Minutes invalides";
            };
            if (init) {
                if (init.placeholder !== undefined)
                    this.placeholder = init.placeholder;
                if (init.value)
                    this.value = init.value;
            }
        }
        generateUi() {
            return new Ui.TextField();
        }
        get isDefined() {
            return this.field.value != undefined && this.field.value != '';
        }
        get value() {
            return this.field.value;
        }
        set value(value) {
            this.field.value = value;
        }
        get time() {
            if (this.value == "" || !this.value.match(/^\d{1,2}:\d{1,2}$/))
                return undefined;
            let parts = this.value.split(':');
            let hours = parseInt(parts[0]);
            if (hours < 0 || hours > 23)
                return undefined;
            let minutes = parseInt(parts[1]);
            if (minutes < 0 || minutes > 59)
                return undefined;
            return { hours: hours, minutes: minutes };
        }
        get hours() {
            let time = this.time;
            return (!time) ? undefined : time.hours;
        }
        get minutes() {
            let time = this.time;
            return (!time) ? undefined : time.minutes;
        }
        get totalSeconds() {
            let time = this.time;
            return (!time) ? undefined : time.hours * 3600 + time.minutes * 60;
        }
        set placeholder(value) {
            this.field.textHolder = value;
        }
    }
    Form.TimeField = TimeField;
    class SliderField extends Field {
        constructor(init) {
            super(init);
        }
        generateUi() {
            return new Ui.Slider();
        }
        get isDefined() {
            return true;
        }
        get value() {
            return this.field.value;
        }
        set value(value) {
            this.field.value = value;
        }
    }
    Form.SliderField = SliderField;
    class ComboField extends Field {
        constructor(init) {
            super(init);
            this._data = [];
            if (init) {
                if (init.text !== undefined)
                    this.text = init.text;
                if (init.key !== undefined)
                    this.key = init.key;
                if (init.search !== undefined)
                    this.search = init.search;
                if (init.placeholder !== undefined)
                    this.placeholder = init.placeholder;
                if (init.data !== undefined)
                    this.data = init.data;
                if (init.position !== undefined)
                    this.position = init.position;
                if (init.value !== undefined)
                    this.value = init.value;
                if (init.allowNone != undefined)
                    this.allowNone = init.allowNone;
            }
        }
        generateUi() {
            return new Ui.Combo();
        }
        get isDefined() {
            return this.field.position != -1;
        }
        set search(value) {
            this.field.search = value;
        }
        set key(key) {
            this.field.field = key;
        }
        get allowNone() {
            return this.field.allowNone;
        }
        set allowNone(value) {
            this.field.allowNone = value;
        }
        get data() {
            return this._data;
        }
        set data(data) {
            this._data = data;
            this.field.data = this._data;
        }
        set text(value) {
            this.field.text = value;
        }
        get value() {
            return this.field.value;
        }
        set value(value) {
            if (value) {
                let pos = this.data.indexOf(value);
                this.field.position = pos;
            }
            else
                this.field.position = -1;
        }
        set position(position) {
            this.field.position = position;
        }
        set placeholder(value) {
            this.field.placeHolder = value;
        }
    }
    Form.ComboField = ComboField;
    class CheckBoxField extends Field {
        constructor(init) {
            super(init);
            if (init) {
                if (init.value != undefined)
                    this.value = init.value;
                if (init.text != undefined)
                    this.text = init.text;
            }
        }
        generateUi() {
            return new Ui.CheckBox();
        }
        get isDefined() {
            return true;
        }
        get value() {
            return this.field.value;
        }
        set value(value) {
            this.field.value = value;
        }
        get text() {
            return this.field.text;
        }
        set text(value) {
            this.field.text = value;
        }
    }
    Form.CheckBoxField = CheckBoxField;
    class YesNoField extends Field {
        constructor(init) {
            super(init);
            if (init) {
                if (init.allowNone != undefined)
                    this.allowNone = init.allowNone;
                if (init.value != undefined)
                    this.value = init.value;
            }
        }
        generateUi() {
            return new Ui.Combo({
                field: 'name',
                data: [
                    { name: 'Oui', value: true },
                    { name: 'Non', value: false }
                ]
            });
        }
        get isDefined() {
            return this.field.value !== undefined && this.field.value.value !== undefined;
        }
        get value() {
            return this.field.value ? this.field.value.value : false;
        }
        set value(value) {
            this.field.position = value ? 0 : 1;
        }
        get allowNone() {
            return this.field.allowNone;
        }
        set allowNone(value) {
            this.field.allowNone = value;
        }
    }
    Form.YesNoField = YesNoField;
    class NumberField extends Field {
        constructor(init) {
            super(init);
            if (init) {
                if (init.value != undefined)
                    this.value = init.value;
            }
        }
        generateUi() {
            return new Ui.TextField().assign({ inputMode: 'numeric', type: 'number' });
        }
        get isDefined() {
            return this.field.value != '' && !isNaN(parseFloat(this.field.value));
        }
        get value() {
            return this.field.value == '' ? undefined : parseFloat(this.field.value);
        }
        set value(value) {
            this.field.value = value == undefined ? '' : value.toString();
        }
        set min(value) {
            this.field.entry.drawing.min = value.toString();
        }
        set max(value) {
            this.field.entry.drawing.max = value.toString();
        }
        set step(value) {
            this.field.entry.drawing.step = value.toString();
        }
        set placeholder(value) {
            this.field.textHolder = value;
        }
    }
    Form.NumberField = NumberField;
    class ColorField extends Field {
        constructor(init) {
            super(init);
            if (init) {
                if (init.value != undefined)
                    this.value = init.value;
            }
        }
        generateUi() {
            return new Ui.ColorButton();
        }
        get isDefined() {
            return true;
        }
        get value() {
            return this.field.value;
        }
        set value(value) {
            this.field.value = value;
        }
        get alpha() {
            return this.field.alpha;
        }
        set alpha(value) {
            this.field.alpha = value;
        }
        set palette(palette) {
            this.field.palette = palette.map(color => Ui.Color.create(color));
        }
        get palette() {
            return this.field.palette;
        }
    }
    Form.ColorField = ColorField;
})(Form || (Form = {}));
var Ui;
(function (Ui) {
    class CheckerBoard extends Ui.CanvasElement {
        constructor() {
            super();
            this._size = 10;
            this.clipToBounds = true;
        }
        get size() {
            return this._size;
        }
        set size(value) {
            if (value != this._size) {
                this._size = value;
                this.invalidateDraw();
            }
        }
        updateCanvas(ctx) {
            let nx = Math.ceil(this.layoutWidth / this.size);
            let ny = Math.ceil(this.layoutHeight / this.size);
            for (let y = 0; y < ny; y++) {
                for (let x = 0; x < nx; x++) {
                    ctx.fillStyle = (x + y) % 2 ? 'black' : '#999999';
                    ctx.fillRect(x * this.size, y * this.size, this.size, this.size);
                }
            }
        }
    }
    Ui.CheckerBoard = CheckerBoard;
    class ColorSlider extends Ui.Slider {
        updateColors() {
            this.bar.fill = 'rgba(0,0,0,0)';
            this.background.drawing.style.background = 'linear-gradient(to right, hsl(0, 100%, 50%), hsl(60,100%,50%), hsl(120, 100%, 50%), hsl(180, 100%, 50%), hsl(270, 100%, 50%), hsl(359, 100%, 50%))';
            this.buttonContent.fill = Ui.Color.createFromHsl(this.value * 360, 1, 0.5, 1);
        }
        updateValue() {
            super.updateValue();
            this.updateColors();
        }
    }
    Ui.ColorSlider = ColorSlider;
    class ColorChooser extends Ui.HBox {
        constructor(init) {
            super(init);
            this._value = new Ui.Color();
            this.hSlider = new ColorSlider();
            this.lock = false;
            this.alpha = false;
            this.changed = new Core.Events();
            this.spacing = 10;
            this.colorRect = new Ui.Rectangle({ width: 80, height: 80 });
            this.append(new Ui.LBox().assign({
                content: [
                    new CheckerBoard().assign({
                        opacity: 0.4
                    }),
                    this.colorRect
                ]
            }));
            let vbox = new Ui.VBox();
            this.append(vbox, true);
            vbox.append(new Ui.VBox().assign({
                content: [
                    new Ui.Text().assign({ text: 'Couleur' }),
                    this.hSlider.assign({
                        marginLeft: 10,
                        onchanged: () => this.sliderChanged()
                    })
                ]
            }));
            this.sSlider = new window.Form.SliderField({
                title: 'Saturation', onchanged: e => this.sliderChanged()
            });
            vbox.append(this.sSlider);
            this.lSlider = new window.Form.SliderField({
                title: 'Lumière', onchanged: e => this.sliderChanged()
            });
            vbox.append(this.lSlider);
            this.aSlider = new window.Form.SliderField({
                title: 'Transparence', onchanged: e => this.sliderChanged()
            });
            this.field = new window.Form.TextField({
                title: 'HTML', width: 200,
                onchanged: e => {
                    if (this.lock)
                        return;
                    try {
                        this.lock = true;
                        this._value = Ui.Color.parse(this.field.value);
                        this.updateColor();
                        this.updateSliders();
                        this.changed.fire({ target: this, value: this._value });
                    }
                    catch (e) { }
                    this.lock = false;
                }
            });
            vbox.append(this.field);
            if (init) {
                if (init.alpha) {
                    this.alpha = init.alpha;
                    vbox.insertBefore(this.aSlider, this.field);
                }
                if (init.value !== undefined)
                    this.value = init.value;
                if (init.onchanged)
                    this.changed.connect(init.onchanged);
            }
            if (!init || !init.value)
                this.value = 'black';
        }
        sliderChanged() {
            if (this.lock)
                return;
            let hsla = {
                h: this.hSlider.value * 360,
                s: this.sSlider.value,
                l: this.lSlider.value,
                a: this.aSlider.value
            };
            this._value = Ui.Color.createFromHsl(hsla.h, hsla.s, hsla.l, hsla.a);
            this.updateColor();
            this.updateField();
            this.changed.fire({ target: this, value: this._value });
        }
        updateColor() {
            this.colorRect.fill = this._value;
        }
        updateSliders() {
            let hsla = this._value.getHsla();
            this.hSlider.value = hsla.h / 360;
            this.sSlider.value = hsla.s;
            this.lSlider.value = hsla.l;
            this.aSlider.value = hsla.a;
        }
        updateField() {
            this.field.value = this._value.getCssHtml(this.alpha);
        }
        set value(value) {
            this.lock = true;
            try {
                this._value = Ui.Color.create(value);
                this.updateColor();
                this.updateSliders();
                this.updateField();
            }
            catch (e) { }
            this.lock = false;
        }
        get value() {
            return this._value;
        }
    }
    Ui.ColorChooser = ColorChooser;
    class ColorButton extends Ui.Button {
        constructor(init) {
            super(init);
            this.color = new Ui.Color();
            this.alpha = false;
            this.changed = new Core.Events();
            this.rect = new Ui.Rectangle({ verticalAlign: 'center' });
            this.value = new Ui.Color();
            this.setIconOrElement(new Ui.LBox().assign({
                content: [
                    new CheckerBoard().assign({
                        opacity: 0.4
                    }),
                    this.rect
                ]
            }));
            this.pressed.connect(() => this.onColorButtonPress());
            this.palette = new Array();
            if (init) {
                if (init.value !== undefined)
                    this.value = init.value;
                if (init.palette !== undefined)
                    this.palette = init.palette.map(color => Ui.Color.create(color));
                if (init.alpha !== undefined)
                    this.alpha = init.alpha;
            }
        }
        set onchanged(value) { this.changed.connect(value); }
        ;
        set palette(palette) {
            this._palette = palette.map(color => Ui.Color.create(color));
        }
        get palette() {
            return this._palette;
        }
        set value(color) {
            this.color = color;
            this.rect.fill = this.color;
            this.changed.fire({ target: this, value: this.color });
        }
        get value() {
            return this.color;
        }
        onColorButtonPress() {
            let popup = new Ui.MenuPopup();
            let lbox = new Ui.LBox({ padding: 10 });
            popup.content = lbox;
            let vbox = new Ui.VBox({ spacing: 10 });
            lbox.content = vbox;
            let colorChooser = new ColorChooser({
                value: this.color, alpha: this.alpha,
                onchanged: e => this.value = e.value
            });
            vbox.append(colorChooser);
            if (this.palette.length > 0) {
                let flow = new Ui.Flow({ spacing: 5 });
                vbox.prepend(flow);
                for (let color of this.palette) {
                    flow.append(new Ui.Pressable({
                        content: new Ui.Rectangle({ width: 32, height: 32, fill: color }),
                        onpressed: () => { colorChooser.value = color; this.value = color; }
                    }));
                }
            }
            popup.openElement(this, 'left');
        }
        onStyleChange() {
            super.onStyleChange();
            let size = this.getStyleProperty('iconSize');
            this.rect.width = size;
            this.rect.height = size;
        }
    }
    Ui.ColorButton = ColorButton;
})(Ui || (Ui = {}));
//# sourceMappingURL=era.js.map